---
title: Mybatis映射文件（1）
date: 2018-08-07 20:01:09
categories:
    - Mybatis
tags:
    - Mybatis
    - Basic
    - Java
---

MyBatis是针对SQL构建的。它的强大在于映射语句，且映射器的XML文件相对简单。与相同功能的JDBC代码相比，会节约近95%代码。

<!-- more -->

##### 目录

> MyBatis的SQL映射文件有很少的几个顶级元素，它们也有一定的定义顺序，可[参见官网](http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html)。这里按常用的顺序先介绍如下几个

+ I.CRUD标签
+ II.sql片段
+ III.#{}和${}
+ IV.传参接参
+ V.参考

---

# I.CRUD标签

#### 1.select

> 该标签的属性比update、delete、insert要多，体现出select的使用较频繁，具体属性参考[官方文档](http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#select)，以下介绍常用的简单属性

- id：当前名称空间下的该statement的唯一标识，必填。一般id和mapper接口中的方法的名字一致。(使用动态代理之后，必须一致)
- resultType：将结果集映射为java的对象类型，必填（和resultMap二选一）
- parameterType：传入参数类型，可省略

```
<select id="queryUserById" resultType="com.baicai.mybatis.pojo.User" parameterType="long">
    select * from tb_user where id = #{id}
</select>
```

#### 2.insert

> insert和update/delete相比，多了几个主键回写的属性。另外它们3个都没有resultType/resultMap属性(有selectKey)

- id属性：同上
- parameterType：传入的参数类型，可省略
- 特有属性：主键回写（useGeneratedKeys开启主键回写，将keyColumn字段的值，回显到对象的keyProperty属性中，直接代码中user.getId()即可获取到）

```
<insert id="insert" parameterType="User" useGeneratedKeys="true" keyColumn="id" keyProperty="id">
    INSERT INTO tb_user(id, user_name, password, name, age, sex, birthday, created, updated) 
    VALUES(null, #{username}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, now(), now())
</insert>
```

> - 关于主键回写，官方给出两种方式，这里是其中一种
> - oracle没有自增主键，只能使用第二种，即selectKey，而MySQL和SQL Server支持自动生成主键的字段，可以上述这种方式，详见[官方文档](http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#insert_update_and_delete)

#### 3.update

- id属性：同上
- parameterType：传入的参数类型，可省略
- 也可以回写主键(只能使用selectKey的方式)，但是本身就是根据id修改，所以意义不大

```
<update id="update" parameterType="User">
    UPDATE tb_user SET user_name = #{username}, password = #{password}, name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday}, updated = now() 
    WHERE id = #{id}
</update>
```

#### 4.delete

- id属性：同上
- parameterType：传入的参数类型，可省略

```
<!-- 全名应该是java.lang.Long,这里用Long/long，甚至lOnG都可以 -->
<delete id="deleteById" parameterType="long">
    DELETE FROM tb_user WHERE id = #{id}
</delete>
```

---

# II.sql片段

> 一般配合include标签使用。两种常用用途和两种使用方式

#### 1.用途

- 1.1 抽取字段，便于重用

```
<sql id="columns">id, user_name, password, name, age, sex, birthday, created, updated</sql>
```

```
<select id="queryUserById" resultType="User" parameterType="long">
    select <include refid="columns" /> from tb_user where id = #{id}
</select>
```

- 1.2 其他复杂片段拼接

```
<sql id="sometable">${prefix}Table</sql>
<sql id="someinclude">From <include refid="${include_target}"/></sql>

<select id="select" resultType="map">
  Select field1, field2, field3
  <include refid="someinclude">
    <property name="prefix" value="Some"/>
    <property name="include_target" value="sometable"/>
  </include>
</select>

#最后的语句
Select field1, field2, field3 From SomeTable
```

#### 2.使用方式

- 1.在自身XxxMapper.xml中定义，如上。通过id直接引用
- 2.单独提取出公共的sql片段xml，需要在全局配置中引入。引用时使用namespace.id

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="sqlSegment">
    <sql id="columns">id, user_name, password, name, age, sex, birthday, created, updated</sql>
</mapper>
```

```
<!-- 在全局配置文件中引入该xml文件 -->
<mappers>
    <mapper resource="UserMapper.xml" />
    <mapper resource="sqlSegment.xml" />
</mappers>
```

```
<!-- 使用namespace.id引用 -->
<select id="queryUserById" resultType="User" parameterType="long">
    select <include refid="sqlSegment.columns" /> from tb_user where id = #{id}
</select>
```

---

# III.#{}和${}

> - #{}与${}是取参数值的两种方式
> - 使用原则：非表字段使用${}拼接，表字段用#{}预编译占位（非表字段用#{}会报语法错误）

|取参方式 | 区别|
|:--------|:----|
|${} |1.用?占位，相当于PreparedStatement使用占位符去替换参数<br>2.可以防止sql注入（1=1 and..）<br>3.不需要手动判断参数的数据类型|
|#{}| 1.字符串直接拼接，相当于Statement使用字符串直接拼接sql<br>2.不能防止sql注入<br>3.需要手动判断参数的数据类型|

> 另外，两者在使用细节上也稍有不同，但不是根本区别，也取决于参数类型和个数

> 关于${}需要判断参数类型

```
public User queryUserByUsername(@Param("username") String username);

<select id="queryUserByUsername" resultType="User">
<!-- ${username}会取到连接池的username=root哦，#{}预编译占位，不会 -->
  <!-- SELECT * FROM tb_user WHERE user_name = '${username}' -->
  SELECT * FROM tb_user WHERE user_name = '${param1}'
  <!-- SELECT * FROM tb_user WHERE user_name = #{username} -->
  <!-- SELECT * FROM tb_user WHERE user_name = #{param1} -->
</select>
```

> TODO：MySQL隐式转换

> 关于#{}和${}模糊查询的拼接

```
public List<User> queryUserLikeUsername(@Param("username") String username);

<select id="queryUserLikeUsername" resultType="User">
  <!-- ${}单引号双引号都可以；${username}会取到连接池的username=root哦 -->
  <!-- SELECT * FROM tb_user WHERE user_name LIKE '%${param1}%' -->
  <!-- SELECT * FROM tb_user WHERE user_name LIKE "%${param1}%" -->
  <!-- SELECT * FROM tb_user WHERE user_name LIKE "%${username}%" -->
  <!-- #{}只能用双引号 -->
  <!-- SELECT * FROM tb_user WHERE user_name LIKE "%"#{param1}"%" -->
  <!-- SELECT * FROM tb_user WHERE user_name LIKE CONCAT("%",#{username},"%") -->
  SELECT * FROM tb_user WHERE user_name LIKE "%"#{username}"%"
</select>
```