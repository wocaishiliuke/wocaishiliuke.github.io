---
title: Git整理
date: 2018-03-16 19:01:09
categories:
    - Tools
tags:
    - Git
---

本文介绍Git的基本使用

<!-- more -->

##### 目录
+ I.简介
+ II.集中式vs分布式
+ III.安装和配置
+ IV.概念
+ V.流程
+ VI.常用命令
+ VII.参考

---

# I.简介

Git是一个开源的分布式版本控制系统，由Linus使用C编写，起初是为了解决Linux代码的版本管理问题（关于Git的由来，可自行搜索）

> 版本控制系统目前分为集中式和分布式，都是为了解决手动管理文件版本困难的问题。集中式的代表CVS和SVN，CVS是最早开源免费的集中式版本控制系统，但稳定性较差。随后SVN修正了CVS的稳定性问题，成为应用最多的集中式版本控制系统。


---

# II.集中式vs分布式

集中式版本控制系统和分布式版本控制系统的比较，以SVN和Git对比。最主要的区别就在于模式：

- SVN是集中式，版本库存放在中央服务器，即必须要有中央服务器
- Git是分布式，每个终端都有一个完整的版本库，即本地仓库（可以没有中央服务器，但这样终端之间提交合并修改比较麻烦。为了方便交换修改，一般也需要中央服务器）。不需要联网就可以开发（大部分时确实如此），联网时再提交修改

另外在元数据存储方式、分支管理等方面也有差异，这里不做详述。

> 其实在局域网中，开发团队人数较少时，SVN还是可以的

> **所有的版本控制系统,只能跟踪文本文件的改动，如txt、java、html等。对于二进制文件，如图片、Word、视频等，只能跟踪是否改变，无法跟踪文件的具体变化**

---

# III.安装和配置

Ubuntu上安装Git很简单，可参考[Ubuntu环境搭建](http://blog.wocaishiliuke.cn/linux/2018/06/02/Ubuntu01/)。这里另外汇总了各平台安装方式

## 1.安装

#### 1.1 Linux

- Debian或Ubuntu

```shell
# 有没有安装Git
$ git
# 安装
$ sudo apt-get install git
```

老一点的Debian或Ubuntu Linux：（因为以前有个软件也叫GIT（GNU Interactive Tools），而当时Git叫git-core）

```shell
$ sudo apt-get install git-core
```

- 其他Linux版本

直接通过源码安装。从Git官网下载源码，解压编译安装

```shell
$ ./config
$ make
$ sudo make install
```

#### 1.2 Mac

两种安装方式
    
- 1.安装homebrew，通过homebrew安装Git，具体方法请参考[homebrew文档](http://brew.sh/)
- 2.更简单，推荐。从AppStore安装Xcode，Xcode集成了Git。不过默认没有安装，需要运行Xcode，选择菜单"Xcode->Preferences"，在弹出窗口中找到Downloads，选择Command Line Tools，点Install完成安装。

#### 1.3 Windows

msysgit是Windows版的Git，从[msysgit](https://git-for-windows.github.io)下载（网速慢请移步国内镜像），按默认选项安装即可。一般使用Git Bash命令窗口操作（默认目录是c/user/top）


## 2.配置

#### 2.1 全局配置

安装完成后需要配置用户名和Email地址

```shell
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
$ git config -l
```

> global参数表示机器上所有Git仓库都会使用该配置，也可以对单个仓库指定不同的用户名和Email

#### 2.2 ssh密钥配置

以GitHub为例，本地Git仓库和GitHub仓库之间的传输是通过SSH协议（也可以https）

- 1.创建SSH Key

```shell
$ ssh-keygen -t rsa -C "youremail@example.com"
```

> 一路回车，不修改文件名，也无需设置密码。密钥对生成在用户目录下的.ssh目录（如c/user/zhouyu/.ssh）。其中.id_rsa是私钥，需要安全保存，id_rsa.pub是公钥

- 2.将id_rsa.pub公钥内容配置到GitHub，这样本地库和GitHub上的库就可以传输了

> 关于多SSH密钥对配置（Github、GitLab、码云...），可参考[Ubuntu环境搭建](http://blog.wocaishiliuke.cn/linux/2018/06/02/Ubuntu01/)


---

# IV.概念

## 1.仓库

#### 1.1 本地

|概念|名称|说明|
|:---|:--|:--|
|Working Directory|工作目录|工作目录是对项目的某个版本独立提取出来的内容。是从本地库.git中的压缩数据库中提取出来的文件，放在磁盘上供开发人员使用或修改|
|Staging Area|暂存区|暂存区是个文件，保存了下次将要提交的文件列表信息，一般在.git目录中，也常称为索引|
|.git directory|本地仓库|即.git目录，用来保存项目的元数据和对象数据库，是Git中最重要的部分。从其它计算机克隆仓库时，拷贝的就是这里的数据|

> 上述三个概念，对应3种状态：modified（已修改）、staged（已暂存）、committed（已提交）。另外Untracked（未跟踪）表示从未被添加的文件，属于Working Directory中。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Tools/git-local-flow.jpeg)

> 切换分支时，Git会重置工作目录，回到在该分支上最后一次的提交

Git的基本工作流程：

- 1.在工作目录中修改文件
- 2.暂存文件，将文件快照放入暂存区
- 3.提交更新，找到暂存区的文件，将快照永久存储到.git本地仓库目录

> Git跟踪的是修改，不是文件。即add之后再修改该文件，需要再次add，否则后续的修改不会进入暂存区，也就不会被commit到本地仓库

#### 1.2 远程

远程仓库：即Git服务器上的仓库。一般自己创建origin，或从别人的upstream远程仓库（要贡献的项目）fork到自己的origin

- **源分支**upstream：   用于同步上游仓库（同步别人的修改，不用每次都fork，merge即可）

## 2.分支

master分支要求稳定，不做开发修改，仅用来版本发布。所以常用其他分支用来开发


---

# V.小流程

这里以GitHub为例，其他平台类似

## 1.本地项目推送到GitHub

场景：本地先创建了工程，想要保存到GitHub

- 1.在本地工程目录，创建本地仓库（注意添加.gitignore和README.md）

```shell
cd demo/
git init
```

> 会生成.git目录，该目录用来跟踪管理本地版本库

- 2.在Github创建同名远程仓库origin
- 3.为本地仓库添加远程仓库origin地址

```shell
git remote add origin ssh://git@git.91demo.com:10022/demo/demo.git
```

- 4.此时即可向origin提交修改了

```shell
git status
git diff xxx.java
git add xxx.java
git commit -m "first commit"
git push origin master
```

> 这里使用master分支直接开发和提交。通常会切换分支开发，然后将该分支修改合并到master提交（或者在GitHub上提merge request：origin/branch1-->origin/master）

## 2.检出自己的项目

场景：在新电脑上拉去GitHub上自己的项目

```shell
# 克隆自己的远程仓库
git clone ssh://git@git.91demo.com:10022/zhouyu/demo.git
# 查看远程仓库列表（默认有origin）
git remote -v
# 默认有master分支
git status
```

> 随后即可进行修改和提交。更新/推送可直接使用pull/push

## 3.检出和同步别人的项目

场景：公司开发或贡献开源项目

- 1.在GitHub/GitLab上fork上游远程仓库upstream（别人的），即创建远程仓库origin（自己的）
- 2.从origin上clone项目，即创建本地库

```shell
git clone ssh://git@git.91demo.com:10022/zhouyu/demo.git
```
- 3.进入本地库，添加upstream，便于以后更新

```shell
git remote add upstream ssh://git@git.91demo.com:10022/demo/demo.git
git remote -v
```

- 4.如果从origin上clone的不是最新代码，和upstream不一致（一般fork后立马clone的，都一致。除非别人在此期间更新了upstream），完成和upstream的master同步

```shell
$ git fetch upstream
$ git merge upstream/master
```

> 随后即可进行修改和提交到origin，再提交merge request到upstream。更新就使用fetch

## 4.分支开发

场景：最常见的创建分支开发，如修复BUG

> 注意每次开发最好从master主分支切分支

```shell
# 当前分支
$ git branch
* master
# 新建并切换分支
$ git checkout -b dev
# 当前分支
$ git branch
* dev
  master

# 在dev分支进行修改
...

# 在dev分支commit
$ git add README.md
$ git commit -m "commit2"
# 切回master，把dev的提交合并到master
$ git checkout master
$ git merge dev
# 开发完成后可以选择性的删除dev
$ git branch -d dev
```

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Tools/git01_01.png)

> 也可以在dev上直接push到origin/dev，然后提merge request，合并到origin/master（即在远程合并分支）

## 5.分支切换时带走修改

**changes to files are not tied to a particular branch until you commit them**，所以在分支切换时会带走修改，建议commit或stash后再切换分支

## 6.冲突解决

场景：合并分支时，各分支的文件修改冲突

```shell
# 1.从master切到新分支
$ git checkout -b dev

# 2.修改README.md，最后一行添加：dev modify

# 3.dev上提交
$ git add README.md
$ git commit -m "commit2"

# 4.切回master
$ git checkout master

# 5.修改README.md，最后一行添加：master modify

# 6.master上提交
$ git add README.md
$ git commit -m "commit3"

# 7.在master分支合并dev分支，发生冲突
$ git merge dev
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result
# 8.查看冲突文件
$ git status
$ cat README.md
test
<<<<<<< HEAD
master modify
=======
dev modify
>>>>>>> dev

# 9.手动修改冲突

# 10.再提交
$ git add README.md
$ git commit -m "conflict fixed commit4"

# 11.查看分支合并图
$ git log --graph --pretty=oneline --abbrev-commit

# 12.选择性删除分支
$ git branch -d dev
```

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Tools/git01_02.png)

## 7.多分支同时开发和冲突处理

场景：多分支开发

```shell
# 1.从master创建并切换到分支iss53
$ git checkout -b iss53
# 2.在iss53开发
$ vim index.html

# 此时需要紧急修复另一BUG

# 3.可以暂存或提交iss53的修改（stash前也要add）
$ git add index.html
# $ git stash
$ git commit -a -m 'iss53 commit2'

# 4.切回master，再从master创建分支hotfix
$ git checkout master

# 5.修复BUG
$ git checkout -b hotfix
$ vim index.html
$ git add .
$ git commit -a -m 'fixed bug commit3'
$ git checkout master
$ git merge hotfix
$ git branch -d hotfix

# 6.继续iss53的工作
$ git checkout iss53
# 如果之前不是commit，而是stash，需要弹出之前未提交的修改
# $ git stash pop
# 如果想在iss53分支拉取hotfix的修改（需要使用修改的最新代码），将master合并到iss53分支即可
# $ git merge master

# 或者完成iss53分支开发后，再合并到master。下面继续完成iss53开发commit4

# 将iss53合并到master
$ git checkout master
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
$ git branch -d iss53
```

> 最后在三方合并时，有可能出现冲突，解决后再提交即可

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Tools/git01_03.png)

> - **1.在从iss53分支切换回master之前，工作目录和暂存区里还没有提交的修改，可能会和你即将检出的分支产生冲突从而阻止Git切换到该分支。所以，切换分支之前，需要保持好一个干净的状态：stash或commit**
> - **2.在master合并iss53分支的时候，由于iss53是从更早的commit1处分叉开来（diverged），此时master的最新提交不是iss53分支的直接祖先，Git会使用两个分支的末端的快照（C3和C4）以及这两个分支的祖先（C1）做一个简单的三方合并**
> - **3.和之前的分支指针向前推进所不同的是，Git会将此次三方合并的结果做一个新的快照并且自动创建一个新的提交指向它，称为一次合并提交，该commit的特别之处在于他有不止一个父提交**
> - **4.在上述三方合并中，Git会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础，这和CVS等不同（在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础），Git将该过程更加简化**


## 8.删除GitHub上文件

#### 如果同时删除本地的

可以直接删除本地的，再push就行了

#### 如果不删除本地的

适合删除GitHub上，误提交但需要忽略的文件等

> 实质就是删除缓冲区里的文件，再提交给服务器端

- 在分支master/其他分支，ll查看要删除的文件夹，如.metadata(在GitHub上查看也可以)

```shell
# --cached只删暂存区的，不删本地仓库的。而git rm -r –cached . 是删除所有，暴力
git rm -r --cached .metadata/
git status
# 因为操作的缓冲区不是本地仓库，所以不用add直接commit
git commit -m "删除.metadata"
git push orgin 对应分支
```

> ll查看本地还在，但github上就不在了

## 9.回退

#### 回退修改

```shell
# 撤回add前的修改，包括删除操作（如果该文件加入到暂存区后又修改，会撤回到加入暂存区后的修改状态）
git checkout xxxx

# 撤回add后的修改，由暂存区回退到工作目录，修改依然存在
git reset HEAD xxx
```

#### 回退版本

Git将每次commit串联成时间线（UI界面可见）。版本回退时，其实就是改变HEAD指针的位置（HEAD指向当前版本）

> Git的commitID是使用SHA1计算的（和SVN的1、2、3递增数字不同，因为Git是分布式的，多人开发，commitID需要保持唯一）

```shell
# 提交日志，可选参数表示只显示一行
git log [--pretty=oneline]

# 回退到上一个commit版本
git reset --hard HEAD^
# 回退到上上一个commit版本
git reset --hard HEAD^^
# 回退到上100个commit版本
git reset --hard HEAD~100
# 根据commitID回退
git reset --hard commitID
```

> 如果不想回退了，想返回最新的提交，可以查看之前命令行中最新commit的ID，进行回退的撤销。如果命令行已关闭，Git提供了查看以往操作命令日志的命令，根据提交描述找到对应commit的ID（也可在GitHub上查看），进行回退的撤销

```shell
# 查看以往操作命令日志
git reflog
```

## 10.撤销或绑定commit到其他branch

场景：在错误的分支开发，并commit，需要回退，并在理应提交的分支上合并commit

- 1.将错误commit绑定到预期分支
- 2.删除原commit（可选）

```shell
# 1.在错误的分支，找到误提交commit
$ git log --oneline
54fd74d (HEAD -> master) modify for cherry-pick on master
620d74e (master) master分支添加1.md

# 2.切换到正确的分支，合并提交
$ git checkout iss53
$ git cherry-pick 54fd74d
# 如果没有共同修改，就没有冲突；如果有冲突，解决冲突
error: could not apply 54fd74d... modify for cherry-pick on master
hint: after resolving the conflicts, mark the corrected paths
hint: with 'git add <paths>' or 'git rm <paths>'
hint: and commit the result with 'git commit'
$ git status
On branch iss53
You are currently cherry-picking commit 54fd74d.
  (fix conflicts and run "git cherry-pick --continue")
  (use "git cherry-pick --abort" to cancel the cherry-pick operation)
Unmerged paths:
  (use "git add <file>..." to mark resolution)
    both modified:   1.md
$ vim 1.md
$ git cherry-pick --continue
U   1.md
error: Committing is not possible because you have unmerged files.
hint: Fix them up in the work tree, and then use 'git add/rm <file>'
hint: as appropriate to mark resolution and make a commit.
fatal: Exiting because of an unresolved conflict.
$ git add .
$ git cherry-pick --continue
[iss53 0e98d0d] modify for cherry-pick on master
 Date: Mon Dec 24 12:20:01 2018 +0800
 1 file changed, 1 insertion(+)

# 3.查看合并的commit（ID与master上的该commit不同）
$ git log --oneline 
0e98d0d (HEAD -> iss53) modify for cherry-pick on master
9a0d280 iss53 modify1
620d74e (master) master分支添加1.md

# 4.删除（master）原commit
$ git checkout master 
$ git log --oneline
54fd74d (HEAD -> master) modify for cherry-pick on master
620d74e (master) master分支添加1.md
$ cat 1.md
$ git reset HEAD~1
Unstaged changes after reset:
M   1.md
$ git log --oneline
620d74e (master) master分支添加1.md
```

---

# VI.常用命令

## 基本命令

```shell
git --help
git config -l

# 查看当前分支的修改文件
git status
# 查看文件改动内容
git diff xxxx
# 添加到暂存区，包括添加未跟踪文件（变绿）
git add xxxx
# 提交到本地库
git commit -m "V2.4.0_#111修改完成"
# 本地库推送到origin，同时在origin创建同名分支
git push origin V2.4.0_#111
# push后再提merge request

# 撤回add前的修改（如果该文件加入到暂存区后又修改，会撤回到加入暂存区后的修改状态）
git checkout xxxx
# 用于删除文件操作，将修改保存到暂存区，此时相当于git add want_delete_file
git rm want_delete_file
# add后，由暂存区回退到工作目录，修改依然存在
git reset HEAD xxx
```

## 分支命令

```shell
# 查看分支：r远程分支，a本地分支和远程分支
git branch [-a][-r]

# 新建分支
git branch branchname
git checkout branchname
# 相等于上述两条
git checkout -b branchname

# 使用-m重命名分支，如果newbranch分支已存在，需要使用-M强制重命名
git branch -m | -M oldbranch newbranch 

# 删除分支
git branch -d | -D branchname
# 批量强删带有'V2.4.0'的分支
git branch |grep 'V2.4.0'|xargs git branch -D     
# 删除远程分支（只是删除本地的索引，不是真正删除远程分支的内容）   
git branch -d -r branchname
# 删除远程分支（真正删除远程分支上的内容）
git push origin : branchname
```

## 其他命令

```shell
# 暂存修改
git stash
# 弹出修改
git stash pop
# 查看栈
git stash list

# 添加远程仓库
git remote add origin/upstream ssh或https...
# 修改origin的地址
git remote set-url origin ssh或https...
```


---

# VII.参考

- [Reference](https://git-scm.com/docs)
- [Pro Git Book](https://git-scm.com/book/zh/v2)
- [廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)