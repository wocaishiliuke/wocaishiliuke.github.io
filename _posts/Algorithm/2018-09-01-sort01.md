---
title: 排序（一）
date: 2018-09-01 19:02:09
categories:
    - Algorithm
tags:
    - Algorithm
    - Sort
    - Java
---

排序是计算机中最基本的算法之一，其他很多算法都是以排序算法为基础，排序在日常生活中也处处可见。本文将介绍一些排序算法和基于的Java实现。

<!-- more -->

##### 目录
+ I.简介
+ II.直接插入排序


---

# I.简介

#### 1.定义

- 排序：将记录，按关键字递增或递减的次序，排列起来。确切定义为：

> n条记录R1,R2,...,Rn,对应关键字分别为K1,K2,...,Kn。排列成Ril,Ri2,...,Rin,使得 Ki1≤Ki2≤...≤Kin（或 Ki1≥Ki2≥...≥Kin）

- 概念：
    + 记录：需要排序的列表元素。一条数据可有多个数据项（属性）
    + 关键字：记录的某一项属性，排序的依据，关键字项（key），一般为数字或字符类型

- 稳定性

> - 当所有记录的关键字均不相同时，排序结果是唯一的，否则排序结果不唯一
> - 若存在多个关键字相同的记录，经排序后，这些具有相同关键字的记录之间的相对次序保持
不变，则该排序方法是稳定的；否则即使只有一处次序改变，也是不稳定的

- 成本
    + 时间复杂度：一次排序执行完成，所耗费的时间
    + 空间复杂度：执行一次排序，所需的内存大小

#### 2.分类

- 2.1 按排序地点

> - 内部排序：在排序过程中，所有记录都在内存中处理，不涉及数据的内、外存交换
> - 外部排序：反之，在排序过程中需要进行数据的内、外存交换的，称之为外部排序

> 内部排序适合记录个数不多，外排序则适用于记录数太多，不能一次将全部记录放入内存的情况

> 内部排序由分为：
> 
> - 插入排序
>     + 直接插入排序
>     + 希尔排序
> - 选择排序
>     + 简单选择排序
>     + 堆排序
> - 交换排序
>     + 冒泡排序
>     + 快速排序
> - 归并排序
> - 基数排序

#### 3.比较

|排序算法|最好情况|最坏情况|平均时间复杂度|空间复杂度|稳定性|说明|
|:----:|:----:|:-----:|:----------:|:------:|:---:|:----|
|直插排序|

# II.直接插入排序 Insertion Sort

#### 原理

> 构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入（可以一次挪动后面的有序记录，也可以每次比较后挪动）

#### 步骤

> - 1.待排序的记录存放在数组R[1..n]中
> - 2.初始时，R[1]自成1个有序区，无序区为R[2..n]
> - 3.依次将R[i]（i=2...n）插入当前的有序区R[1..i-1]中，最终生成含所有n个记录的有序区

> 直接插入排序的基本操作是，将当前无序区的第1个记录 R[i]插人到有序区R[1..i-1]中适当的位置上,使
R[1..i]变为新的有序区。这种方法每次使有序区增加1个记录,通常称为增量法

#### 实现

```
//对顺序表R中的记录R[1..n]按递增序进行插入排序
void insertSort(SeqList R){ 
    int i,j;
    //依次插入R[2],...,R[n]
    for(i=2; i<=n; i++) {
        //当R[i]大于等于有序区中所有的记录，则R[i]应在原有位置上；否则，才进行从后向前的逐一比较
        if(R[i] < R[i-1]) {
            R[0] = R[i];            //R[0]是哨兵,且是R[i]的副本
            j = i-1;    
            do{                     //从右向左在有序区R[1..i-1]中查找R[i]的插入位置
                R[j+1] = R[j];      //将大于R[i]的记录后移
                j--;
            }while(R[0] < R[j]);    //终止逐一比较的条件
            R[j+1] = R[0];          //将R[i]插入到正确位置
        }
    }
}
```

> - 一切为简化边界条件而引入的附加结点(元素)均可称为哨兵。这里哨兵有两个作用
>     + 1.保存R[i]的副本，避免因索引后移而丢失R[i]
>     + 2.监视下标变量j是否越界。一旦越界(即j=0)，R[0]<R[j]循环条件不成立，使得查找循环结束,从而避免了在while循环内每一次均要检测j是否越界(即省略了循环判定条件j>=1)，每次判断条件时间减半，当数据量较大时，哨兵的作用不可忽视。

```
/**
     * 直插排序（从小到大）Java实现（数组arr[0]也是参与排序的记录，无法做哨兵）
     * @param arr
     * @return
     */
    private static int[] insertionSort(int[] arr) {
        if (arr == null || arr.length <= 1) return arr;
        /* 1.current：不是哨兵，只保存当前要插入记录的副本，不做越界控制
           2.cursor：逐一比较的游标 */
        int current,cursor;
        // 将arr[1]到arr[n-1]逐个插入到有序区。初始有序区：arr[0]
        for (int i = 1; i < arr.length; i++) {
            // 当要插入的arr[i]>arr[i-1]，即大于有序区所有记录，则保持不动，否则才进行逐一比较
            if (arr[i] < arr[i-1]) {
                current = arr[i];
                cursor = i - 1;
                // 从后向前逐一比对
                do {
                    arr[cursor + 1] = arr[cursor];  // 后移有序区记录
                    cursor--;                       // 游标前移
                }while (cursor >= 0 && current < arr[cursor]);
                // 比对完，插入arr[i]到正确的位置
                arr[cursor + 1] = current;
            }

            /* 
            //while实现方式
            current = arr[i];
            cursor = i - 1;
            while (cursor >= 0 && current < arr[cursor]) {
                arr[cursor + 1] = arr[cursor];
                cursor--;
            }
            arr[cursor + 1] = current;*/
        }
        return arr;
    }
```

#### 分析

> 共n条记录，即需要n-1趟比较

- 1.时间复杂度

|排序前状态|正序|反序|无序（平均）|
|:-------|:--:|:--:|:-------:|
|第i趟比较次数|1(只比较if)|i+1(if+while)|(i+2)/2|
|总比较次数|n-1|2+3+..+n=(n-1)(n+2)/2|≈n^2/4|
|第i趟移动次数|0|i+1|(i+1)/2|
|总移动次数|0|2+3+..+n=(n-1)(n+2)/2|≈n^2/4|
|时间复杂度|O(n)|O(n^2)|O(n^2)|

- 2.空间复杂度

> 所需的辅助空间是一个监视哨或副本，辅助空间复杂度S(n)=O(1)，是个就地排序

- 3.稳定性

> 稳定。具有相同key的记录，每次排序后相对位置不变

# III.希尔排序 Shell Sort

> 是插入排序的一种，是简单插入排序的改进，由D.L.Shell于1959年提出，也称缩小增量排序，该算法是冲破O(n2）的第一批算法之一。

#### 原理

> - 先取整数d1(d1<n)作为第一个增量，把n条记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插人排序
> - 然后，取第二个增量d2<d1<n ,重复上述的分组和组内直插排序
> - 直至所取的增量dt=1(dt<dt-1<...<d2<d1<n)，此时所有记录放在同一组中进行直接插入排序，为止
> - 实质上是一种分组插入方法。如果d1=1，就是直插排序

#### 步骤

- 选择增量/间隔序列，这里我们简单使用希尔增量，d初始值为n/2。则增量为9,4,2,1
- 也就是进行4遍排序，第一遍分为9组，第二遍分为4组，第三遍分为2组，第四遍分为1组
- 每一遍排序，都对各组内进行直插排序。只不过组内直插时，比较的游标每次需要移动d

#### 实现

```
//对顺序表R中的记录R[1..n]按递增序进行希尔排序
void shellSort(SeqList R) {
    int increment = x;                      //增量初值,x<n
    do {
        shellPass(R,increment);             //一趟增量为increment的shell排序
        increment=increment / 2;            //下一增量
    }while(increment >= 1)
}

//希尔排序中的一趟排序，排序对象都是R，d为当前增量
void shellPass(SeqList R,int d) {
    for(i=d+1; i<=n; i++) {                 //将R[d+1..n]分别插入各组当前的有序区
        if(R[i] < R[i-d]){
            R[0] = R[i];                    //R[0]只是暂存单元,不是哨兵
            j = i - d;                
            do {                            //查找R[i]的插入位置
                R[j+d] = R[j];              //后移记录
                j = j - d;                  //指向前一个比较记录
            }while(j>0 && R[0] < R[j]);
            R[j+d] = R[0];                  //将R[i]插入到正确位置
        }
    }
}
```

> 当增量d=1时，该趟shellPass和整体直插排序一样，只不过有了前几趟的排序，使得R较有序，最后一趟的时间就会节省很多。只是由于没有哨兵，循环中增加了一个防止下标越界的条件j>0

```
public static void main(String[] args) {
    int[] arr = {3,51,34,7,53,89,6,5,21,17,14,108,8,46,91,28,7,21};
    int increment = arr.length;
        do {
            increment = increment / 2;
            arr = shellSort(arr,increment);          //排4次,increment=9,4,2,1
        }while (increment > 1);

    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i] + " ");
    }
}

/**
 * 希尔排序
 * @param arr
 * @param d
 * @return
 */
private static int[] shellSort(int[] arr, int d) {
    if (arr == null || arr.length <= 1) return arr;
    int mirror,cursor;
    //将各组的记录进行直插排序
    for (int i = d; i < arr.length; i++) {
        if (arr[i] < arr[i-d]) {
            mirror = arr[i];
            cursor = i - d;
            do {
                arr[cursor + d] = arr[cursor];
                cursor -= d;
            }while (cursor >= 0 && mirror < arr[cursor]);
            arr[cursor + d] = mirror;
        }

        /*
        mirror = arr[i];
        cursor = i - d;
        while (cursor >= 0 && mirror < arr[mirror]) {
            arr[cursor + d] = arr[cursor];
            cursor -= d;
        }
        arr[cursor + d] = mirror;*/
    }
    return arr;
}
```

> 断点调试，每趟排序的结果为：

```
3 14 34 7 46 89 6 5 21 17 51 108 8 53 91 28 7 21 
3 14 6 5 7 17 34 7 8 21 51 28 21 53 91 108 46 89 
3 5 6 7 7 14 8 17 21 21 34 28 46 53 51 89 91 108 
3 5 6 7 7 8 14 17 21 21 28 34 46 51 53 89 91 108
```

#### 分析

> - 需要多趟排序，增量序列的选择很重要，执行时间依赖于增量序列
> - 希尔自己推荐希尔增量{n/2,(n/2)/2...1}，但已被证明不是最优的，有时时间复杂度还会降低到O(n^2)，这并不比直插排序的效率更高
> - 增量序列中数字互质很重要，即除了1它们没有公约数。该约束条件可使每趟排序更有可能保持前一趟已排好的效果
> - 上述n/2的算法可以优化为n/2.2，即：8,3,1
> - Knuth提出使用h=h*3+1生成增量序列:1,4,13,40,121,364（后面就太大了），根据数组长度从中截取即可。如n=100时，可取40,13,4,1
> - 上述只是增量序列的一种计算方式，其他间隔序列也有很好的效果，最优的计算方式仍是个数学难题。**不管怎样的增量序列，最后一个值必为1，即最后需要整体的直接插入排序**

- 1.时间复杂度

> - 希尔排序时效分析很难，比较次数与移动次数依赖于增量因子序列的选取。有人通过大量的实验,给出：当n较大时,比较和移动的次数约在n^1.25到1.6n^1.25之间
> - 当n较小时，n和n^2的差别也较小
> - **希尔排序的性能优于直插排序，尤其是n较大时**,因为：
>     + 1.开始时，整体n大，但分组也较多，使得组内的长度k较小，插入排序较快（记录数较少时，直插排序最好和最差情况的k和k^2的差别也较小）
>     + 2.新一遍的排序是在上一遍排序后的基础上，即新的分组内已经基本有序，趋于直插的最好情况O(n)，所以新一遍排序也较快，尤其时最后一趟基本接近O(n)
>     + 3.因此，希尔排序在效率上，比直接插入排序有较大的改进

- 2.空间复杂度

> 所需的辅助空间也只是一个副本

- 3.稳定性

> 不稳定。具有相同key的记录，每次排序后相对位置会变化