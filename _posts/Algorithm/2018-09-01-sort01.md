---
title: 排序（一）
date: 2018-09-01 19:02:09
categories:
    - Algorithm
tags:
    - Algorithm
    - Sort
    - Java
---

排序是计算机中最基本的算法之一，其他很多算法都是以排序算法为基础，排序在日常生活中也处处可见。本文将介绍一些排序算法和基于的Java实现。

<!-- more -->

##### 目录
+ I.简介
+ II.直接插入排序


---

# I.简介

#### 1.定义

- 排序：将记录，按关键字递增或递减的次序，排列起来。确切定义为：

> n条记录R1,R2,...,Rn,对应关键字分别为K1,K2,...,Kn。排列成Ril,Ri2,...,Rin,使得 Ki1≤Ki2≤...≤Kin（或 Ki1≥Ki2≥...≥Kin）

- 概念：
    + 记录：需要排序的列表元素。一条数据可有多个数据项（属性）
    + 关键字：记录的某一项属性，排序的依据，关键字项（key），一般为数字或字符类型

- 稳定性

> - 当所有记录的关键字均不相同时，排序结果是唯一的，否则排序结果不唯一
> - 若存在多个关键字相同的记录，经排序后，这些具有相同关键字的记录之间的相对次序保持
不变，则该排序方法是稳定的；否则即使只有一处次序改变，也是不稳定的

- 成本
    + 时间复杂度：一次排序执行完成，所耗费的时间
    + 空间复杂度：执行一次排序，所需的内存大小

#### 2.分类

- 2.1 按排序地点

> - 内部排序：在排序过程中，所有记录都在内存中处理，不涉及数据的内、外存交换
> - 外部排序：反之，在排序过程中需要进行数据的内、外存交换的，称之为外部排序

> 内部排序适合记录个数不多，外排序则适用于记录数太多，不能一次将全部记录放入内存的情况

> 内部排序由分为：
> 
> - 插入排序
>     + 直接插入排序
>     + 希尔排序
> - 选择排序
>     + 简单选择排序
>     + 堆排序
> - 交换排序
>     + 冒泡排序
>     + 快速排序
> - 归并排序
> - 基数排序

#### 3.比较

|排序算法|最好情况|最坏情况|平均时间复杂度|空间复杂度|稳定性|说明|
|:----:|:----:|:-----:|:----------:|:------:|:---:|:----|
|直插排序|

# II.直接插入排序 Insertion Sort

#### 原理

> 构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入（可以一次挪动后面的有序记录，也可以每次比较后挪动）

#### 步骤

> - 1.待排序的记录存放在数组R[1..n]中
> - 2.初始时，R[1]自成1个有序区，无序区为R[2..n]
> - 3.依次将R[i]（i=2...n）插入当前的有序区R[1..i-1]中，最终生成含所有n个记录的有序区

> 直接插入排序的基本操作是，将当前无序区的第1个记录 R[i]插人到有序区R[1..i-1]中适当的位置上,使
R[1..i]变为新的有序区。这种方法每次使有序区增加1个记录,通常称为增量法

#### 实现

```
//对顺序表R中的记录R[1..n]按递增序进行插入排序
void lnsertSort(SeqList R){ 
    int i,j;
    //依次插入R[2],...,R[n]
    for(i=2;i<=n;i++) {
        //当R[i]大于等于有序区中所有的记录，则R[i]应在原有位置上；否则，才进行从后向前的逐一比较
        if(R[i]<R[i-1]) {
            R[0]=R[i];          //R[0]是哨兵,且是R[i]的副本
            j=i-1;    
            do{                 //从右向左在有序区R[1..i-1]中查找R[i]的插入位置
                R[j+1]=R[j];    //将大于R[i]的记录后移
                j-- ;
            }while(R[0]<R[j]);  //终止逐一比较的条件
            R[j+1]=R[0];        //将R[i]插入到正确位置
        }
    }
}
```

> - 一切为简化边界条件而引入的附加结点(元素)均可称为哨兵。这里哨兵有两个作用
>     + 1.保存R[i]的副本，避免因索引后移而丢失R[i]
>     + 2.监视下标变量j是否越界。一旦越界(即j=0)，R[0]<R[j]循环条件不成立，使得查找循环结束,从而避免了在while循环内每一次均要检测j是否越界(即省略了循环判定条件j>=1)，每次判断条件时间减半，当数据量较大时，哨兵的作用不可忽视。

```
/**
     * 直插排序（从小到大）Java实现（数组arr[0]也是参与排序的记录，无法做哨兵）
     * @param arr
     * @return
     */
    private static int[] insertionSort(int[] arr) {
        if (arr == null || arr.length <= 1) return arr;
        /* 1.current：不是哨兵，只保存当前要插入记录的副本，不做越界控制
           2.cursor：逐一比较的游标 */
        int current,cursor;
        // 将arr[1]到arr[n-1]逐个插入到有序区。初始有序区：arr[0]
        for (int i = 1; i < arr.length; i++) {
            // 当要插入的arr[i]>arr[i-1]，即大于有序区所有记录，则保持不动，否则才进行逐一比较
            if (arr[i] < arr[i-1]) {
                current = arr[i];
                cursor = i - 1;
                // 从后向前逐一比对
                do {
                    arr[cursor + 1] = arr[cursor];  // 后移有序区记录
                    cursor--;                       // 游标前移
                }while (cursor >= 0 && current < arr[cursor]);
                // 比对完，插入arr[i]到正确的位置
                arr[cursor + 1] = current;
            }

            /* 
            //while实现方式
            current = arr[i];
            cursor = i - 1;
            while (cursor >= 0 && current < arr[cursor]) {
                arr[cursor + 1] = arr[cursor];
                cursor--;
            }
            arr[cursor + 1] = current;*/
        }
        return arr;
    }
```

#### 分析

> 共n条记录，即需要n-1趟排序

- 1.时间复杂度

|排序前状态|正序|反序|无序（平均）|
|:-------|:--:|:--:|:-------:|
|第i趟比较次数|1(只比较if)|i+1(if+while)|(i+2)/2|
|总比较次数|n-1|2+3+..+n=(n-1)(n+2)/2|≈n^2/4|
|第i趟移动次数|0|i+1|(i+1)/2|
|总移动次数|0|2+3+..+n=(n-1)(n+2)/2|≈n^2/4|
|时间复杂度|O(n)|O(n^2)|O(n^2)|

- 2.空间复杂度

> 所需的辅助空间是一个监视哨或副本，辅助空间复杂度S(n)=O(1)，是个就地排序

- 3.稳定性

> 稳定：具有相同key的记录，每次排序后相对位置不变

# III.希尔排序 Shell Sort

> 是插入排序的一种。由D.L.Shell于1959年提出