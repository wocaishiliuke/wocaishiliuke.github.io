---
title: 字节流
date: 2018-01-21 00:00:00
categories:
    - JavaSE
tags:
    - JavaSE
---

本文讲述字节流的相关内容。

<!-- more -->

##### 目录
- I.概述
- II.InputStream/OutputStream
- III.ByteArrayInputStream/ByteArrayOutputStream
- IV.FileInputStream/FileOutputStream
- V.FilterInputStream/FilterOutputStream

---
# I.概述

上篇提到，Java中的文件被当做IO设备来处理，并且通过流进行操作。流又可以细分为字节流、字符流。其中，字节流的继承体系如下：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/JavaSE/io/java_input_stream_system.png)

本文重点介绍如下几种字节流：

- InputStream/OutputStream：基类
- ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流
- FileInputStream/FileOutputStream: 输入源和输出目标是文件的流
- FilterInputStream/FilterOutputStream：所有包装流（有"特殊"功能的流）的父类，如DataInputStream/DataOutputStream、BufferedInputStream/BufferedOutputStream都继承自该类
- ObjectInputStream/ObjectOuputStream：输入源和输出目标是对象的流，用于实现Java序列化


---
# II.InputStream/OutputStream

InputStream和OutputStream抽象类，是所有字节流的基类。

## 1.InputStream

```java
public abstract class InputStream implements Closeable
```

#### 1.1 read()

该方法会从字节输入流中读取下一个字节，返回字节的int值（一个字节8位，范围0~255，所以可以用int表示）。

```java
// 从字节输入流中读取下一个字节，返回值为读取字节的int值
public abstract int read() throws IOException;
```

- 当读到流结尾时，返回值为-1
- 如果字节输入流中没有数据，read()会阻塞，直到数据到来、流关闭、或异常出现
- 当异常出现时，read()抛出IOException（checked exception），调用者必须处理，否则编译通不过

#### 1.2 read(byte b[])

该方法会将从字节输入流读取的字节，放入字节数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推。一次最多读入b.length个字节，实际读入的字节数可能小于数组长度。返回值为实际读入的字节个数。

```java
// 从字节输入流中读取多个字节，放入字节数组b中，返回值为实际读入的字节个数
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}
```

- 如果刚开始读取时已到流结尾，则返回-1；否则，只要数组长度大于0，该方法都会至少读取一个字节
- 如果流中一个字节都没有，它也会阻塞直到数据到来、流关闭、或异常出现
- 该方法不是抽象方法，InputStream提供了一个默认实现，通过调用读一个字节的read方法实现，但子类中一般会提供更为高效的实现

#### 1.3 read(byte b[], int off, int len)

该方法会将读入的第一个字节放入b[off]，最多读取len个字节（所以返回值≤len）。

```java
// 从字节输入流中读取len个字节，放入字节数组b中off开始的位置，返回值实际读入的字节个数
public int read(byte b[], int off, int len) throws IOException {
    // 在read()基础上实现，具体参考源码
}
```

#### 1.4 close()

该方法用于字节输入流读取结束后，关闭流，释放相关资源。

```java
// 关闭字节输入流，释放资源
public void close() throws IOException {}
```

不管read()是否抛出异常，都要调用close()（一般放在finally内）。该方法不是抽象方法，InputStream没有具体实现，交由子类。

#### 1.5 skip(long n)

该方法会跳过字节输入流中的n个字节。由于输入流中剩余的字节个数可能不到n，所以返回值为实际略过的字节个数（≤n）。

```java
// 跳过字节输入流中n个字节，返回值为实际跳过的字节个数
public long skip(long n) throws IOException {
    // 具体参考源码
}
```

该方法非抽象，InputStream提供的默认实现，是调用read(byte b[], int off, int len)，尽力读取n个字节，实现skip效果。子类往往会提供更为高效的实现，比如在FileInputStream中会调用本地方法。在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。

#### 1.6 available()

该方法返回下一次不需要阻塞就能读取到的字节个数。

```java
// 返回下一次不需要阻塞就能读取到的字节个数，使用较少
public int available() throws IOException {
    return 0;
}
```

InputStream提供的默认实现是直接返回0，子类会根据具体情况返回适当的值。在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。

#### 1.7 mark(int readlimit)

该方法用于标记当前字节输入流读取的位置。当字节输入流已经读取过该位置后，可以通过调用reset()，重新从标记位置读取。

```java
// 标记能够从字节输入流中往后读取的字节个数readlimit
public synchronized void mark(int readlimit) {}
```

readLimit表示在设置了标记后，能够继续往后读的最多字节数，如果超过了，标记会无效。因为之所以能够重读，是因为流能够将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，流只保证不会小于readLimit。在InputStream中该方法是个空方法，具体需要子类根据自身情况覆写。

#### 1.8 markSupported()

该方法用于获取当前字节输入流是否支持mark/reset操作，true表示支持。

```java
// 判断当前字节输入流是否支持mark/reset操作
public boolean markSupported() {
    return false;
}
```

InpuStream类中的默认实现是不支持，子类根据自身情况覆盖该方法。

#### 1.9 reset()

该方法用于重新从mark标记位置读取字节输入流。

```java
// 重新从标记位置读取字节输入流
public synchronized void reset() throws IOException {
    throw new IOException("mark/reset not supported");
}
```

## 2.OutputStream

```java
public abstract class OutputStream implements Closeable, Flushable
```

#### 2.1 write(int b)

该方法向流中写入一个字节，参数类型虽然是int，但其实只会用到低8位（一个字节）。

```java
// 向字节输出流中写出一个字节
public abstract void write(int b) throws IOException;
```

该方法在OutputStream中是个抽象方法，需要子类实现。

#### 2.2 write(byte b[])

该方法会将字节数组b中的全部字节写出到字节输出流，在OutputStream中的实现依赖write(b, 0, b.length)。

```java
// 将字节数组b中所有的字节写出到字节输出流
public void write(byte b[]) throws IOException {
    write(b, 0, b.length);
}
```

#### 2.3 write(byte b[], int off, int len)

该方法会将字节数组中从off开始的len个字节，写出到字节输出流中。第一个被写出的字节是b[off]，最后一个是b[off+len-1]或b[b.length-1]。

```java
// 将字节数组b中从off开始，长度为len的字节写出到字节输出流
public void write(byte b[], int off, int len) throws IOException {
    // 具体参考源码
}
```

OutputStream的默认实现是循环调用单字节的write方法，子类往往有更为高效的实现。

#### 2.4 flush()

该方法会将缓冲而未实际写出的数据，进行写出。

```java
// 将缓冲而未实际写出数据进行写出
public void flush() throws IOException {
}
```

#### 2.5 close()

该方法会关闭字节输出流，释放系统资源。

```java
// 关闭字节输出流，释放资源
public void close() throws IOException {
}
```


---
# III.ByteArrayInputStream/ByteArrayOutputStream

```java
public class ByteArrayInputStream extends InputStream
public class ByteArrayOutputStream extends OutputStream
```

## 1.ByteArrayInputStream

ByteArrayInputStream的作用是将byte数组包装为一个输入流（适配器模式）。两个构造方法：

```java
// 将字节数组buf中的全部字节，都包装到ByteArrayInputStream
public ByteArrayInputStream(byte buf[]);
// 将字节数组buf中从offset开始长度为length的字节，包装到ByteArrayInputStream
public ByteArrayInputStream(byte buf[], int offset, int length);
```

第二个构造，是将buf[]中从offset到offset+len-1的字节，体现在ByteArrayInputStream中，read操作也只能读取到offset及之后的字节。ByteArrayInputStream的所有数据都在内存，支持mark/reset重复读取。

## 2.ByteArrayOutputStream

ByteArrayOutputStream的作用是将内存中的数据输出到byte数组，充当"管道"的角色。两个构造方法：

```java
public ByteArrayOutputStream();
public ByteArrayOutputStream(int size);
```

第二个构造函数中的size，是输出目的地字节数组的大小。第一个构造依赖第二个构造而实现，size默认为32。在调用write()向ByteArrayOutputStream流中写值时，如果字节数组长度不够，会进行动态扩容，扩展后的容量是扩容前容量的两倍。

```java
// 将ByteArrayOutputStream流中的内容输出到字节数组
public synchronized byte[] toByteArray()
// 使用系统编码，将ByteArrayOutputStream流中的内容（write操作写进来的字节数组）输出为字符串
public synchronized String toString()   
// 使用特定编码，将ByteArrayOutputStream流中的内容（write操作写进来的字节数组）输出为字符串
public synchronized String toString(String charsetName) 
// 将ByteArrayOutputStream中的数据，写到另一个OutputStream中
public synchronized void writeTo(OutputStream out) throws IOException   
// 返回当前已经写入到流的字节个数
public synchronized int size()  
// 重置ByteArrayOutputStream中的内容，之前写入的内容都会无效
public synchronized void reset()
```

## 3.示例

```java
@SneakyThrows
public static void main(String[] args) {
    byte[] bytes = Bytes.toArray(Lists.newArrayList(65, 66, 67, 68));

    try (InputStream is = new ByteArrayInputStream(bytes);
        ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        writeStream(is, os);
    }

    try (InputStream is = new ByteArrayInputStream(bytes, 1, 2);
        ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        writeStream(is, os);
    }
}

private static void writeStream(InputStream is, ByteArrayOutputStream os) throws IOException {
    byte[] buf = new byte[16];
    int bytesRead;
    while ((bytesRead = is.read(buf)) != -1) {
        os.write(buf, 0, bytesRead);
    }
    String data = os.toString("UTF-8");
    System.out.println(data);
}
```

> 输出

```
ABCD
BC
```

- Bytes.toArray()和Lists.newArrayList()是google Guava工具包提供的API
- 使用了Java8提供的语法糖try-with-resource，可以在try代码块执行结束，自动关闭打开的资源
- 第一个ByteArrayInputStream对象通过整个byte数组构造，第二个ByteArrayInputStream对象通过byte数组从1到2的字节构造
- output.write()将is中构造时读取的字节数组，写入到os中，再使用UTF-8编码将ByteArrayOutputStream中的内容输出为字符串


---
# IV.FileInputStream/FileOutputStream

```java
public class FileInputStream extends InputStream
public class FileOutputStream extends OutputStream
```

## 1.FileInputStream

FileInputStream是文件和内存之间的"通道"，是一种将文件读入到内存中的工具流。构造：

```java
// 根据文件路径，创建文件输入流
public FileInputStream(String name) throws FileNotFoundException
// 根据文件对象，创建文件输入流
public FileInputStream(File file) throws FileNotFoundException
// 根据FileDescriptor对象，创建文件输入流
public FileInputStream(FileDescriptor fdObj)
```

其中文件路径和文件对象必须是一个存在的文件，并且不能是目录，否则抛FileNotFoundException。

> 示例：通过FileInputStream读取文件，然后打印文件内容

```java
@SneakyThrows
public static void main(String[] args) {
    try (InputStream is = new FileInputStream("home/top/1.txt")) {
        byte[] buf = new byte[1024];
        int b;
        int bytesRead = 0;
        while ((b = is.read()) != -1) {
            buf[bytesRead++] = (byte) b;
        }
        String data = new String(buf, 0, bytesRead, StandardCharsets.UTF_8);
        System.out.println(data);
    }

    try (InputStream is = new FileInputStream(new File("home/top/1.txt"))) {
        byte[] buf = new byte[1024];
        int bytesRead = is.read(buf);
        String data = new String(buf, 0, bytesRead, StandardCharsets.UTF_8);
        System.out.println(data);
    }

    try (InputStream is = new FileInputStream(new File("home/top/1.txt"));
         ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        byte[] buf = new byte[1024];
        int bytesRead;
        while ((bytesRead = is.read(buf)) != -1) {
            os.write(buf, 0, bytesRead);
        }
        String data = os.toString("UTF-8");
        System.out.println(data);
    }
}
```

- 第一种方式：逐个字节，将FileInputStream流中的内容读取到字节数组buf中。没有缓存时逐个字节读取，效率较差，且文件内容不能超过1024个字节
- 第二种方式：通过FileInputStream.read()，一次性将FileInputStream流中的内容读取到字节数组buf中。较第一种效率稍好，但文件内容仍不能超过1024个字节
- 第三种方式：借助ByteArrayOutputStream，每次从FileInputSteam流中读取1024个字节到字节数组buf中，然后再将字节数组内容写入到ByteArrayOutputStream中。由于ByteArrayOutputStream支持动态扩容，不像前两种对文件内容有限制，所以这种方式较合理

## 2. FileOutputStream

FileOutputStream是内存和文件之间的"通道"，是一种将内存数据写入到文件中的工具流。构造：

```java
public FileOutputStream(String name) throws FileNotFoundException
public FileOutputStream(String name, boolean append) throws FileNotFoundException
public FileOutputStream(File file) throws FileNotFoundException
public FileOutputStream(File file, boolean append) throws FileNotFoundException
public FileOutputStream(FileDescriptor fdObj)
```

可以通过File对象（必须是文件，不是文件路径）、文件路径（绝对路径或相对路径）、FileDescriptor对象，创建FileOutputStream。如果文件已存在，参数append指定是追加还是覆盖（true表示追加，false表示覆盖），没有append参数的构造，append默认为false，表示覆盖文件。

> 示例：将"白菜饼123"写入到文件

```java
@SneakyThrows
public static void main(String[] args) {
    try (OutputStream os = new FileOutputStream(new File("/home/top/1.txt"))) {
        byte[] bytes = "白菜饼123".getBytes(Charset.forName("UTF-8"));
        os.write(bytes);
    }
}
```

- 先使用getBytes()将字符串转化为byte[]
- 然后调用FileOutPutStream.write()，将byte数组的内容写入到文件


---
# V.FilterInputStream/FilterOutputStream