---
title: 字节流
date: 2018-01-21 00:00:00
categories:
    - JavaSE
tags:
    - JavaSE
---

本文讲述字节流的相关内容。

<!-- more -->

##### 目录
- I.概述
- II.InputStream/OutputStream
- III.ByteArrayInputStream/ByteArrayOutputStream
- IV.FileInputStream/FileOutputStream
- V.FilterInputStream/FilterOutputStream
- VI.ObjectInputStream/ObjectOuputStream

---
# I.概述

上篇提到，Java中的文件被当做IO设备来处理，并且通过流进行操作。流又可以细分为字节流、字符流。其中，字节流的继承体系如下：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/JavaSE/io/java_input_stream_system.png)

本文重点介绍如下几种字节流：

- InputStream/OutputStream：基类
- ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流
- FileInputStream/FileOutputStream: 输入源和输出目标是文件的流
- FilterInputStream/FilterOutputStream：所有包装流（有"特殊"功能的流）的父类，如DataInputStream/DataOutputStream、BufferedInputStream/BufferedOutputStream都继承自该类
- ObjectInputStream/ObjectOuputStream：输入源和输出目标是对象的流，用于实现Java序列化


---
# II.InputStream/OutputStream

InputStream和OutputStream抽象类，是所有字节流的基类。

## 1.InputStream

```java
public abstract class InputStream implements Closeable
```

#### 1.1 read()

该方法会从字节输入流中读取下一个字节，返回字节的int值（一个字节8位，范围0~255，所以可以用int表示）。

```java
// 从字节输入流中读取下一个字节，返回值为读取字节的int值
public abstract int read() throws IOException;
```

- 当读到流结尾时，返回值为-1
- 如果字节输入流中没有数据，read()会阻塞，直到数据到来、流关闭、或异常出现
- 当异常出现时，read()抛出IOException（checked exception），调用者必须处理，否则编译通不过

#### 1.2 read(byte b[])

该方法会将从字节输入流读取的字节，放入字节数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推。一次最多读入b.length个字节，实际读入的字节数可能小于数组长度。返回值为实际读入的字节个数。

```java
// 从字节输入流中读取多个字节，放入字节数组b中，返回值为实际读入的字节个数
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}
```

- 如果刚开始读取时已到流结尾，则返回-1；否则，只要数组长度大于0，该方法都会至少读取一个字节
- 如果流中一个字节都没有，它也会阻塞直到数据到来、流关闭、或异常出现
- 该方法不是抽象方法，InputStream提供了一个默认实现，通过调用读一个字节的read方法实现，但子类中一般会提供更为高效的实现

#### 1.3 read(byte b[], int off, int len)

该方法会将读入的第一个字节放入b[off]，最多读取len个字节（所以返回值≤len）。

```java
// 从字节输入流中读取len个字节，放入字节数组b中off开始的位置，返回值实际读入的字节个数
public int read(byte b[], int off, int len) throws IOException {
    // 在read()基础上实现，具体参考源码
}
```

#### 1.4 close()

该方法用于字节输入流读取结束后，关闭流，释放相关资源。

```java
// 关闭字节输入流，释放资源
public void close() throws IOException {}
```

不管read()是否抛出异常，都要调用close()（一般放在finally内）。该方法不是抽象方法，InputStream没有具体实现，交由子类。

#### 1.5 skip(long n)

该方法会跳过字节输入流中的n个字节。由于输入流中剩余的字节个数可能不到n，所以返回值为实际略过的字节个数（≤n）。

```java
// 跳过字节输入流中n个字节，返回值为实际跳过的字节个数
public long skip(long n) throws IOException {
    // 具体参考源码
}
```

该方法非抽象，InputStream提供的默认实现，是调用read(byte b[], int off, int len)，尽力读取n个字节，实现skip效果。子类往往会提供更为高效的实现，比如在FileInputStream中会调用本地方法。在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。

#### 1.6 available()

该方法返回下一次不需要阻塞就能读取到的字节个数。

```java
// 返回下一次不需要阻塞就能读取到的字节个数，使用较少
public int available() throws IOException {
    return 0;
}
```

InputStream提供的默认实现是直接返回0，子类会根据具体情况返回适当的值。在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。

#### 1.7 mark(int readlimit)

该方法用于标记当前字节输入流读取的位置。当字节输入流已经读取过该位置后，可以通过调用reset()，重新从标记位置读取。

```java
// 标记能够从字节输入流中往后读取的字节个数readlimit
public synchronized void mark(int readlimit) {}
```

readLimit表示在设置了标记后，能够继续往后读的最多字节数，如果超过了，标记会无效。因为之所以能够重读，是因为流能够将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，流只保证不会小于readLimit。在InputStream中该方法是个空方法，具体需要子类根据自身情况覆写。

#### 1.8 markSupported()

该方法用于获取当前字节输入流是否支持mark/reset操作，true表示支持。

```java
// 判断当前字节输入流是否支持mark/reset操作
public boolean markSupported() {
    return false;
}
```

InpuStream类中的默认实现是不支持，子类根据自身情况覆盖该方法。

#### 1.9 reset()

该方法用于重新从mark标记位置读取字节输入流。

```java
// 重新从标记位置读取字节输入流
public synchronized void reset() throws IOException {
    throw new IOException("mark/reset not supported");
}
```

## 2.OutputStream

```java
public abstract class OutputStream implements Closeable, Flushable
```

#### 2.1 write(int b)

该方法向流中写入一个字节，参数类型虽然是int，但其实只会用到低8位（一个字节）。

```java
// 向字节输出流中写出一个字节
public abstract void write(int b) throws IOException;
```

该方法在OutputStream中是个抽象方法，需要子类实现。

#### 2.2 write(byte b[])

该方法会将字节数组b中的全部字节写出到字节输出流，在OutputStream中的实现依赖write(b, 0, b.length)。

```java
// 将字节数组b中所有的字节写出到字节输出流
public void write(byte b[]) throws IOException {
    write(b, 0, b.length);
}
```

#### 2.3 write(byte b[], int off, int len)

该方法会将字节数组中从off开始的len个字节，写出到字节输出流中。第一个被写出的字节是b[off]，最后一个是b[off+len-1]或b[b.length-1]。

```java
// 将字节数组b中从off开始，长度为len的字节写出到字节输出流
public void write(byte b[], int off, int len) throws IOException {
    // 具体参考源码
}
```

OutputStream的默认实现是循环调用单字节的write方法，子类往往有更为高效的实现。

#### 2.4 flush()

该方法会将缓冲而未实际写出的数据，进行写出。

```java
// 将缓冲而未实际写出数据进行写出
public void flush() throws IOException {
}
```

#### 2.5 close()

该方法会关闭字节输出流，释放系统资源。

```java
// 关闭字节输出流，释放资源
public void close() throws IOException {
}
```


---
# III.ByteArrayInputStream/ByteArrayOutputStream

```java
public class ByteArrayInputStream extends InputStream
public class ByteArrayOutputStream extends OutputStream
```

## 1.ByteArrayInputStream

ByteArrayInputStream的作用是将byte数组包装为一个输入流（适配器模式）。两个构造方法：

```java
// 将字节数组buf中的全部字节，都包装到ByteArrayInputStream
public ByteArrayInputStream(byte buf[]);
// 将字节数组buf中从offset开始长度为length的字节，包装到ByteArrayInputStream
public ByteArrayInputStream(byte buf[], int offset, int length);
```

第二个构造，是将buf[]中从offset到offset+len-1的字节，体现在ByteArrayInputStream中，read操作也只能读取到offset及之后的字节。ByteArrayInputStream的所有数据都在内存，支持mark/reset重复读取。

## 2.ByteArrayOutputStream

ByteArrayOutputStream的作用是将内存中的数据输出到byte数组，充当"管道"的角色。两个构造方法：

```java
public ByteArrayOutputStream();
public ByteArrayOutputStream(int size);
```

第二个构造函数中的size，是输出目的地字节数组的大小。第一个构造依赖第二个构造而实现，size默认为32。在调用write()向ByteArrayOutputStream流中写值时，如果字节数组长度不够，会进行动态扩容，扩展后的容量是扩容前容量的两倍。

```java
// 将ByteArrayOutputStream流中的内容输出到字节数组
public synchronized byte[] toByteArray()
// 使用系统编码，将ByteArrayOutputStream流中的内容（write操作写进来的字节数组）输出为字符串
public synchronized String toString()   
// 使用特定编码，将ByteArrayOutputStream流中的内容（write操作写进来的字节数组）输出为字符串
public synchronized String toString(String charsetName) 
// 将ByteArrayOutputStream中的数据，写到另一个OutputStream中
public synchronized void writeTo(OutputStream out) throws IOException   
// 返回当前已经写入到流的字节个数
public synchronized int size()  
// 重置ByteArrayOutputStream中的内容，之前写入的内容都会无效
public synchronized void reset()
```

## 3.示例

```java
@SneakyThrows
public static void main(String[] args) {
    byte[] bytes = Bytes.toArray(Lists.newArrayList(65, 66, 67, 68));

    try (InputStream is = new ByteArrayInputStream(bytes);
        ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        writeStream(is, os);
    }

    try (InputStream is = new ByteArrayInputStream(bytes, 1, 2);
        ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        writeStream(is, os);
    }
}

private static void writeStream(InputStream is, ByteArrayOutputStream os) throws IOException {
    byte[] buf = new byte[16];
    int bytesRead;
    while ((bytesRead = is.read(buf)) != -1) {
        os.write(buf, 0, bytesRead);
    }
    String data = os.toString("UTF-8");
    System.out.println(data);
}
```

> 输出

```
ABCD
BC
```

- Bytes.toArray()和Lists.newArrayList()是google Guava工具包提供的API
- 使用了Java8提供的语法糖try-with-resource，可以在try代码块执行结束，自动关闭打开的资源
- 第一个ByteArrayInputStream对象通过整个byte数组构造，第二个ByteArrayInputStream对象通过byte数组从1到2的字节构造
- output.write()将is中构造时读取的字节数组，写入到os中，再使用UTF-8编码将ByteArrayOutputStream中的内容输出为字符串


---
# IV.FileInputStream/FileOutputStream

```java
public class FileInputStream extends InputStream
public class FileOutputStream extends OutputStream
```

## 1.FileInputStream

FileInputStream是文件和内存之间的"通道"，是一种将文件读入到内存中的工具流。构造：

```java
// 根据文件路径，创建文件输入流
public FileInputStream(String name) throws FileNotFoundException
// 根据文件对象，创建文件输入流
public FileInputStream(File file) throws FileNotFoundException
// 根据FileDescriptor对象，创建文件输入流
public FileInputStream(FileDescriptor fdObj)
```

其中文件路径和文件对象必须是一个存在的文件，并且不能是目录，否则抛FileNotFoundException。

> 示例：通过FileInputStream读取文件，然后打印文件内容

```java
@SneakyThrows
public static void main(String[] args) {
    try (InputStream is = new FileInputStream("home/top/1.txt")) {
        byte[] buf = new byte[1024];
        int b;
        int bytesRead = 0;
        while ((b = is.read()) != -1) {
            buf[bytesRead++] = (byte) b;
        }
        String data = new String(buf, 0, bytesRead, StandardCharsets.UTF_8);
        System.out.println(data);
    }

    try (InputStream is = new FileInputStream(new File("home/top/1.txt"))) {
        byte[] buf = new byte[1024];
        int bytesRead = is.read(buf);
        String data = new String(buf, 0, bytesRead, StandardCharsets.UTF_8);
        System.out.println(data);
    }

    try (InputStream is = new FileInputStream(new File("home/top/1.txt"));
         ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        byte[] buf = new byte[1024];
        int bytesRead;
        while ((bytesRead = is.read(buf)) != -1) {
            os.write(buf, 0, bytesRead);
        }
        String data = os.toString("UTF-8");
        System.out.println(data);
    }
}
```

- 第一种方式：逐个字节，将FileInputStream流中的内容读取到字节数组buf中。没有缓存时逐个字节读取，效率较差，且文件内容不能超过1024个字节
- 第二种方式：通过FileInputStream.read()，一次性将FileInputStream流中的内容读取到字节数组buf中。较第一种效率稍好，但文件内容仍不能超过1024个字节
- 第三种方式：借助ByteArrayOutputStream，每次从FileInputSteam流中读取1024个字节到字节数组buf中，然后再将字节数组内容写入到ByteArrayOutputStream中。由于ByteArrayOutputStream支持动态扩容，不像前两种对文件内容有限制，所以这种方式较合理

## 2. FileOutputStream

FileOutputStream是内存和文件之间的"通道"，是一种将内存数据写入到文件中的工具流。构造：

```java
public FileOutputStream(String name) throws FileNotFoundException
public FileOutputStream(String name, boolean append) throws FileNotFoundException
public FileOutputStream(File file) throws FileNotFoundException
public FileOutputStream(File file, boolean append) throws FileNotFoundException
public FileOutputStream(FileDescriptor fdObj)
```

可以通过File对象（必须是文件，不是文件路径）、文件路径（绝对路径或相对路径）、FileDescriptor对象，创建FileOutputStream。如果文件已存在，参数append指定是追加还是覆盖（true表示追加，false表示覆盖），没有append参数的构造，append默认为false，表示覆盖文件。

> 示例：将"白菜饼123"写入到文件

```java
@SneakyThrows
public static void main(String[] args) {
    try (OutputStream os = new FileOutputStream(new File("/home/top/1.txt"))) {
        byte[] bytes = "白菜饼123".getBytes(Charset.forName("UTF-8"));
        os.write(bytes);
    }
}
```

- 先使用getBytes()将字符串转化为byte[]
- 然后调用FileOutPutStream.write()，将byte数组的内容写入到文件


---
# V.FilterInputStream/FilterOutputStream

```java
public class FilterInputStream extends InputStream
public class FilterOutputStream extends OutputStream
```

上述的流，基本是按字节读写，没有缓冲区。Java使用了装饰器设计模式，提供FilterInputStream/FilterOutputStream，来解决这个问题。FilterInputStream/FilterOutputStream是所有装饰流的父类，子类很多，常见的有：

- DataInputStream/DataOutputStream：按八种基本类型和字符串对流进行读写
- BufferedInputStream/BufferedOutputStream：对基础流进行缓冲读写

## 1.DataInputStream/DataOutputStream

```java
public class DataInputStream extends FilterInputStream implements DataInput
public class DataOutputStream extends FilterOutputStream implements DataOutput
```

#### 1.1 DataInputStream

DataInputStream是装饰类FilterInputStream的子类，可以方便地对被包装流中的数据，通过基础数据类型读取。

> 构造：对其他流进行包装，所以只有一个有参构造，传入被包装流的对象：

```java
public DataInputStream(InputStream in) {
    super(in);
}
```

> 方法（常用读方法）

```java
// 从被包装字节输入流中读取多个字节，放入字节数组b中，返回值为实际读入的字节个数
public final int read(byte b[]) throws IOException
// 从被包裝字节输入流中读取len个字节，放入字节数组b从off开始的位置，返回值为实际读入的字节个数
public final int read(byte b[], int off, int len) throws IOException
// 从被包裝字节输入流中读取一个字节，并转化为boolean
public final boolean readBoolean() throws IOException
// 从被包裝字节输入流中读取一个字节
public final byte readByte() throws IOException
// 从被包裝字节输入流中读取两个字节，并转化为char
public final char readChar() throws IOException
// 从被包裝字节输入流中读取八个字节，并转化为double
public final double readDouble() throws IOException
// 从被包裝字节输入流中读取四个字节，并转化为float
public final float readFloat() throws IOException
// 从被包裝字节输入流中读取四个字节，并转化为int
public final int readInt() throws IOException
// 从被包裝字节输入流中读取八个字节，并转化为long
public final long readLong() throws IOException
// 从被包裝字节输入流中读取两个字节，并转化为short
public final short readShort() throws IOException
// 从被包裝字节输入流中读取一个字节，并转化为无符号byte
public final int readUnsignedByte() throws IOException
// 从被包裝字节输入流中读取两个字节，并转化为无符号short
public final int readUnsignedShort() throws IOException
// 读取在已使用UTF-8修改版格式编码的字符串（就是使用DataOutputStream的writeUTF写入的）
public final String readUTF() throws IOException
```

#### 1.2 DataOutputStream

DataOutputStream是装饰类FilterOutputStream的子类，可以方便地将内存中的数据通过基础数据类型写入到被包装流的输出目标中。比如被包装流是FileOutputStream对象，那么调用dataOutputSream的writeInt操作，就可以将一个int值写入到FileOutputStream对象的目标文件中。

> 构造

```java
public DataOutputStream(OutputStream out) {
    super(out);
}
```

> 方法（常用写方法）

```java
// 写入一个字节(b的低8位)，到被包装流
public synchronized void write(int b) throws IOException
// 从b[]的off开始，写入len个字节，到被包装流
public synchronized void write(byte b[], int off, int len)
// 写入一个字节，如果v为true，则写入1，否则0
public final void writeBoolean(boolean v) throws IOException
// 写入一个字节(v是byte值)
public final void writeByte(int v) throws IOException  
// 写入String，s的每个char都舍弃高八位 
public final void writeBytes(String s) throws IOException 
// 写入两个字节(v是char值)，高字节先被写入
public final void writeChar(int v) throws IOException 
// 写入String，依赖writeChar（不舍弃高八位 ）
public final void writeChars(String s) throws IOException 
// 写入八个字节(先使用doubleToLongBits将v转化成long)，最高位字节先写入  
public final void writeDouble(double v) throws IOException
// 写入四个字节(先使用floatToIntBits将v转化成int)，最高位字节先写入  
public final void writeFloat(float v) throws IOException
// 写入四个字节(v是int值)，最高位字节先写入  
public final void writeInt(int v) throws IOException
// 写入八个字节(v是long值)，最高位字节先写入  
public final void writeLong(long v) throws IOException 
// 写入两个字节(v是short值)，高字节先被写入
public final void writeShort(int v) throws IOException
// 将字符串的UTF-8编码字节写入，这个编码格式与标准的UTF-8编码略有不同
public final void writeUTF(String str) throws IOException
```

#### 1.3 示例

```java
@Getter
@Setter
@AllArgsConstructor
@ToString
public class Student {
    private String name;
    private int age;
    private float grade;
}
```

```java
@SneakyThrows
public static void main(String[] args) {
    try (OutputStream fos = new FileOutputStream("/home/top/1.txt");
         DataOutputStream dataOutputStream = new DataOutputStream(fos)
    ) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("Alice", 23, 80.5f));
        list.add(new Student("Brian", 22, 95.0f));
        list.add(new Student("Carol", 21, 79.8f));

        for (Student s : list) {
            dataOutputStream.writeUTF(s.getName());
            dataOutputStream.writeInt(s.getAge());
            dataOutputStream.writeFloat(s.getGrade());
        }
    }

    try (InputStream fis = new FileInputStream("/home/top/1.txt");
         DataInputStream dataInputStream = new DataInputStream(fis)
    ) {
        List<Student> list = new ArrayList<>();
        try {
            while (true) {
                String name = dataInputStream.readUTF();
                int age = dataInputStream.readInt();
                float grade = dataInputStream.readFloat();
                list.add(new Student(name, age, grade));
            }
        } catch (EOFException ex) {
        }
        System.out.println(listStudent);
    }
}
```

> 输出

```java
[Student(name=Alice, age=23, grade=80.5), Student(name=Brian, age=22, grade=95.0), Student(name=Carol, age=21, grade=79.8)]
```

使用DataInputStream/DataOutputStream读写对象，非常灵活，但比较麻烦，所以Java提供了序列化机制ObjectInputSream/ObjectOutputStream。

## 2.BufferedInputStream/BufferedOutputStream

```java
public class BufferedInputStream extends FilterInputStream
public class BufferedOutputStream extends FilterOutputStream
```

#### 2.1 BufferedInputStream

BufferedInputStream是装饰类FilterInputStream的子类，提供普通流读取的缓冲功能（"蓄水池"）。BufferedInputStream内部有个字节数组作为缓冲区，读取时，先从这个缓冲区读，缓冲区读完了再调用包装流的读。

> 两个构造

```java
// 该构造，缓存区字节数组默认长度8192
public BufferedInputStream(InputStream in)
// 指定缓冲区大小的构造
public BufferedInputStream(InputStream in, int size)
```

> 方法

BuffedInputStream没有提供特有的方法，重写了InputStream的read方法，

```java
// 从BuffedInputStream中读取下一个字节，返回值读取字节的int值
public synchronized int read() throws IOException   
// 从BuffedInputStream中读取len个字节放入字节数组b从off开始的位置，返回值实际读入的字节个数
public synchronized int read(byte b[], int off, int len) throws IOException 
// 关闭BuffedInputStream，释放资源
public void close() throws IOException 
// 跳过BuffedInputStream中n个字节，返回值为实际跳过的字节个数
public long skip(long n) throws IOException
// 返回下一次不需要阻塞就能读取到的字节个数，使用较少
public synchronized int available() throws IOException  
// 标记能够从字节输入流中往后读取的字节个数readlimit
public synchronized void mark(int readlimit)
// 默认返回true，BufferedInputSream支持mark/reset操作
public boolean markSupported()  
// 重新从标记位置读取字节输入流
public synchronized void reset() throws IOException 
```

#### 2.2 BufferedOutputStream

BufferedOutputStream是装饰类FilterOutputStream的子类，提供普通流读取的缓冲功能。

> 构造，也是两个

```java
// 默认也是8192
public BufferedOutputStream(OutputStream out)
public BufferedOutputStream(OutputStream out, int size)
```

> 方法

```java
// 向BufferedOutputStream中写入一个字节
public synchronized void write(int b) throws IOException
// 将字节数组b中从off开始长度为len的字节，写入BufferedOutputStream   
public synchronized void write(byte b[], int off, int len) throws IOException
// 将缓冲而未实际写出数据，写出
public void flush() throws IOException  
```

#### 2.3 示例

```java
@SneakyThrows
public static void main(String[] args) {
    try (OutputStream fos = new FileOutputStream("/home/top/1.txt");
         BufferedOutputStream bos = new BufferedOutputStream(fos);
         DataOutputStream dataOutputStream = new DataOutputStream(bos)
    ) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("Alice", 23, 80.5f));
        list.add(new Student("Brian", 22, 95.0f));
        list.add(new Student("Carol", 21, 79.8f));

        for (Student s : list) {
            dataOutputStream.writeUTF(s.getName());
            dataOutputStream.writeInt(s.getAge());
            dataOutputStream.writeFloat(s.getGrade());
        }
    }

    try (InputStream fis = new FileInputStream("/home/top/1.txt");
         BufferedInputStream bis = new BufferedInputStream(fis);
         DataInputStream dataInputStream = new DataInputStream(bis)
    ) {
        List<Student> list = new ArrayList<>();
        try {
            while (true) {
                String name = dataInputStream.readUTF();
                int age = dataInputStream.readInt();
                float grade = dataInputStream.readFloat();
                list.add(new Student(name, age, grade));
            }
        } catch (EOFException ex) {
        }
        System.out.println(list);
    }
}
```

跟上节示例效果相同，通过DataOutputStream向文件中写入对象，然后通过DataInputStream从文件中读取对象。但上节示例是直接读写的，比如readInt需要逐个字节从FileInputStream中读取内容，效率不高。而本节示例中，通过BufferedInputStream将FileInputStream对象包装，readInt操作就可以从缓冲区中读取内容，BufferedOutputStream原理相似，提高效率。




---
# VI.ObjectInputStream/ObjectOuputStream