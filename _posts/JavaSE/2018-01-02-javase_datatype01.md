---
title: Java数据类型
date: 2018-01-02 00:00:00
categories:
    - JavaSE
tags:
    - JavaSE
---

本文记录Java数据类型的基本知识。

<!-- more -->

##### 目录
+ I.常量
+ II.变量
+ III.数据类型
+ IV.转义字符
+ V.值传递

---

# I.常量

程序执行中，其值不会发生改变

- 分类：字面值常量、自定义常量
- 字面值常量：
    + 整数常量：123
    + 小数常量：12.3
    + 字符常量：**单引号，且只能放单个数字/字母/符号，也不能什么也不放**
    + 字符串常量：双引号"abc"
    + 布尔常量：true、false
    + 空常量：null

```
''和'10'会报错
' '合法
```


---

# II.变量

程序执行中可变化的量，**但类型不能变**

- 格式：数据类型 变量名(标识符) = 值;
- 一条语句可以定义多个变量
- 同一作用域中，不能重名

```java
int a,b,c;
int a = 1, b = 2;
```

> Java中根据定义位置，分为局部变量、成员变量。成员变量又可分为静态和非静态的。（static不能修饰局部变量）

## 1.局部变量

声明在方法上或方法中

> - 存在于栈内存，生命周期随方法
> - 局部变量在 **使用前** 必须赋值(只声明不赋值使用，不报错)

## 2.成员变量

#### 2.1 静态成员变量

static修饰，两种访问方式

- 1.类名访问：类名.变量名
- 2.实例访问：private的用getter。非私有的可以getter，也可以实例.变量名

> **静态变量是全局的，类级别的**，甚至有些可以整个项目共享

#### 2.2 非静态成员变量

只能先获取对象实例，才能访问（只能实例访问）：
private的用getter，非私有的可以getter，也可以实例.变量名


---

# III.数据类型

Java是强类型语言，对每种数据都定义了具体的类型，并分配适合的内存大小

分类：基本数据类型（4类8种）、引用数据类型

## 1.基本数据类型

|类型|分类|占字节|取值范围|
|:--|:--|:----|:------|
|整型|byte|1   |-128~127|
|   |short|2   |-2^15~2^15-1|
|   |int|4   |-2^31~2^31-1|
|   |long|8   |-2^63~2^63-1|
|浮点型|float单精度|4|-2^128 ~ +2^128 或 -3.403E38~3.403E38|
|     |double双精度|8|-2^1024 ~ +2^1024 或 -1.798E308~1.798E308|
|字符型|char|2|0~65535(没有负数)|
|布尔型|boolean|理论应占1/8字节，但Java中未明确指定所占大小|true/false|

- **String不是基本数据类型，是引用数据类型**
- Java中boolean不能和其他数据类型进行运算，区别于C语言
- 不加声明时：整数默认的数据类型是int；小数默认是double

> 所以long类型赋值时最好加l/L(如果不加，超出int范围的数会报错)，float必须要加f/F

```java
byte b = 127;           //可以
byte b = 128;           //不可以

long l = 50;            //可以
long l = 8888888888;    //不可以
long l = 8888888888L;   //可以

float f = 11.2;         //不可以
float f = 11.2F;        //可以
float f = 11;           //可以（int强转float）
float f = 11.0;         //不可以

double d = 12.3;        //可以
double d = 12.3D;       //可以
double d = 12.3F;       //可以
double d = 12;          //可以（int强转double）
```

## 2.引用数据类型

> 数组、类、接口、枚举

// TODO

## 3.数据类型转换

#### 3.1 隐式转换

小数据类型和大数据类型运算时，会提升到大数据类型

```java
byte b = 1;
int i = 2;
i = b + i;  //3(整型)
```

> b占1字节（8位），i占4字节（32位）。此时会提升b为int（前面加24个0）再做运算，结果是4字节的int数

#### 3.2 强制类型转换

```java
byte b = 1;
int i = 2;
b = b + i;          //报错
b = (byte)(b + i);  //可以
```

> - 由于隐式转换，b + i的结果是int，再赋值给byte型的b，不匹配报错
> - 加上强转后，将前24个0去掉，变成1字节（8位）的数据赋值给b

#### 3.3 强转中的问题

强转可能会得到意想不到的结果，因为是对补码进行运算

```java
byte b1 = 127 + 1;         //不可以
byte = (byte)(127 + 1); //可以,但结果是-128
```

> - 两个int正数补码相加后结果的补码为：00000000 00000000 00000000 10000000
> - 对补码强转后变成：10000000
> - 该补码对应的-128

#### 3.4 注意事项

- 1.byte、short、char之间混合运算时，不会相互提升转换，而是都提升为int，其中char字符按ASCI码表转换
- 2.其他类型混合运算时，小数据类型提升为大数据类型：int-->long(8字节)-->float(4字节)-->double
- 3.虽然long占8字节，float占4字节，但**float的取值范围远比long大**
- 4.字符串+其他数据类型时，都会产生新的字符串

> - float和double的取值范围是由指数的位数来决定，而精度由尾数位决定
> - IEEE 754规定：float中的32位(4字节)，其中有1位表示符号位，有8位为指数位，有23位为尾数位
> - 并规定8位指数位的取值范围为:0-255,0表示0,255表示无穷大，剩余1-254减去127为-126~127
> - [参考](https://blog.csdn.net/a327369238/article/details/52354811)

- 5.字符型可以存储**单个中文字符**。因为Java采用Unicode编码，char占2字节，而中文也是占2字节，所以可以存放

```java
//运算提升为int，结果也为int；另外两个变量相加，范围可能会超出取值范围，得到意想不到的结果，编码时要避免
byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;//不可以

//java编译器有常量优化机制
byte b1 = 1 + 2;//可以

//两个变量相加，范围可能会超出取值范围，得到意想不到的结果，编码时要避免
int b1 = 2000000000;
int b2 = 2000000000;
int b3 = b1 + b2;//得到-294967296

//float和long的取值比较
float f = 12.3F;
long l = 123L;
l = f;          //不可以
l = (long)f;    //可以,强转结果为12(除去小数)
f = l;          //可以，隐式转换

//字符类型提升为int
System.out.println('a'+ 1);                 //98
System.out.println((char)('a'+ 1));         //b

//字符串类型(引用数据类型)参与运算
System.out.println("hello" + 'a' + 1);      //helloa1
System.out.println('a' + 1 + "hello");      //98hello
System.out.println("5 + 5 = " + 5 + 5);     //5 + 5 = 55
System.out.println("5 + 5 = " + (5 + 5));   //5 + 5 = 10

//字符类型
char c1 = 97;   //可以,0-65535
char c2 = 'a';  //可以
char c3 = '中';   //可以
char c3 = '中国'; //不可以
```

---

# IV.转义字符

|转义字符|表示的符号|
|:-----|:-------|
|'\t' | 制表符  |
|'\r' | 回车  |
|'\n' | 换行  |
|'\"' | " |
|'\' | '  |

> - DOS中\r\n和\n都表示回车换行
> - Windows中\r\n表示回车换行
> - Mac中\r表示回车换行


---

# V.值传递

- 基本数据类型的值传递，**不改变原值**。因为调用后方法弹栈，局部变量随之消失
- 引用数据类型的值传递，**改变原值**。即使方法弹栈，堆内存中的对象已经改变，可通过地址继续访问

**Java中基本数据类型传值，引用数据类型传址**（但址也是一种值）