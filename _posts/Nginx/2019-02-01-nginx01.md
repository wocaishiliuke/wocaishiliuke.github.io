---
title: Nginx文档（一）
date: 2019-02-01 19:01:09
categories:
    - Nginx
tags:
    - Nginx
---

这里通过阅读和翻译[nginx documentation](http://nginx.org/en/docs/)，进行nginx的学习和记录。

<!-- more -->

##### 目录
+ I.Installing nginx
+ II.Building nginx from Sources
+ III.Beginner’s Guide
+ IV.Admin’s Guide
+ V.Controlling nginx
+ VI.Connection processing methods
+ VII.Setting up hashes
+ VIII.A debugging log
+ IX.Logging to syslog
+ X.Configuration file measurement units
+ XI.Command-line parameters
+ XII.nginx for Windows
+ XIII.How nginx processes a request
+ XIV.Server names
+ XV.Using nginx as HTTP load balancer
+ XVI.Configuring HTTPS servers
+ XVII.How nginx processes a TCP/UDP session
+ XVIII.Scripting with njs
+ XIX.Chapter "nginx" in "The Architecture of Open Source Applications"
---

# Scripting with njs

---

# Chapter “nginx” in “The Architecture of Open Source Applications”


---

# I.安装nginx

nginx提供了多系统支持，这里只给出**Ubuntu 18.04上stable版的preBuild package安装方式**。其他系统、版本、安装方式可参考官方[Installing nginx](http://nginx.org/en/docs/install.html)。

> 安装部分翻译参考的是nginx商业官网文档[Installing NGINX Open Source](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)。也可以参考nginx开源官网的[Installing nginx](http://nginx.org/en/docs/install.html)，这里不再翻译。

## 1.选择安装版本

开源nginx提供两个版本，**稳定版、主线版**

- Mainline：主线版。包含最新特性和修复，保持代码最新。可信任，但可能包含实验性模块，可能存在BUG
- Stable：稳定版。不包含最新特性，但修复了关键严重BUG。推荐生产环境使用

## 2.选择安装方式：

开源nginx的主线版和稳定版，都可以采用两种方式安装，**预安装包、源码安装**

- prebuilt binary package：预编译的二进制包，快捷简单。包中包含了几乎所有nginx官方模块，支持主流操作系统
- binaries you compile from source：源码（自编译）安装，操作复杂。但可以自定义添加模块（包括第三方模块）或最新的安装补丁

这里就是采用的预编译包安装，并且只介绍Ubuntu中的预编译包安装。

> 预编译包方式支持的Linux版本可参考[nginx: Linux packages](https://nginx.org/en/linux_packages.html)

## 3.预编译包Ubuntu版安装

nginx提供了14.04-18.10的安装包。安装包可从以下方式获取：

- default Ubuntu repository：Ubuntu默认仓库。方便，但往往不是最新版的
- nginx.org官方仓库：需要设置apt-get源，然后安装的就是最新版了

#### 3.1 Ubuntu默认仓库

从Ubuntu Repository安装Prebuilt Package。该方式提供的package一般是过时的，**不推荐**

```shell
$ sudo apt-get update
$ sudo apt-get install nginx
$ sudo nginx -v
nginx version: nginx/1.4.6 (Ubuntu)
```

#### 3.2 NGINX官方仓库

从Official NGINX Repository的package安装

- 1.下载key

key用于sign NGINX packages and the repository。下载后添加到apt program’s key ring

```shell
$ sudo wget https://nginx.org/keys/nginx_signing.key
$ sudo apt-key add nginx_signing.key
```

- 2.修改源

在sources.list中加入并命名nginx源

```shell
$ sudo vi /etc/apt/sources.list

deb https://nginx.org/packages/mainline/ubuntu/ <CODENAME> nginx
deb-src https://nginx.org/packages/mainline/ubuntu/ <CODENAME> nginx
```

其中：

- mainline表示会获取最新的mainline版本，不带mainline表示获取最新的stable版本
- CODENAME是Ubuntu release。以最新的Ubuntu 18.04（bionic）stable版为例：

```
deb https://nginx.org/packages/ubuntu/ bionic nginx
deb-src https://nginx.org/packages/ubuntu/ bionic nginx
```

- 3.安装和启动

```shell
$ sudo apt-get remove nginx-common
$ sudo apt-get update
$ sudo apt-get install nginx
# 启动NGINX Open Source
$ sudo nginx
```

- 4.测试

```shell
$ curl -I 127.0.0.1

HTTP/1.1 200 OK
Server: nginx/1.14.2
```


## 4.安装后nginx文件位置

- 配置文件：/etc/nginx
- 存放静态文件（50x.html、index.html）：/usr/share/nginx
- 日志：/var/log/nginx
- 可执行文件nginx命令：/usr/sbin/nginx
- 主进程PID：/var/run/nginx.pid


---

# II.源码安装

源码安装这里不做翻译，可参考[Building nginx from Sources](http://nginx.org/en/docs/configure.html)或nginx商业官网的[Compiling and Installing from Source](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#sources)


---

# III.新手指南

本节介绍nginx基本内容和使用，包括
- 起、停、重载配置
- 配置文件的结构
- 设置nginx响应静态资源
- 配置nginx作为代理服务器
- 连接FastCGI应用

**nginx有一个master process和多个[worker process](http://nginx.org/en/docs/ngx_core_module.html#worker_processes)。主进程的主要作用是读取配置和维护工作进程，工作进程才是处理请求的**。nginx引入event-based模型和OS-dependent机制，以完成worker进程间请求的高效分发。worker进程数在配置文件中指定，可以是固定配置（数），也可以配置成自动调整为可用CPU内核数

> worker进程的最优值取决于多个因素，包括但不限于CPU cores数、硬盘数、load pattern。当有一个不确定时，可以将其设置成可用CPU cores数（使用"auto"参数会自动检测内核数)

nginx和其模块的工作方式是在配置文件中配置的。默认配置文件是nginx.conf，一般位于/usr/local/nginx/conf或/etc/nginx或/usr/local/etc/nginx

## 1.启、停、重载配置

启动nginx需要运行可执行文件。如上述安装中执行的：

```shell
sudo nginx
```

一旦nginx启动了，就可以使用nginx命令和-s参数进行控制

```shell
nginx -s signal
```

其中，signal可以为:

- stop：fast shutdown
- quit：graceful shutdown
- reload：reloading the configuration file
- reopen：reopening the log files

**优雅地结束nginx进程**：等待worker进程处理完当前的requests后，才结束nginx processes：

```shell
nginx -s quit
```

> 该命令的执行者，需要和启动nginx时的用户一致

**重载配置**：一旦master进程收到重载配置的指令，它会先检查配置文件的语法是否合法，然后尝试应用新配置。如果成功，master进程会开启new worker processes，并发送消息到old worker processes让他们关闭。old worker processes收消息后会停止接收新连接，并在处理完当前的requests后关闭。如果尝试应用新配置失败，master进程会回滚配置，继续使用原有配置工作。

```shell
nginx -s reload
```

**使用Unix命令操控nginx**：可以使用Unix工具发送消息到nginx processes，如kill命令等：

kill命令会发送消息到指定nginx进程(PID)。master进程的PID号默认写在nginx.pid文件，位于/usr/local/nginx/logs或/var/run。例如，如果主进程PID是1628，可以使用下列命令,**也会优雅地关闭nginx**：

```shell
# 通过结束master process，优雅地关闭nginx
kill -s QUIT 1628
```

**查看nginx进程**-获取正在运行的nginx processes，可以使用ps utility，如：

```shell
ps -ax | grep nginx
```

更多关于发送信号到nginx，可参考下面[Controlling nginx](https://nginx.org/en/docs/control.html)的翻译。

## 2.配置文件结构

nginx由modules组成，这些模块由配置文件中的指令控制。指令分为simple directives简单指令和block directives指令块。简单指令由name和parameters组成，使用空格分割，并以分号;结束。指令块的结构同简单指令，但是以一组大括号{}包围的additional instructions结尾的，而不是分号。如果一个指令块的{}中有其他指令，则称之为context（如：events、http、server和location）

配置文件中，不在任何context中的指令，可看做在main context中。events和http指令在main context中，server指令在http中，location指令在server中

> 单行注释使用#号

## 3.提供静态资源服务

web服务器的一个重要作用就是提供静态资源访问（图片、HTML等）。这里将做个demo，根据不同的请求，响应不同路径的文件。需要在配置文件中配置，在http块中配置一个server块，配置两个location块。

- 1.创建/data/www并放置一个index.html，创建/data/images并放置一些图片
- 2.编辑配置文件，可以先注释掉原有的示例server块。增加下列配置：

```
http {
    ...

    server {
        location / {
            root /data/www;
        }

        location /images/ {
            root /data;
        }
    }
}
```

一般来说，配置文件中包含多个server块，由监听的端口和server name来区分。一旦nginx决定了由哪个server处理请求，nginx会对请求头中的URI和server块中的location块中的参数进行测试。

上面第一个location块指定了"/"前缀来映射请求以"/"开头的URI。会将"/"添加到root指令中的路径后，拼接成指向本地资源的路径。如果某个请求有多个location对应，nginx会选择前缀最长的location（最匹配）。上述第一个location提供了一个最短的匹配前缀（长度=1），所以当其他location块都匹配不到时，该location会被使用。

第二个location将匹配以/images/开头的请求（第一个location /也能匹配，但它不是最匹配的）

该配置配置了一个server虚拟主机，（默认）监听80端口，本地可以使用http://localhost/访问。如果想响应请求http://localhost/images/example.png，就需要本地准备/data/images/example.png文件。找不到该文件时，nginx会返回404。其他不是以/images/开头的请求会被映射到/data/www目录，如http://localhost/some/example.html，nginx会返回/data/www/some/example.html文件。

重启或重载配置文件，使新配置生效。

```shell
nginx -s reload
```

如果有问题，可以查看/usr/local/nginx/logs或/var/log/nginx中的日志access.log、error.log寻找原因。

> 本地测试时，虽然/etc/nginx/nginx.conf中没有配location，但在include的/etc/nginx/conf.d/*.conf;中包含了default.conf，在该配置文件中配置了一个server也监听80端口，server中配置了两个location，用来映射/usr/share/nginx/html中的欢迎页和50x页。需要注释掉该server再测试

#### 本地测试

以下内容为本地测试配置，非官方文档内容

```
server {
    location / {
        root /home/top/nginx/www;
    }

    location /images/ {
        root /home/top/nginx;
    }
}
```

> 在/home/top/nginx/www下创建hello.html，在/home/top/nginx/images下放入1.jpeg

分别测试：

```
http://localhost/images/1.jpeg
http://localhost/hello.html
http://localhost/index.html
http://localhost/
```


## 4.配置一个简单的代理主机

将nginx配置成一个proxy server是种常用方式。代理服务器用来接收request，转发给被代理服务器，并从它们那里取回Response，响应给客户端。

这里我们将配置一个基本的代理服务器：图片请求使用本地文件响应，其他请求转发给proxied server。该示例中所有的服务器都在一个nginx实例中定义

首先，在配置文件中，通过添加一个或多个server块，来定义被代理服务器proxied server：

```
server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
```

这是一个简单的server，监听8080端口（之前没有指定listen指令，因为默认是80），映射所有请求到/data/up1本地目录。创建该目录并放入index.html文件。server context中有个（server全局的）root指令，用于当location中没有处理请求的局部root时。

然后，使用上一节（提供静态资源服务）中的server块，将其修改为一个proxy server：在第一个location块中，放置一个proxy_pass指令，明确协议、（站点）名称、被代理服务器的端口

然后修改第二个location块（之前是匹配/images/请求到/data/images目录）。参数使用正则表达式，匹配.gif、.jpg、.png，~需要在正则的前面。匹配到的请求，会被映射到/data/images目录。

```
server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
```

当nginx选择一个location来处理request时，它会先检查指定前缀的location块，并记住最长前缀（最匹配）的location，然后才检查正则表达式的location。如果有正则表达式匹配上，nginx会选择这个正则location。否则就选择之前记住的最匹配location。

**该server会过滤以.gif、.jpg、.png结尾的请求，并把他们映射到/data/images目录，其他所有请求转发到被代理服务器**

向nginx发送reload信号以应用新配置。更多用于配置proxy connection，可参考[ngx_http_proxy_module](https://nginx.org/en/docs/http/ngx_http_proxy_module.html)


#### 本地测试

以下内容为本地测试部分，非官方文档内容

```
server {
    listen 8080;
    root /home/top/nginx/www;

    location / {
    }
}       

# 默认监听80
server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location ~ \.(gif|jpg|jpeg|png)$ {
        root /home/top/nginx;
    }
}
```

```
http://localhost/hello.html
http://localhost:8080/hello.html
http://localhost/index.html
http://localhost/images/1.jpeg
http://localhost/1.jpeg
```


## 5.Setting Up FastCGI Proxying

略，具体参考[官方说明](https://nginx.org/en/docs/beginners_guide.html#fastcgi)


---

# IV.高级指南

该部分位于nginx商业网站的[Admin Guide](https://docs.nginx.com/nginx/admin-guide/)。部分内容和nginx.org中的重复。该部分很多章节将nginx和nginx plus混合在一起说明，内容较多较乱，会持续更新...

## 安装NGINX和NGINX Plus

nginx商业官网提供了nginx和nginx plus的各种安装方式和场景，这里不再翻译。参考上述nginx在Ubuntu下的package安装

## 基础功能

#### 运行时控制nginx进程

该部分描述运行时nginx启动的进程，以及如何控制它们

###### 主进程和工作进程

nginx有一个master process和一个或多个worker processes。如果开启了caching，启动时还会运行cache loader和cache manager两个进程

主进程的主要作用是读取配置和维护工作进程。

工作进程才是实际处理请求的。nginx依赖OS-dependent机制，以完成工作进程间请求的高效分发。工作进程数在nginx.conf中使用worker_processes指令指定，可以设置成固定值，也可以配置成自动调整为可用CPU内核数

###### 控制nginx

为了重载配置，可以停止或重启nginx，或发送信号到主进程。可以使用nginx命令（调用nginx可执行文件）和-s参数发送指令。

```shell
nginx -s SIGNAL
```

SIGNAL的值可以为：

- quit：优雅地关闭
- reload：重载配置文件
- reopen：重新打开日志文件
- stop：立刻关闭

kill命令也会直接发送信号到master process。master进程的PID默认写在nginx.pid文件，位于/usr/local/nginx/logs或/var/run。

更多关于signals可参考nginx.org的[Controlling nginx](http://nginx.org/en/docs/control.html)

#### 创建NGINX Plus和NGINX配置文件

NGINX和NGINX Plus与其他应用相似，都是使用基于文本text‑based的、有特定格式的配置文件。默认配置文件名是nginx.conf，NGINX Plus的是放在/etc/nginx目录，NGINX的存在位置，取决于用于安装nginx的包管理器package system和操作系统operating system，通常在/usr/local/nginx/conf，/etc/nginx或/usr/local/etc/nginx

###### 指令

配置文件由指令directives和参数parameters组成。 简单(单行）指令以分号结尾。其他指令像容器一样使用大括号将相关指令汇成一组，通常称为指令块。简单指令示例如下：

```
user             nobody;
error_log        logs/error.log notice;
worker_processes 1;
```

###### Feature-Specific配置文件

为了方便维护配置文件，推荐把配置内容分割成一组feature‑specific的配置文件，放在/etc/nginx/conf.d目录，并在主配置文件nginx.conf中使用include指令引入这些feature‑specific配置文件。

```
include conf.d/http;
include conf.d/stream;
include conf.d/exchange-enhanced;
```

###### Contexts

一些顶级指令，被称为context上下文，聚集不同通信方式traffic types的指令：

- events：General connection processing
- http：HTTP traffic
- mail：Mail traffic
- stream：TCP and UDP traffic

在这些contexts以外的指令，被认为是在main context中

###### 虚拟主机

在每个处理通信的context中，可以引入一个或多个server块，定义为虚拟主机，控制请求的处理。server context中可以引入的指令根据通信类型的不同而不同。

对于HTTP通信来说（http context），每个server指令控制着，对特定域名或IP资源的请求处理。一个server块中的一个或多个location context，又定义了如何处理匹配到的URIs的请求

对于mail和TCP/UDP通信（对应mail和stream context），每个server指令控制着，对特定TCP端口或UNIX socket的通信处理

###### 多context的简单配置

下面配置多context的示例.

```
# 指令，位于main context
user nobody;

# 处理connection的配置
events {
}

http {
    # HTTP配置，影响所有虚拟主机servers  

    server {
        # HTTP虚拟主机1配置     
        location /one {
            # 用来处理以/one开头的URIs的配置
        }
        location /two {
            # 用来处理以/two开头的URIs的配置
        }
    } 
    
    server {
        # HTTP虚拟主机2配置
    }
}

stream {
    # TCP/UDP配置，影响所有虚拟主机servers  
    server {
        # TCP虚拟主机1配置
    }
}
```

###### 继承

一般来说，子context，包含在另一个context（父context）中，会继承上级父context中的配置指令。一些指令可以出现在多个context中，所以可以通过覆写指令，来覆盖父context中的对应指令配置。如proxy_set_header指令。

###### 重载配置

对配置文件的修改要生效，就必须reload。可以restart nginx进程，也可以发送reload信号（不会打断当前请求的处理）。更多可查看上述【运行时控制nginx进程】小节

如果使用NGINX Plus，可以在不reload配置的情况下，通过upstream组中的虚拟主机servers，动态地重新配置load balancing。也可以使用NGINX Plus API和key‑value store来动态地控制访问control access，如通过客户端IP地址（IP黑名单）。


## 负载均衡器

#### HTTP负载均衡

该章节描述如何使用NGINX和NGINX Plus作为一个load balancer。

###### 概述

多个应用实例间的Load balancing是一项常用技术，用来优化资源使用、最大化吞吐量、降低延迟、容错保障。

如果nginx用户想构建大型、高可用的web应用，可以进一步参考[NGINX Plus for Load Balancing and Scaling](https://www.nginx.com/resources/webinars/nginx-plus-for-load-balancing-30-min)

nginx和nginx Plus可以被用在不同的部署场景下，作为高效的HTTP load balancer。

###### 代理HTTP通信到一组Server

使用nginx或nginx +，将http请求负载均衡到一组服务器上，需要先使用[upstream](https://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream)指令定义组。该指令位于[http](https://nginx.org/en/docs/http/ngx_http_core_module.html?#http) context中。

组中的服务器使用[server](https://nginx.org/en/docs/http/ngx_http_upstream_module.html#server)指令进行配置（**不要和定义虚拟主机的server块混淆了**）。例如下列配置，定义了一个名为backend的upstream组，包含了3个主机配置（可能对应不止3个实际主机）。其中两个运行同一个应用的实例，另一个作为备用server。

为了传递请求到server组（upstream），将组名指定到[proxy_pass](https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass)指令（或其他协议的fastcgi_pass、memcached_pass、scgi_pass、uwsgi_pass指令），下面定义了一个运行在nginx上的虚拟主机，将所有请求代理到backend upstream。

```
http {
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server 192.0.0.1 backup;
    }
    
    server {
        location / {
            proxy_pass http://backend;
        }
    }
}
```

**由于没有为upstream块指定负载均衡算法，nginx使用默认的Round Robin算法（轮询调度）**

###### 负载均衡方法

开源nginx支持4种负载均衡的方法，nginx plus额外增加了2种

- 1.Round Robin

requests均匀地在servers间分配，[server weights](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#weights)会被考虑。该方法是负载均衡的默认值（没有对应的指令）:

```
upstream backend {
   # no load balancing method is specified for Round Robin
   server backend1.example.com;
   server backend2.example.com;
}
```

- 2.[Least Connections](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#least_conn)

请求会被发送到最少活跃连接数的主机，server weights也会被考虑：

```
upstream backend {
    least_conn;
    server backend1.example.com;
    server backend2.example.com;
}
```

- 3.[IP Hash](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#ip_hash)

根据客户端IP，来决定请求被发送到哪个server。这种情况下，IPv4的前3个octet或者整个IPv6会被用来计算哈希值。该方式保证了，相同IP的请求由同一台server响应，除非该server不可用。

> Each IP address is 32 bits long and composed of four octets, or 8-bit fields. An octet is a decimal number in the range from 0 through 255. Each octet is separated by a period（句号）

```
upstream backend {
    ip_hash;
    server backend1.example.com;
    server backend2.example.com;
}
```

如果其中一台server需要暂时从负载均衡轮转中移除，可以使用[down](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#down)参数标记它，这样可以保护目前存在的客户端IP hash。原本将由该server处理的请求，交由组内的下一个server处理。

```
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com down;
}
```

- 4.Generic [Hash](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#hash)

由用户定义的key来决定请求发送到哪个主机，key可以是string、变量、或两者结合。例如key可能是资源IP和端口对、或URI：

```
upstream backend {
    hash $request_uri consistent;
    server backend1.example.com;
    server backend2.example.com;
}
```

hash指令的可选参数[consistent](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#hash)开启了[ketama](https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients) consistent‑hash load balancing。根据自定义的hashed key，请求被均匀的分配到upstream中的所有server。如果upstream组中新增或移除一个server，对于负载均衡缓存服务器load‑balancing cache servers或其他状态累计的应用other applications that accumulate state来说，只有一小部分key会被重新映射，这样会最小化缓存的未命中率。

- 5.Least Time (NGINX Plus only)

该方式只要nginx plus，这里不做翻译，可参考[官方原文](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#method)

- 6.Random

每个请求都被随机传递到某个server。如果指定了two参数，首先NGINX会随机（考虑权重）选取2台server，然后再使用下列方法选取一个server:

- least_conn：最少活跃连接数
- least_time=header (NGINX Plus)：从server接收到响应头的最小平均时间($upstream_header_time)
- least_time=last_byte (NGINX Plus)：从server接收到完整响应的最小平均时间($upstream_response_time)

```
upstream backend {
    random two least_time=last_byte;
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
    server backend4.example.com;
}
```

Random算法应该应用在分布式环境，即多个load balancers传递requests到同一组backends（upstream）。对于the load balancer has a full view of all requests（一个负载均衡器处理所有请求）的环境，可以使用其他负载均衡算法，如RR、least connections、least time。

> 注意：当配置除RR以外的方法时，要将相应的指令（hash、ip_hash、least_conn、least_time、r random）放在upstream内的server前。


###### 主机权重

默认情况下，nginx使用RR算法，根据server的权重分发请求。server的[weight](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#weight)参数用来设置该主机的权重，默认值1。

```
upstream backend {
    server backend1.example.com weight=5;
    server backend2.example.com;
    server 192.0.0.1 backup;
}
```

上例中，backend1.example.com权重5，其他两个默认权重是1。其中192.0.0.1被标记为backup，它不接收请求，除非其他两个都不可用的时候。该配置下，每6个request，5个被发送到backend1.example.com，1个被发送到backend2.example.com。

###### Server Slow-Start

server的slow-start慢启动特性，可以保护一个最近恢复的server，不被connections压垮，否则可能会连接超时，导致该server被再次标记成failed。

在nginx Plus中，slow‑start允许upstream中的主机，在恢复或变得可用之后，从0逐渐恢复它的weight到正常值。可以在server指令中使用[slow_start](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#slow_start)参数来实现：

```
upstream backend {
    server backend1.example.com slow_start=30s;
    server backend2.example.com;
    server 192.0.0.1 backup;
}
```

时间值（30s）表示：NGINX Plus将该server的连接数，斜坡提升到最大值的时间。

如果group中只有一个server，server指令的[max_fails](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#max_fails)、[fail_timeout](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#fail_timeout)和slow_start参数都会被忽略，并且该server被认为是一直可用的。

###### 开启会话保持

[Session persistence](https://www.nginx.com/resources/glossary/session-persistence/) 会话保持，是指nginx Plus识别用户会话Session，并将给定Session的所有请求路由到同一个主机。

NGINX Plus支持三种保持会话的方法，使用[sticky](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#sticky)指令来设置。（对于NGINX OSS，使用hash或ip_hash指令）

- 1.[Sticky cookie](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#sticky_cookie)

NGINX Plus为从upstream组发出的第一次response添加一个session cookie，并确认哪个server发送的响应。客户端的下次请求包含该cookie，NGINX Plus会路由该请求到第一次响应的那个upstream server：

```
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
    sticky cookie srv_id expires=1h domain=.example.com path=/;
}
```

该例中，srv_id参数设定了cookie名，可选参数expires设定了浏览器保存该Cookie的过期时间（1小时），可选参数domain定义了cookie的域，可选参数path定义了cookie路径。这是最简单的会话保持方式。

- [Sticky route](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#sticky_route)

第一次接到请求时，NGINX Plus为客户端指定一个"route"。后续的请求都会跟server指令的route参数比较，来确认哪个server来处理该请求。route信息可以通过cookie或请求URI传递。

```
upstream backend {
    server backend1.example.com route=a;
    server backend2.example.com route=b;
    sticky route $route_cookie $route_uri;
}
```

- [Cookie learn](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#sticky_learn)

NGINX Plus首先通过请求和响应找到Session ID。然后NGINX Plus会"学习"哪个upstream server对应哪个Session ID。通常ID是通过Cookie传递。如果一个请求的Session ID已经"被学习"过了，NGINX Plus会转发请求到对应的server：

```
upstream backend {
   server backend1.example.com;
   server backend2.example.com;
   sticky learn
       create=$upstream_cookie_examplecookie
       lookup=$cookie_examplecookie
       zone=client_sessions:1m
       timeout=1h;
}
```

该例中，其中一个主机，会通过在响应中设置EXAMPLECOOKIE Cookie，来创建一个Session。

必须参数create指定一个变量，表示如何创建一个新Session。该例中，根据主机发送的EXAMPLECOOKIE Cookie创建。

必须参数lookup指定如何搜索存在的Session。该例中，会从客户端发送的EXAMPLECOOKIE Cookie中查找。

必须参数zone指定一个共享的内存区域，用以保持sticky sessions的所有信息。该例中，该区域名为client_sessions，大小1M。

该方式比上两个更精致，因为不需要在客户端保存Cookie，所有信息都保存在服务端的共享内存区域。

如果是多个nginx实例的集群使用sticky learn方式，可以同步各个共享内存区域中的内容，但需要满足：

- 1.zone名称都相同
- 2.每个实例都配置了[zone_sync](https://nginx.org/en/docs/stream/ngx_stream_zone_sync_module.html?#zone_sync)功能
- 3.指定了sync参数

```
sticky learn
   create=$upstream_cookie_examplecookie
   lookup=$cookie_examplecookie
   zone=client_sessions:1m
   timeout=1h
   sync;
}
```

更多可参考[Runtime State Sharing in a Cluster](https://docs.nginx.com/nginx/admin-guide/high-availability/zone_sync/)

###### 限制连接数

对于NGINX Plus，通过使用[max_conns](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&#max_conns)参数指定最大连接数，限制某个upstream server的连接数。

当达到最大连接数时，如果使用了[queue](https://nginx.org/en/docs/http/ngx_http_upstream_module.html?#queue)指令设置了队列中同时存在的最大请求数，则后续的request会进入队列等待被处理。

```
upstream backend {
    server backend1.example.com max_conns=3;
    server backend2.example.com;
    queue 100 timeout=70;
}
```

使用了可选参数timeout时，在指定的超时时长内，如果队列满了，或者upstream server不能被选中，客户端会收到一个error。

注意，如果在其他worker进程中，某主机有打开的空闲keepalive连接，max_conns的限制会被忽略。这就导致了，当多个worker进程共享内存时，一个server的总连接数可能会超过max_conns值。

> keepalive指定的是upstream组中的每个server的最大空闲连接数，max_conns指定的是某个server的最大连接数。

###### Passive Health Checks
###### Active Health Checks

###### 多工作进程共享数据

如果upstream块中没有zone指令，每个worker进程只保留自己对server组配置的副本，只维护自己的相关计数器。计数器包括组中每个server的当前连接数和某个请求对某个server的失败重试次数。这导致server组的配置不能被动态地修改。

当在upstream中使用zone指令时，upstream组的配置被保存在内存中，被所有的worker进程共享。这种情况下是动态可配置的，因为所有worker进程

###### Setting the Zone Size
###### Configuring HTTP Load Balancing Using DNS
###### Load Balancing of Microsoft Exchange Servers
###### Complete NTLM Example
###### Dynamic Configuration Using the NGINX Plus API




#### TCP and UDP Load Balancing

#### HTTP Health Checks

#### TCP Health Checks

#### UDP Health Checks

#### Configuring Dynamic Load Balancing with the NGINX Plus API

#### Accepting the PROXY Protocol


---

# V.Controlling nginx

nginx可以使用signals进行控制。master进程的PID默认被写入/usr/local/nginx/logs/nginx.pid文件。该文件名可能在配置期，或者在nginx.conf中使用pid指令被修改。**主进程**支持下列signals：

- TERM、INT：快速关闭
- QUIT：优雅地关闭
- HUP：更改配置、keeping up with a changed time zone (only for FreeBSD（一个类UNIX操作系统） and Linux)、使用新配置开启新worker进程、优雅地关闭老worker进程
- USR1：re-opening log files
- USR2：upgrading an executable file
- WINCH：优雅地结束worker进程

尽管不需要，但**个别工作进程**可以使用以下signals进行控制：

- TERM、INT：快速关闭
- QUIT：优雅地关闭
- USR1：re-opening log files
- WINCH：异常结束debugging（需要debug_points开启）

## Changing Configuration

为了让nginx重新读取配置文件，需要发送HUP signal到master进程。首先主进程会语法的合法性，然后尝试应用新配置，即打开log文件和新listen sockets。如果尝试失败，nginx会回滚改变，继续使用旧配置。如果尝试成功，nginx会开启new worker进程，并且发送消息到old worker进程，要求他们优雅地关闭。Old worker进程停止监听sockets，但会继续处理旧客户端请求。在所有clients被处理后，old worker进程被关闭。

通过以下示例进行说明。假设nginx运行在FreeBSD，命令是：

```shell
ps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep '(nginx|PID)'
```

输出:

```
  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx
33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)
33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)
```

如果发送HUP到master进程，输出变为：

```
  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
```

其中一个old worker进程（PID 33129）将继续工作。一段时间后它会关闭：

```
  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND
33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx
33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)
```

## Rotating Log-files

为了rotate log files，需要先重命名，然后发送USR1 signal到master进程。主进程会重新打开所有当前打开的日志文件，把它们归属到一个unprivileged user（worker进程运行在该user下）。成功重新打开后，主进程关闭所有打开的文件，并发送消息到工作进程，要求它们重新打开文件。工作进程立刻打开新文件，关闭老文件。结果，old files几乎立刻对post processing可用， 比如压缩。

## Upgrading Executable on the Fly

运行时更改可执行文件，这里不做介绍，可参考[官方原文](http://nginx.org/en/docs/control.html#upgrade)


---

# VI.Connection处理方法

nginx支持很多处理连接方法。某个方法是否可用取决于使用的系统平台。对于支持多种处理方法的平台，nginx会自动选择一个最高效的。但如果需要，可以显式的使用use指令指定一种connection处理方法。

connection支持下列各种处理方法：

- select：标准方法。当没有更有效率的方法时，该平台自动构建此方法的支持模块。with-select_module和without-select_module参数可以用来强制启动或者停止构建该模块。

- pool：标准方法。当该没有更有效率的方法时，该平台自动构建此方法的支持模块。with-pool_module和without-pool_module参数可以用来强制启动或者停止构建该模块。

- kqueue：用在FreeBSD 4.1+、OpenBSD 2.9+、NetBSD 2.0和Mac OS X上的有效方法。

- epool：用在linux2.6+上的有效方法。从1.11.3开始支持EPOLLRDHUP(Linux 2.6.17, glibc 2.8)和EPOLLEXCLUSIVE(Linux 4.5, glibc 2.24) flags。一些旧的版本例如SUSE8.2提供在kernel2.4版本上支持epool的补丁。

- /dev/poll：在Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, 和Tru64 UNIX 5.1A+.上使用的有效方法。

- eventport：在Solaris 10.上使用的有效方法。（由于一些已知原因，推荐使用/dev/poll代替该方法）


---

# VII.Setting up hashes

为了快速处理数据的静态部分，如server名称、map指令的值、MIME类型、请求头的名称字符串，nginx使用了hash表。启动或每次重新配置时，nginx选择最小可能容量的hash表



---

# VIII.nginx调试日志

为了启动一个调试日志，nginx需要在构建时配置支持调试模式。

```
./configure --with-debug ...
```

其次，需要使用err_log指令设置调试级别：

```
err_log /path/to/log debug;
```

验证nginx是否配置成了支持debug，运行nginx -V命令：

```
configure arguments: --with-debug ...
```

预编译的Linux包，通过nginx-debug二进制文件（1.9.8），提供了对debug log开箱即用的支持。可以通过以下命令使用：

```
service nginx stop
service nginx-debug start
```

然后设置debug级别。nginx的二进制windows版本通常在构建时已经支持调试日志，因此只需要设置调试级别就足够了。

注意：重新定义日志而不指明调试级别将使调试日志失效。下面的例子，重新定义了一个服务器的日志导致该服务器上调试日志失效。

```
error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log;
        ...
```

为避免出现这种情况，要么注释掉重新定义的日志，要么在配置上加上调试级别。如下：

```
error_log /path/to/log debug;

http {
    server {
        error_log /path/to/log debug;
        ...
```


## 为指定客户端开启debug log

也可以仅通过使用[selected_client_addresses](http://nginx.org/en/docs/ngx_core_module.html#debug_connection)使调试日志对指定客户端生效：

```
error_log /path/to/log;

events {
    debug_connection 192.168.1.1;
    debug_connection 192.168.10.0/24;
}
```

## Logging to a cyclic memory buffer

debug log可以写到一个cyclic memory buffer中

```
error_log memory:32m debug;
```

debug级别写log到memory buffer，对性能没有太大影响，即使是在高负荷时。在这种情况下，log可以使用类似下述的gdb脚本提取出来。

```
set $log = ngx_cycle->log

while $log->writer != ngx_log_memory_writer
    set $log = $log->next
end

set $buf = (ngx_log_memory_buf_t *) $log->wdata
dump binary memory debug_log.txt $buf->start $buf->end
```


---

# VX.Logging to syslog

---

# X.配置文件中的度量单位

容量大小可以使用bytes、kilobytes(后缀k或K)、megabytes(后缀m或M)，比如"1024"、"8k"、"1m"。

还可以使用gigabytes，即使用g或G后缀。

时间间隔可以使用毫秒、秒、分、时、天等，对应后缀：

|后缀|时间间隔|
|:--:|:--:|
|ms|milliseconds|
|s|seconds|
|m|minutes|
|h|hours|
|d|days|
|w|weeks|
|M|months,30 days|
|y|years,365 days|

多个单位可以混合使用，从大单位到小单位的顺序，使用空格分割，例如1h 30m等同于90m或者5400s。一个值没有后缀，默认是秒。推荐指定后缀，尽可能使用同一种单位。

一些时间间隔可以只使用s来解决。


---

# XI.命令行参数

nginx支持下列命令行参数：

- \-? | \-h：查看命令行参数帮助
- \-c *file*：指定配置文件，代替默认的配置文件
- \-g *directives*：设置[global configuration directives](http://nginx.org/en/docs/ngx_core_module.html)如：

```shell
nginx -g "pid /var/run/nginx.pid; worker_processes `sysctl -n hw.ncpu`;"
```

- \-p *prefix*：设置nginx路径前缀，如保存主机文件的目录（默认是/usr/local/nginx）
- \-q：在配置文件测试期间，抑制发出非error警告
- \-s *signal*：发送信号到主线程，信号可以是：
    - stop：立刻关闭
    - quit：优雅地关闭
    - reload：重载配置，使用新配置开启新工作进程，优雅地关闭老工作进程
    - reopen：重新打开日志文件
- \-t：测试配置文件的语法，然后尝试打开配置文件中的引用文件
- \-T：和\-t一样，但会自动输出配置文件
- \-v：打印nginx版本
- \-V：打印nginx版本、编译器版本、配置参数


---

# XII.nginx for Windows

nginx的Windows版本使用了native Win32 API（而不是Cygwin emulation layer）。只有select()连接处理方法目前在用，所以不要预计会有高性能和可伸缩性。基于这个原因和其他已知问题，Windows版的nginx被认为是beta版。除XSTL过滤器、图片过滤器、GeoIP模块和内置Perl语言以外，它提供了大部分同UNIX版的功能。

安装nginx/Windows，[下载](http://nginx.org/en/download.html)最新mainline版本（1.15.8），因为主线版本包括了所有已知修复。然后解压，在nginx-1.15.8目录，运行nginx。下面是个C盘根目录的例子：

```shell
cd c:\
unzip nginx-1.15.8.zip
cd nginx-1.15.8
start nginx
```

执行tasklist命令行，查看nginx进程

```shell
C:\nginx-1.15.8>tasklist /fi "imagename eq nginx.exe"

Image Name           PID Session Name     Session#    Mem Usage
=============== ======== ============== ========== ============
nginx.exe            652 Console                 0      2 780 K
nginx.exe           1332 Console                 0      3 112 K
```

一个是主进程，另一个是工作进程。如果nginx没有启动，在logs/error.log中查看原因。如果没有创建log文件，会报告在Windows Event Log中。如果显示的不是预期页面，而是error页面，也查看logs/error.log寻找原因。

nginx/Windows使用其被运行的目录，作为其配置文件中的相对路径。上例中，前缀就是C:\nginx-1.15.8。配置文件中的路径必须使用UNIX风格的斜杠：

```
access_log   logs/site.log;
root         C:/web/html;
```

nginx/Windows作为一个标准控制台应用standard console application（不是服务service），可以使用以下命令管理：

```
# 快速关闭
nginx -s stop
# 优雅地关闭
nginx -s quit
# 更新配置，使用新配置开启新worker进程，优雅地关闭老worker进程
nginx -s reload
# 重新打开日志文件
nginx -s reopen
```

## 已知问题

- 尽管可以开启多个worker进程，只有其中一个真正地做所有工作
- 一个worker进程同时最多可以处理1024个连接
- 不支持UDP代理功能

## 未来可能的加强

- 作为一个服务service运行
- 使用I/O completion ports作为一个连接处理方法connection processing method
- 在单个worker进程中，使用多个工作线程worker threads


---

# XIII.nginx如何处理一个请求

## 基于名称的虚拟主机

nginx首先决定由哪个server来处理请求。以下示例中，3个虚拟主机都监听80端口

```
server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
```

在该配置中（一台主机配置了多个域名站点），nginx只根据请求头中的Host字段，来决定路由到哪个server。如果Host的值不匹配任何server_name，或者请求中根本就没有Host字段，nginx会路由该request到默认server。在上述配置中，默认server是第一个（nginx的默认行为）。也可以使用listen指令的default_server参数，来明确指定default server

```
server {
    listen      80 default_server;
    server_name example.net www.example.net;
    ...
}
```

> 在0.8.21版本之后，才使用default_server参数。更早版本使用的是default参数。注意默认主机是listen的一个属性，而非server_name的。

## 如何防止处理未定义主机名的请求

对于请求头中没有Host字段的request，应该被禁止。下面是一个丢弃这样request的示例：

```
server {
    listen      80;
    server_name "";
    return      444;
}
```

这里server_name是个空串，所以它将匹配所有没有Host header的请求，并返回一个特殊的nginx非标状态码444，用来关闭连接。

> 自从0.8.48版本，server_name的默认值就是空串，所以这里server_name ""可以省略。更早版本中，默认的server_name是使用主机的hostname。

## 基于name和IP混合的虚拟主机

一个稍复杂的示例，多个虚拟主机监听了不同IP的80端口

```
server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80;
    server_name example.com www.example.com;
    ...
}
```

该配置中，nginx首先测试请求的IP地址和端口是否匹配某个server配置块中的listen指令。然后继续测试请求的Host头是否匹配这个server块中的某个server_name的值。如果server_name没有找到，请求将交由default server处理。比如，一个从192.168.1.1:80端口收到的访问www.example.com的请求，该请求将由第一个监听192.168.1.1:80的default server处理（没指定，nginx默认第一个），因为192.168.1.1:80端口上没有匹配到名为www.example.com的虚拟主机。

default server是listen指令的一个属性，所以对于不同的端口，可以指定对应的default server：

```
server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80 default_server;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80 default_server;
    server_name example.com www.example.com;
    ...
}
```

## 一个简单的PHP站点配置

现在我们来看在一个典型的，简单的PHP站点中，nginx怎样为一个请求选择location来处理：

```
server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
```

首先，nginx使用前缀匹配找出最准确的location，这一步nginx会忽略location在配置文件出现的顺序。上面的配置中，唯一的前缀匹配location是"/"，而且因为它可以匹配任意的请求，所以被作为最后一个选择。接着，nginx继续按照配置中的顺序依次匹配正则表达式的location，匹配到第一个正则表达式后就停止搜索。匹配到的正则location将被使用。如果没有匹配到**正则表达式的location**，则使用刚刚找到的**最精确的前缀匹配的location**。

请注意所有location匹配测试只使用请求的URI部分，而不使用参数部分。这是因为写参数的方法很多，比如：

```
/index.php?user=john&page=1
/index.php?page=1&user=john
```

除此以外，任何人在请求串中都可以随意添加字符串：

```
/index.php?page=1&something+else&user=john
```

现在让我们来看使用上面的配置，请求是怎样被处理的：

- 请求"/logo.gif"首先匹配上location "/"，然后匹配上正则表达式"\.(gif|jpg|png)$"。因此，它将被后者处理。根据"root /data/www"指令，nginx将请求映射到文件/data/www/logo.gif"，并发送该文件到客户端。

- 请求"/index.php"首先也匹配上location "/"，然后匹配上正则表达式"\.(php)$"。 因此，它将被后者处理，进而被发送到监听在localhost:9000的FastCGI服务器。fastcgi_param指令将FastCGI的参数SCRIPT_FILENAME的值设置为"/data/www/index.php"，接着FastCGI服务器执行这个文件。变量$document_root等于root指令设置的值，变量$fastcgi_script_name的值是请求的uri，"/index.php"。

- 请求"/about.html"仅能匹配上location "/"，因此，它将使用此location进行处理。根据"root /data/www"指令，nginx将请求映射到文件"/data/www/about.html"，并发送该文件到客户端。

- 请求"/"的处理更为复杂。它仅能匹配上location "/"，因此，它将使用此location进行处理。然后，index指令使用它的参数和"root /data/www"指令所组成的文件路径来检测对应的文件是否存在。如果文件/data/www/index.html不存在，而/data/www/index.php存在，此指令将执行一次内部重定向到"/index.php"，接着nginx将重新寻找匹配"/index.php"的location，就好像这次请求是从客户端发过来一样。正如我们之前看到的那样，这个重定向的请求最终交给FastCGI服务器来处理。


---

# 虚拟主机名

虚拟主机名使用server_name指令定义，用于决定由哪台虚拟主机来处理请求。具体请参考上节《nginx如何处理一个请求》。虚拟主机名可以使用：确切的名字、通配符、正则表达式：

```
server {
    listen       80;
    server_name  example.org  www.example.org;
    ...
}

server {
    listen       80;
    server_name  *.example.org;
    ...
}

server {
    listen       80;
    server_name  mail.*;
    ...
}

server {
    listen       80;
    server_name  ~^(?<user>.+)\.example\.net$;
    ...
}
```

当nginx通过名字查找虚拟主机时，如果名字匹配了多个主机名定义，比如同时匹配了通配符名字定义和正则表达式名字定义，那么nginx按照下面的优先级别进行查找，并选中第一个匹配的虚拟主机：

- 确切的名字；
- 最长的以星号起始的通配符名字：*.example.org；
- 最长的以星号结束的通配符名字：mail.*；
- 第一个匹配的正则表达式名字（按在配置文件中出现的顺序）

## 通配符名字

通配符名字要求，只可以在名字的起始处或结尾处包含一个星号，并且星号与其他字符之间用点分隔。所以，"www.\*.example.org"和"w\*.example.org"都是非法的。不过，这两个名字可以使用正则表达式描述，即"~^www\..+\.example\.org$"和"~^w.*\.example\.org$"。星号可以匹配名字的多个节（各节都是以点号分隔的），"\*.example.org"不仅匹配www.example.org，也匹配www.sub.example.org。

有一种形如".example.org"的特殊通配符，既匹配确切名字"example.org"，也可以匹配通配符名字"\*.example.org"。

## 正则表达式名字

nginx使用的正则表达式兼容PCRE（Perl语言）。为了使用正则表达式，虚拟主机名必须以波浪线"~"起始：

```
server_name  ~^www\d+\.example\.net$;
```

否则该名字会被认为是个确切的名字，或者如果表达式含星号，则会被认为是个通配符名字（而且很可能是一个非法的通配符名字）。不要忘记设置"^"和"$"锚点，语法上它们不是必须的，但是逻辑上是的。同时需要注意的是，域名中的点"."需要用反斜线"\"转义。含有"{"和"}"的正则表达式需要被引用（加引号），如：

```
server_name  "~^(?<name>\w\d{1,3}+)\.example\.net$";
```

否则nginx就不能启动，错误提示是：

```
directive "server_name" is not terminated by ";" in ...
```

一个命名的正则表达式捕获组在后面可以作为变量使用：

```
server {
    server_name   ~^(www\.)?(?<domain>.+)$;

    location / {
        root   /sites/$domain;
    }
}
```

PCRE使用下面语法支持命名捕获组：

- ?<name> 从PCRE-7.0开始支持，兼容Perl 5.10语法
- ?'name' 从PCRE-7.0开始支持，兼容Perl 5.10语法
- ?P<name>    从PCRE-4.0开始支持，兼容Python语法

如果nginx不能启动，并显示错误信息：

```
pcre_compile() failed: unrecognized character after (?< in ...
```

说明PCRE版本太旧，应该尝试使用?P<name>。捕获组也可以以数字方式引用：

```
server {
    server_name   ~^(www\.)?(.+)$;

    location / {
        root   /sites/$2;
    }
}
```

不过，这种用法只限于简单的情况（比如上面的例子），因为数字引用很容易被覆盖。

## 其他类型的名字

有一些主机名会被特别地对待。

如果需要用一个非默认的虚拟主机，处理请求头中不含Host字段的请求，需要指定一个空名字：

```
server {
    listen       80;
    server_name  example.org  www.example.org  "";
    ...
}
```

如果server块中没有定义server_name，nginx使用空名字作为虚拟主机名。（nginx 0.8.48版本以下（含）在同样的情况下会使用机器名作为虚拟主机名）

如果以"$hostname“（nginx 0.9.4及以上版本）定义虚拟主机名，机器名将被使用。

如果使用IP地址而不是主机名（域名）来请求服务器，那么请求头的Host字段包含的是IP地址。可以将IP地址作为虚拟主机名来处理这种请求：

```
server {
    listen       80;
    server_name  nginx.org
                 www.nginx.org
                 ""
                 192.168.1.1
                 ;
    ...
}
```

在匹配所有的服务器的例子中，可以见到一个奇怪的名字"_"：

```
server {
    listen       80  default_server;
    server_name  _;
    return       444;
}
```

这没什么特别的，它只不过是，成千上万个与真实的名字绝无冲突的非法域名中的一个而已。当然，也可以使用"--"和"!@#"等等。

nginx0.6.25及以下版本还支持一个特殊的名字"\*"，这个名字一直被错误地理解成是一个匹配所有的名字。但它从来没有像匹配所有的名字，或者通配符名字那样工作过，而是用来支持一种功能，此功能现在已经改由server_name_in_redirect指令提供了。所以，现在这个特殊的名字"\*"已经过时了，应该使用server_name_in_redirect指令取代它。需要注意的是，使用server_name指令无法描述一个匹配所有的名字或者默认服务器。server_name是listen指令的属性，而不是单独的指令。具体请参考《nginx如何处理一个请求》。可以定义两个服务器都监听*:80和*:8080端口，然后指定一个作为端口*:8080的默认服务器，另一个作为端口*:80的默认服务器：

```
server {
    listen       80;
    listen       8080  default_server;
    server_name  example.net;
    ...
}

server {
    listen       80  default_server;
    listen       8080;
    server_name  example.org;
    ...
}
```

## 国际化名字

国际化域名（IDNs）在server_name指令中，应该使用ASCII（Punycode）表示：

```
server {
    listen       80;
    server_name  xn--e1afmkfd.xn--80akhbyknj4f;  # пример.испытание
    ...
}
```

## 优化

确切名字和通配符名字存储在哈希表中，哈希表和监听端口关联。哈希表的尺寸在配置阶段进行了优化，为了查找名字的CPU缓存命中失败率最小化。设置哈希表的细节参见[这篇文档](http://nginx.org/en/docs/hash.html)

nginx首先搜索确切名字的哈希表，如果没有找到，搜索以星号起始的通配符名字的哈希表，如果还没找到，继续搜索以星号结束的通配符名字的哈希表。

因为名字是按照域名的节来搜索的，所以搜索通配符名字的哈希表比搜索确切名字的哈希表慢。注意特殊的通配符名字".example.org"存储在通配符名字的哈希表中，而不在确切名字的哈希表中。

正则表达式是一个一个串行测试的，所以是最慢的，而且不可扩展。

鉴于以上原因，请尽可能使用确切的名字。举个例子，如果使用example.org和www.example.org来访问服务器是最频繁的，那么将它们明确的定义出来就更为有效：

```
server {
    listen       80;
    server_name  example.org  www.example.org  *.example.org;
    ...
}
```

下面这种方法相比更简单，但是效率也更低：

```
server {
    listen       80;
    server_name  .example.org;
    ...
}
```

如果定义了大量名字，或者定义了非常长的名字，那可能需要在http配置块中使用server_names_hash_max_size和server_names_hash_bucket_size指令进行调整。server_names_hash_bucket_size的默认值可能是32，或者是64，或者是其他值，取决于CPU的缓存行的长度。如果这个值是32，那么定义"too.long.server.name.example.org"作为虚拟主机名就会失败，而nginx显示下面错误信息：

```
could not build the server_names_hash,
you should increase server_names_hash_bucket_size: 32
```

出现了这种情况，那就需要将指令的值扩大一倍：

```
http {
    server_names_hash_bucket_size  64;
    ...
```

如果定义了大量名字，得到了另外一个错误：

```
could not build the server_names_hash,
you should increase either server_names_hash_max_size: 512
or server_names_hash_bucket_size: 32
```

那么应该先尝试设置server_names_hash_max_size的值差不多等于名字列表的名字总量。如果还不能解决问题，或者服务器启动非常缓慢，再尝试提高server_names_hash_bucket_size的值。

如果只为一个监听端口配置了唯一的主机，那么nginx就完全不会测试虚拟主机名了（也不会为监听端口建立哈希表）。不过，有一个例外，如果定义的虚拟主机名是一个含有捕获组的正则表达式，这时nginx就不得不执行这个表达式以得到捕获组。

## 兼容性

- 从0.9.4版本开始，支持特殊的虚拟主机名“$hostname”。
- 从0.8.48版本开始，默认的虚拟主机名是空名字“”。
- 从0.8.25版本开始，支持虚拟主机名中使用命名的正则表达式捕获组。
- 从0.7.40版本开始，支持虚拟主机名中使用正则表达式的捕获组。
- 从0.7.12版本开始，支持空名字“”。
- 从0.6.25版本开始，通配符和正则表达式名字可以作为第一个虚拟主机名。
- 从0.6.7版本开始，支持正则表达式的虚拟主机名。
- 从0.6.0版本开始，支持形如example.*的通配符名字。
- 从0.3.18版本开始，支持形如.example.org的特殊通配符名字。
- 从0.1.13版本开始，支持形如*.example.org的通配符名字。

---

# 使用nginx做负载均衡器

## 介绍

多个应用实例间的负载均衡是一项常用技术，用来优化资源使用、最大化吞吐量、降低延迟、容错保障。

使用nginx作为一个高效的HTTP负载均衡器是可能的：分发请求到多个应用服务器，提高性能、可伸缩性、web应用的可靠性

## 负载均衡算法

nginx支持以下负载均衡机制（或算法）：

- round-robinL：使用轮询方式，分发请求到各应用服务器
- least-connected：下个请求将分配给活跃连接数最少的那台服务器
- ip-hash：使用一个hash方法来决定下个请求分给谁（基于客户端IP地址）

## 默认的负载均衡配置（round-robin）

nginx最简单的负载均衡配置，可能长这样：

```
http {
    upstream myapp1 {
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://myapp1;
        }
    }
}
```

上面示例中，有3个项目实例运行在srv1-srv3。没有指定负载均衡方法时，默认是RR方式。所有请求都代理到主机组app1，并且nginx使用HTTP负载均衡来分发请求。

nginx中的反向代理实现包括HTTP、HTTPS、FastCGI、uwsgi、SCGI、memcached、gRPC的负载均衡。

配置HTTPS的负载均衡，只需要使用http协议即可

当配置FastCGI、uwsgi、SCGI、memcached、gRPC的负载均衡时，使用相应的fastcgi_pass、uwsgi_pass、scgi_pass、memcached_pass、grpc_pass指令。

## 最少连接负载均衡（least_conn）

另一个负载均衡原则是最少连接数。当一些请求需要花费较长时间来完成时，最少连接数方式能够公平均匀的控制各应用实例上的负载。

使用最少连接数负载均衡时，nginx会试图不让繁忙的主机承载过多的请求，会将新请求分配到不太繁忙的主机上

在主机组（upstream）中使用least_conn指令开启最少连接数负载均衡：

```
upstream myapp1 {
    least_conn;
    server srv1.example.com;
    server srv2.example.com;
    server srv3.example.com;
}
```

## 持续会话（ip-hash）

在round-robin或least-connected负载均衡策略下，下个客户端请求可能会被分配给另一个不同的主机。不能保证同一个client一直由同一个server响应。

如果需要绑定某个client到指定的某个server，换句话说，使得客户端的会话"有粘性"或"持续性"，一直和某一台server进行通信。此时就可以使用ip-hash策略

在使用ip-hash策略时，客户端IP地址会被用作hashing key，来决定主机组中的哪台server来处理某client的请求。该方式保证来自同一client的请求，会被同一台server处理，除非该台server不可用了。

在主机组（upstream）中使用ip_hash指令，开启ip-hash负载均衡策略：

```
upstream myapp1 {
    ip_hash;
    server srv1.example.com;
    server srv2.example.com;
    server srv3.example.com;
}
```

## 加权负载均衡（Weighted）

可以使用server权重，进一步影响nginx的负载均衡算法。

在上述示例中，没有配置server的权重，那么对于一个特定的负载均衡策略，对待所有server的权重都相同。

特别地，对于round-robin轮询策略，假设有足够多的request，并且请求的处理方式统一、响应速度够快，那么权重意味着更多或更少的请求分配。

```
upstream myapp1 {
    server srv1.example.com weight=3;
    server srv2.example.com;
    server srv3.example.com;
}
```

该配置中，每5个请求将会以以下的方式在应用实例中被分配：3个请求被转发到srv1，1个去往srv2，另1个去往srv3

在最近nginx版本中，对于least-connected和ip-hash策略，使用权重和RR是类似的。

## 健康检查

nginx中的反向代理实现，包括了in-band（被动的）server health checks。如果来自某个server的响应失败报错了，nginx会将该server标记为failed，随后的一段时间，nginx会避免将后续的request分配给该server。

[max_fails](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server)指令（server的一个参数，也算一个指令），可以设置[fail_timeout](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server)（server的一个参数）时间内，连续尝试与该server通信失败的次数。max_fails默认值1，当设为0时，会关闭该server的健康检查。max_fails参数还可以定义该server被标记成failed的时长。在server失败的fail_timeout期间，nginx会使用活跃的client的请求，优雅地检测该server。如果探测成功，该server会被标记成存活的。

## 更多

另外，还有很多指令和参数可以控制nginx的负载均衡，如[proxy_next_upstream](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream)、[backup](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server)、[down](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server)、[keepalive](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive)。更多可参考[手册文档](http://nginx.org/en/docs/)。

最后，但不是最重要的，server groups的application load balancing、application health checks、activity monitoring、on-the-fly reconfiguration是付费的NGINX Plus中的可用功能。

下面的文章描述了NGINX Plus中的负载均衡的更多细节:

- [Load Balancing with NGINX and NGINX Plus](https://www.nginx.com/blog/load-balancing-with-nginx-plus)
- [Load Balancing with NGINX and NGINX Plus part 2](https://www.nginx.com/blog/load-balancing-with-nginx-plus-part2)


---

# 配置HTTPS服务器

配置HTTPS主机，必须在server配置块中打开SSL协议，还需要指定服务器端证书和密钥文件的位置：

```
server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ...
}
```

服务器证书是公开的，会被传送到每一个连接到服务器的客户端。而私钥不是公开的，需要存放在访问受限的文件中，当然，nginx主进程必须有读取密钥的权限。私钥和证书可以存放在同一个文件中：

```
ssl_certificate     www.example.com.cert;
ssl_certificate_key www.example.com.cert;
```

这种情况下，证书文件同样得设置访问限制。当然，虽然证书和密钥存放在同一个文件，只有证书会发送给客户端，密钥不会发送。

ssl_protocols和ssl_ciphers指令可以用来强制用户连接只能引入SSL/TLS那些强壮的协议版本和强大的加密算法。nginx默认使用"ssl_protocols TLSv1 TLSv1.1 TLSv1.2"和"ssl_ciphers HIGH:!aNULL:!MD5"，所以可以缺省这些配置。但需要注意这些指令的默认值已经被改变了很多次，可参考[兼容性](http://nginx.org/en/docs/http/configuring_https_servers.html#compatibility)。

## HTTPS服务器优化

SSL操作需要消耗很多CPU资源，所以在多处理器的系统，需要启动多个工作进程，而且数量需要不少于可用CPU的个数。最消耗CPU资源的SSL操作是SSL握手，有两种方法可以将每个客户端的握手操作数量降到最低：第一种是保持客户端长连接，在一个SSL连接发送多个请求，第二种是在并发连接或者后续连接中，重用SSL会话参数，这样可以避免SSL握手的操作。SSL会话保存在SSL会话缓存中，这些缓存在工作进程间共享，可以使用ssl_session_cache指令进行配置。1M缓存可以存放大约4000个会话。默认的缓存超时是5分钟，可以使用ssl_session_timeout加大它。下面是一个针对多核系统的配置优化的例子，使用10M的共享会话缓存：

```
worker_processes  auto;

http {
    ssl_session_cache    shared:SSL:10m;
    ssl_session_timeout  10m;

    server {
        listen              443 ssl;
        server_name         www.example.com;
        keepalive_timeout   70;

        ssl_certificate     www.example.com.crt;
        ssl_certificate_key www.example.com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;
        ...
```

## SSL证书链

有些浏览器不接受那些众所周知的证书认证机构签署的证书，而另外一些浏览器却接受它们。这是由于证书签发使用了一些中间认证机构，这些中间机构被众所周知的证书认证机构授权代为签发证书，但是它们自己却不被广泛认知，所以有些客户端不予识别。针对这种情况，证书认证机构提供一个证书链的包裹，用来声明众所周知的认证机构和自己的关系，需要将这个证书链包裹与服务器证书合并成一个文件。在这个文件里，服务器证书需要出现在认证方证书链的前面：

```
$ cat www.example.com.crt bundle.crt > www.example.com.chained.crt
```

这个文件需要使用ssl_certificate指令来引用：

```
server {
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.chained.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
```

如果服务器证书和认证方证书链合并时顺序弄错了，nginx就不能正常启动，而且会显示下面的错误信息：

```
SSL_CTX_use_PrivateKey_file(" ... /www.example.com.key") failed
   (SSL: error:0B080074:x509 certificate routines:
    X509_check_private_key:key values mismatch)
```

因为nginx会用私钥去解密该合并证书的第一个证书，即服务器证书，如果顺序错乱，解密的将是认证方的证书。

浏览器通常会将那些被受信的认证机构认证的中间认证机构保存下来，那么这些浏览器以后在遇到使用这些中间认证机构但不包含证书链的情况时，因为已经保存了这些中间认证机构的信息，所以不会报错。可以使用openssl命令行工具来确认服务器发送了完整的证书链：

```shell
$ openssl s_client -connect www.godaddy.com:443
...
Certificate chain
 0 s:/C=US/ST=Arizona/L=Scottsdale/1.3.6.1.4.1.311.60.2.1.3=US
     /1.3.6.1.4.1.311.60.2.1.2=AZ/O=GoDaddy.com, Inc
     /OU=MIS Department/CN=www.GoDaddy.com
     /serialNumber=0796928-7/2.5.4.15=V1.0, Clause 5.(b)
   i:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
 1 s:/C=US/ST=Arizona/L=Scottsdale/O=GoDaddy.com, Inc.
     /OU=http://certificates.godaddy.com/repository
     /CN=Go Daddy Secure Certification Authority
     /serialNumber=07969287
   i:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
 2 s:/C=US/O=The Go Daddy Group, Inc.
     /OU=Go Daddy Class 2 Certification Authority
   i:/L=ValiCert Validation Network/O=ValiCert, Inc.
     /OU=ValiCert Class 2 Policy Validation Authority
     /CN=http://www.valicert.com//emailAddress=info@valicert.com
...
```

> 当使用SNI测试配置时，需要指定-servername选项，因为openssl默认不是使用SNI

在这个例子中，www.GoDaddy.com的服务器证书（#0）的受签/持有者（"s"）是被签发机构（"i"）签名的，而签发机构i又是证书（#1）的持有者，证书（#1）的签发机构是另一个签发机构，该机构又是证书（#2）的受签者，最后证书（#2）是被众所周知的签发机构ValiCert, Inc签发。ValiCert, Inc的证书存储在浏览器的内置证书基地中，被浏览器自动识别（这段话神似英国诗《在Jack盖的房子里》里面的内容）。

如果不是证书链，就只会显示服务器证书（#0）。


## 单个（合并）HTTP/HTTPS主机

可以配置一个虚拟主机，既处理HTTP请求，又处理HTTPS请求：

```
server {
    listen              80;
    listen              443 ssl;
    server_name         www.example.com;
    ssl_certificate     www.example.com.crt;
    ssl_certificate_key www.example.com.key;
    ...
}
```

> 在0.7.14之前，不能像上述示例一样，选择性的对单个端口开启SSL。只能使用SSL指令对整个server开启SSL，不能配置一个HTTP/HTTPS合并的server。后来添加的listen指令的ssl参数，解决了这个问题。现在的版本中不鼓励使用ssl指令了（使用listen指令中的ssl参数）。

## 基于名称的HTTPS主机

如果为同一个IP配置多个HTTPS主机，会出现一个很普遍的问题：

```
server {
    listen          443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
```

使用上面的配置，不论浏览器请求哪个主机，都只会收到默认主机www.example.com的证书。这是由SSL协议本身的行为引起的：先建立SSL连接，再发送HTTP请求，所以nginx建立SSL连接时不知道所请求主机的名字，因此，它只会返回默认主机的证书。

最古老的也是最稳定的解决方法就是每个HTTPS主机使用不同的IP地址：

```
server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}
```

## 带有多个主机名的SSL证书

也有其他一些方法可以实现多个HTTPS主机共享一个IP地址，但都有不足。其中一种方法是在"SubjectAltName"字段中使用有多个名字的一个证书，比如www.example.com和www.example.org。但"SubjectAltName"字段的长度有限制。

另一种方式是使用通配符名称的证书，比如*.example.org。该通配符证书保护其所有一级子域名，如该证书匹配www.example.org，但是不匹配example.org和www.sub.example.org。这两种方法可以结合使用，即在"SubjectAltName"字段中存放的多个名字的某证书，这些名字既可以是确切的名字，也可以是通配符名称，比如example.org和*.example.org。

最好将带有多个名字的证书和它的密钥文件配置在http配置块中，这样可以只保存一份内容拷贝，所有server都从中继承：

```
ssl_certificate      common.crt;
ssl_certificate_key  common.key;

server {
    listen          443 ssl;
    server_name     www.example.com;
    ...
}

server {
    listen          443 ssl;
    server_name     www.example.org;
    ...
}
```

## 主机名指示

在一个IP上运行多个HTTPS主机的更通用的方案，是TLS主机名指示扩展（SNI，RFC6066），它允许浏览器和服务器进行SSL握手时，将请求的主机名传递给服务器，因此服务器可以知道使用哪一个证书来服务这个连接。SNI目前被大部分主流浏览器所支持，可能不适用于部分老旧和特殊的浏览器：

> 通过SNI只能传递域名，但是，当请求中包含可读的IP地址时，某些浏览器将服务器的IP地址作为服务器的名字进行了传送。这是一个错误，大家不应该依赖于这个。

为了在nginx中使用SNI，那么无论是在编译nginx时使用的OpenSSL类库，还是在运行nginx时使用的OpenSSL运行库，都必须支持SNI。从0.9.8f版本开始，OpenSSL通过"--enable-tlsext"配置选项加入SNI支持，从0.9.8j版本开始，此选项成为默认选项。当nginx被编译成支持SNI时，在使用"-V"选项运行时会显示如下信息：

```
$ nginx -V
...
TLS SNI support enabled
...
```

但是，当开启SNI支持的nginx被动态链接到不支持SNI的OpenSSL库上时，nginx会显示如下警告：

```
nginx was built with SNI support, however, now it is linked
dynamically to an OpenSSL library which has no tlsext support,
therefore SNI is not available
```

## 兼容性

- 从0.8.21和0.7.62版本开始，使用"-V"选项运行nginx时，将显示SNI支持状态信息
- 从0.7.14版本开始，listen指令支持ssl参数。0.8.21之前的版本，它只能和default参数一起指定
- 从0.5.32版本开始，支持SNI
- 从0.5.6版本开始，支持SSL会话缓存，并可在工作进程间共享
- 1.9.1及以后版本，默认SSL协议是TLSv1、TLSv1.1和TLSv1.2（如果OpenSSL库支持）
- 0.7.65、0.8.19及以后版本，默认SSL协议是SSLv3、TLSv1、TLSv1.1和TLSv1.2（如果OpenSSL库支持）
- 0.7.64、0.8.18及以前版本，默认SSL协议是SSLv2、SSLv3和TLSv1
- 1.0.5及以后版本，默认SSL密码算法是"HIGH:!aNULL:!MD5"
- 0.7.65、0.8.20及以后版本，默认SSL密码算法是"HIGH:!ADH:!MD5"
- 0.8.19版本，默认SSL密码算法是"ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM"
- 0.7.64、0.8.18及以前版本，默认SSL密码算法是ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP


---

# How nginx processes a TCP/UDP session

---

# Scripting with njs

---

# Chapter "nginx" in "The Architecture of Open Source Applications"

---

该文只翻译nginx documentation的Introduction部分。其中拿不准的地方了保留原文，持续更新...
