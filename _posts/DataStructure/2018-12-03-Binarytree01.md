---
title: 二叉树
date: 2018-12-03 19:01:09
categories:
    - DataStructure
tags:
    - DataStructure
    - BinaryTree
---

本文将介绍二叉树的基本原理。

<!-- more -->

##### 目录
+ I.树简介
+ II.二叉树简介
+ III.二叉排序树
+ IV.红黑树
+ V.参考


---

# I.简介

## 1.树

**树**（tree）是一种非线性抽象数据模型，用来模拟树状结构的数据集合。二叉树是其中一种常用的数据结构（如二叉排序树、Huffman编码等），其他的还有红黑树、B树等

> 文件系统和数据库系统一般都采用树（特别是B树）结构，主要考虑到排序和查询效率。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/tree-example.png)

常见术语：
- 根节点、父节点、（左右）子节点、兄弟节点、堂兄弟节点、层、深度、高度
- 节点的度：节点的子树个数
- 树的度：该树中最大的节点的度
- 叶子节点：度为0的节点
- 分支节点：度不为0的节点
- 节点的层：根节点为第1层，以此类推
- 深度：从根到该节点的唯一路径长，根的深度为0
- 高度：从该节点到某叶子节点的最长路径，所有叶子节点的高度为0

> Java中，节点一般代表对象实例，边代表引用（成员变量）

## 2.树的优点

#### 树、数组、链表的比较

- **数组**：查找快，但增删慢，需要平均移动N/2次后面的数据
- **链表**：增删很快，只需要改变一些引用值，但查找慢，需要从第一个数据遍历，平均比较N/2次
- **树**：同时具备数组查找快、链表增删快的优点

> - 查询时间复杂度：例如某节点在第x层，查找时间为t，则约t/2的时间消耗在第x层，约t/4消耗在第(x-1)层...
> - 查询操作复杂度：例如1024个数据的链表或无序数组，查询需要平均比较512次，而二叉树平均只需要比较10次
> - 删除复杂度：例如1024个数据的数组，查找节点很快，但增删需要平均移动512次；而二叉树查找需要约10次比较，然后很少的时间来处理断点替换和上下代关系建立

树的效率取决于该节点所在层数。以二叉树为例：
- 每层最多2^(i-1)个节点
- K层树最多T=2^K-1个节点
- 增删查的时间复杂度都是为O(log2_T)（增删时维护上下代关系的时间很短）。


---
# II.二叉树简介

每个节点都有0-2个子节点的树。分为左右子树，每个子树也是二叉树（所以二叉树有递归含义）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example.png)

## 1.二叉树的存储结构

二叉树是一种非线性数据结构，每个节点至多一个前驱，可以有多个后继。一般采用数组、链表存储结构。

#### 1.1 数组结构

按层次遍历，从左到右依次存储树的每一层。根节点在arr[0]，arr[1]是根的左子节点，以此类推。

树的每个位置无论是否存在节点，都对应数组中的一个位置。即数组长度为2^K-1（K为树高度），没有的节点在数组中用0或者null表示

> 索引为index的元素对应的节点，其左子节点是2\*index+1，右子节点是2\*index+2，父节点是(index-1)/2。

一般情况，使用数组表示树，效率较低。不满的节点和删除掉的节点都会在数组中留下洞，浪费空间。更糟糕的情况是，删除节点如果需要移动子树时，子树中的每个节点都要移到数组中的新位置，非常费时。如果不允许真删除时，数组表示可能会有用。

#### 1.2 链表结构

- 二叉链表：用非连续存储的链表表示。每个结点包含三个域：数据域、左、右指针域
- 三叉链表：比二叉链表多一个域：父指针域

使用三叉链表，节点可以直接访问到父节点，但也增加了空间开销。一般使用二叉链表。

## 2.二叉树的特性

所有二叉树的通用特性：
- 1.非空二叉树的第i层（i≥1），最多有2^(i-1)个节点（等比数列）
- 2.深度为K的非空二叉树（k>=1)，最多有2^k-1个节点（等比数列之和）
- 3.如果非空二叉树的叶子节点个数为n0，度数为2的节点个数为n2，则n0=n2+1

> 设叶子节点个数为n0，度数为1的节点个数为n1，度数为2的节点个数为n2，则节点总数T=n0+n1+n2，那么连线（边）的个数为：T-1=n0+n1+n2-1=2×n2+n1，所以n0=n2+1

## 3.二叉树的遍历

- 深度优先遍历
    + 先序遍历（Pre-Order Traversal）
    + 中序遍历（In-Order Traversal）
    + 后序遍历（Post-Order Traversal）
- 广度优先遍历（层次遍历）

## 4.二叉树的分类

根据不同的特点，常见的二叉树可分为如下几种。稍后重点介绍最常用的二叉排序树

#### 4.1 二叉排序树

又称二叉搜索树，需要满足以下条件：
- 若左子树不为空，则左子树上所有节点的值均小于根节点的值
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉排序树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example1.png)

对二叉排序树进行**中序遍历，可以得到有序数列**，而先序和后序的遍历结果都是无序的。

> 对于值相等的节点可以根据业务需要，灵活的规定放在左或右节点，但规则必须在该树内统一

**二叉排序树保持了元素的顺序，是一种综合效率很高的数据结构。查找、插入、删除的效率都是O(h)，h为树的高度。最坏情况为O(N)（退化成链表），树平衡时为O(log2_T)，T为节点数。**

#### 4.2 斜树

所有节点都只有左子树（左斜树）或右子树（右斜树）。不需要像排序树一样比较大小排位

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example2.png)

> 这种树高度高，相当于链表，应用较少

#### 4.3 满二叉树

所有分支节点都有左子树和右子树，并且所有叶子节点都在最后一层。不需要向排序树一样比较大小排位
- 叶子都在最下一层
- 非叶子节点的度一定是2
- 同深度的二叉树中，满二叉树的节点个数最多，叶子树（节点）最多

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example3.png)

#### 4.4 完全二叉树

对有n个节点的二叉树，按层序编号（从上向下，从左向右），如果编号为i的节点（i从1-n），与同深度的满二叉树编号为i的节点位置相同，就是完全二叉树。不需要向排序树一样比较大小。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example4.png)

- 叶子节点都在最后一层或倒数第二层（满二叉树都在最后一层）
- 最下层的叶子节点一定集中在左部连续位置
- 倒数第二层，如有叶子节点，一定出现在右部连续位置。
- 相同节点数的二叉树，完全二叉树（或满二叉树）的高度最小

> 如果完全二叉树最后一层恰好排满就是满二叉树。即满二叉树是完全二叉树，反之不一定。

除上述二叉树通用特性外，完全二叉树还有下述特点：
- 1.深度为k的完全二叉树节点数为T：2^(k-1)-1 < T ≤ 2^k-1
- 2.节点总数为T的完全二叉树，深度为：[log2_T]+1
- 3.对完全二叉树的n个节点按层次序编号，对任一层编号为i的节点（1<=i<=n）有
    - 3.1 如果i=1，则节点i是二叉树的根。如果i>1，则其父节点编号为[i/2]（向下取整）
    - 3.2 如果2i>n，则节点i是叶子节点；如果2i=n，则其左孩子为2i，没有右孩子；如果2i< n，则其左孩子为2i，右孩子为2i+1

> 2由1推算而来（T是正整数）：2^(k-1) ≤ T ≤ 2^k-1 < 2^k，即k-1 ≤ log2_T < k

#### 4.5 平衡二叉树

AVL树。**首先平衡二叉树是一种二叉排序树**，其次要么是空树，要么满足：
- 1.左右子树深度之差的绝对值不超过1
- 2.左右子树仍然为平衡二叉树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example5.png)

AVL树每个节点的平衡因子只能是1、0、-1。绝对值超过1，则该二叉排序树就是不平衡的。

> 平衡因子：BF = 左子树深度 - 右子树深度

为了保证树的平衡，降低树深度，提高查询效率，需要一定的算法机制实现树的平衡，如AVL、Treap（树堆）、红黑树等。

二叉树最差的情况是斜二叉树（链表），此时查询时间复杂度为O(N)。即使没有退化为链表，如果排序二叉树高度不平衡，效率也会很低。平衡二叉树就是为了提高查询效率，查询效率近似于二分法，每次比较都缩小约一半的范围，查询时间复杂度O(log2_N)，所以其主要优点就是查找快。


---
# III.二叉排序树

BST（Binary Search Tree）。以二叉排序树（左< 父 ≤ 右）为例，叙述二叉树节点的查找、插入、删除和遍历等。

> 不论是查找、插入、删除或遍历等，大都需要从根节点开始遍历。

这里只记录实现思路，完整代码参考[study-datastructure](https://github.com/wocaishiliuke/study-datastructure)中的tree包。其中递归方式较简单，非递归方式需要使用循环（while）来代替递归操作。

## 1.查找节点

- 从root开始比较
    - 小于：继续查找左子树
    - 等于：查找结束
    - 大于：继续查找右子树

如果二叉树是比较平衡的，则每次比较都能将比较范围缩小一半（二分法），效率很高。（**其实是把时间成本放到了插入时的比较上**。

## 2.查找最值

即查找最左或最右节点

## 3.插入节点

- 从root开始比较
    - 1.如果此时root为空，作为root节点即可
    - 2.如果此时root不为空，和root比较
        + 小于：如果左孩子为空，作为root的左孩子即可；否则继续和左孩子比较...
        + 等于大于：如果右孩子为空，作为root的右孩子即可；否则继续和右孩子比较...

## 4.遍历节点

对于二叉排序树，中序遍历是有序的，先、后序遍历的结果是无序的。

> 中序：左-根-右，先序：根-左-右，后序：左-右-根

具体实现包括递归和非递归方式，参考源码。源码中还包括了层次遍历的实现

## 5.删除节点

#### 5.1 假删除

不改变原有树结构，通过设置节点属性达到删除效果。

#### 5.2 真删除

删除后需要保证仍是二叉排序树，即需要选择替补节点，分三种情况：
- 1.查找目标节点、目标节点的父节点，以及确定目标节点是父节点的左孩子还是右孩子（isLeftChild）
- 2.删除目标节点
    + 2.1 目标节点是叶子节点（不需要替补）
        * 断绝父子关系即可，剩余交由GC处理
    + 2.2 目标节点只有左或右孩子（左或右孩子直接替补）
        * 将目标节点的父节点原本指向目标节点的引用，改为指向该节点的子节点即可
    + 2.2 目标节点有两个子节点
        * a.先确定替补者、替补者的父节点。这里替补者使用目标节点的右子树的最小值（最左最深），**此时替补者肯定没有左孩子**
        * b.处理替补者被带走后的残局，即处理替补者替补前的上下代关系：如果有右孩子，移动到替补者的位置）
        * c.替补，即处理替补者替补后的上下代关系

> 上述2.2.a中，替补者也可以使用左子树的最大值（最右最深），则该替补者没有右孩子


---
# IV.红黑树

拷贝美团技术团队的[红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)。






---
# V.参考

- [文章中的源码实现](https://github.com/wocaishiliuke/study-datastructure)
- [红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)