---
title: 二叉树
date: 2018-12-03 19:01:09
categories:
    - DataStructure
tags:
    - DataStructure
    - BinaryTree
---

本文将介绍二叉树的基本原理。

<!-- more -->

##### 目录
+ I.树
+ II.二叉树
+ III.二叉排序树
+ IV.AVL树
+ V.红黑树
+ VI.参考


---

# I.树

## 1.树的简介

**树**（tree）是一种非线性抽象数据模型，用来模拟树状结构的数据集合。二叉树是其中一种常用的数据结构（如二叉排序树、Huffman编码等），其他的还有红黑树、B树等

> 文件系统和数据库系统一般都采用树（特别是B树）结构，主要考虑到排序和查询效率。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/tree-example.png)

常见术语：
- 根节点、父节点、（左右）子节点、兄弟节点、堂兄弟节点、层、深度、高度
- 节点的度：节点的子树个数
- 树的度：该树中最大的节点的度
- 叶子节点：度为0的节点
- 分支节点：度不为0的节点
- 节点的层：根节点为第1层，以此类推
- 深度：从根到该节点的唯一路径长，根的深度为0
- 高度：从该节点到某叶子节点的最长路径，所有叶子节点的高度为0

> Java中，节点一般代表对象实例，边代表引用（成员变量）

## 2.树的效率

树、数组、链表的比较

- **数组**：查找快，但增删慢，需要平均移动N/2次后面的数据
- **链表**：增删很快，只需要改变一些引用值，但查找慢，需要从第一个数据遍历，平均比较N/2次
- **树**：同时具备数组查找快、链表增删快的优点

二叉树为例：
- 查询时间复杂度：例如某节点在第x层，查找时间为t，则约t/2的时间消耗在第x层，约t/4消耗在第(x-1)层...
- 查询操作复杂度：例如1024个数据的链表或无序数组，查询需要平均比较512次，而二叉树平均只需要比较10次
- 删除复杂度：例如1024个数据的数组，查找节点很快，但增删需要平均移动512次；而二叉树查找需要约10次比较，然后很少的时间来处理断点替换和上下代关系建立

树的效率取决于该节点所在层数。以二叉树为例：
- 每层最多2^(i-1)个节点
- K层树最多T=2^K-1个节点
- 增删查的时间复杂度都是为O(log2_T)（增删时维护上下代关系的时间很短）。


---
# II.二叉树

每个节点都有0-2个子节点的树。分为左右子树，每个子树也是二叉树（二叉树有递归含义）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example.png)

## 1.二叉树的存储结构

二叉树是一种非线性数据结构。每个节点最多一个前驱，可以有多个后继。一般采用数组、链表存储结构来实现。

#### 1.1 数组结构

按层次遍历，从左到右依次存储树的每一层。根节点在arr[0]，arr[1]是根的左子节点，以此类推。

树的每个位置无论是否存在节点，都对应数组中的一个位置。即数组长度为2^K-1（K为树高度），没有的节点在数组中用0或者null表示

> 索引为index的元素对应的节点，其左子节点是2×index+1，右子节点是2×index+2，父节点是(index-1)/2。

一般情况，使用数组表示树，效率较低。不满的节点和删除掉的节点都会在数组中留下洞，浪费空间。更糟糕的情况是，删除节点如果需要移动子树时，子树中的每个节点都要移到数组中的新位置，非常费时。如果不允许真删除时，数组表示可能会有用。

#### 1.2 链表结构

用非连续存储的链表表示：
- 二叉链表：每个节点包含三个域：数据域、左、右指针域
- 三叉链表：比二叉链表多一个域：父指针域

使用三叉链表，节点可以直接访问到父节点，但也增加了空间开销。一般使用二叉链表。

## 2.二叉树的特性

所有二叉树的通用特性：
- 1.非空二叉树的第i层（i≥1），最多有2^(i-1)个节点（等比数列）
- 2.深度为K的非空二叉树（k>=1)，最多有2^k-1个节点（等比数列之和）
- 3.如果非空二叉树的叶子节点个数为n0，度数为2的节点个数为n2，则n0=n2+1

> 设叶子节点个数为n0，度数为1的节点个数为n1，度数为2的节点个数为n2，则节点总数T=n0+n1+n2，那么连线（边）的个数为：T-1=n0+n1+n2-1=2×n2+n1，所以n0=n2+1

## 3.二叉树的遍历

- 深度优先遍历
    + 先序遍历（Pre-Order Traversal）
    + 中序遍历（In-Order Traversal）
    + 后序遍历（Post-Order Traversal）
- 广度优先遍历（层次遍历）

## 4.二叉树的分类

根据不同的特点，常见的二叉树可分为如下几种。稍后重点介绍最常用的二叉排序树

#### 4.1 斜树

所有节点都只有左子树（左斜树）或右子树（右斜树）。不需要像排序树一样比较大小排位

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example2.png)

> 这种树高度高，退化成了链表，应用较少

#### 4.2 满二叉树

所有分支节点都有左子树和右子树，并且所有叶子节点都在最后一层。不需要向排序树一样比较大小排位
- 叶子都在最下一层
- 非叶子节点的度一定是2
- 同深度的二叉树中，满二叉树的节点个数最多，叶子树（节点）最多

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example3.png)

#### 4.3 完全二叉树

对有n个节点的二叉树，按层序编号（从上向下，从左向右），如果编号为i的节点（i从1-n），与同深度的满二叉树编号为i的节点位置相同，就是完全二叉树。不需要向排序树一样比较大小。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example4.png)

- 叶子节点都在最后一层或倒数第二层（满二叉树都在最后一层）
- 最下层的叶子节点一定集中在左部连续位置
- 倒数第二层，如有叶子节点，一定出现在右部连续位置。
- 相同节点数的二叉树，完全二叉树（或满二叉树）的高度最小

> 如果完全二叉树最后一层恰好排满就是满二叉树。即满二叉树是完全二叉树，反之不一定。

除上述二叉树通用特性外，完全二叉树还有下述特点：
- 1.深度为k的完全二叉树节点数为T：2^(k-1)-1 < T ≤ 2^k-1
- 2.节点总数为T的完全二叉树，深度为：[log2_T]+1
- 3.对完全二叉树的n个节点按层次序编号，对任一层编号为i的节点（1<=i<=n）有
    - 3.1 如果i=1，则节点i是二叉树的根。如果i>1，则其父节点编号为[i/2]（向下取整）
    - 3.2 如果2i>n，则节点i是叶子节点；如果2i=n，则其左孩子为2i，没有右孩子；如果2i< n，则其左孩子为2i，右孩子为2i+1

> 2由1推算而来（T是正整数）：2^(k-1) ≤ T ≤ 2^k-1 < 2^k，即k-1 ≤ log2_T < k

#### 4.4 二叉排序树

又称二叉搜索树，需要满足以下条件：
- 若左子树不为空，则左子树上所有节点的值均小于根节点的值
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉排序树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example1.png)

对二叉排序树进行**中序遍历，可以得到有序数列**，而先序和后序的遍历结果都是无序的。

> 对于值相等的节点可以根据业务需要，灵活的规定放在左或右节点，但规则必须在该树内统一

**二叉排序树保持了元素的顺序，是一种综合效率较高的数据结构。查找、插入、删除的效率都是O(h)，h为树的高度，即树的高度决定了它的查找效率。最坏情况为O(N)（退化成链表），树平衡时为O(log2_T)，T为节点数。即当高度为log2_T（向上取整时）时，此二叉排序树是平衡的。**

#### 4.5 平衡二叉树

二叉树最差的情况是斜树（链表），此时查询时间复杂度为O(N)。即使没有退化为链表，如果二叉排序树高度不平衡，效率也会很低。平衡二叉树就是为了提高查询效率，每次比较都缩小约一半的范围，查询时间复杂度O(log2_N)，效率近似于二分法。

**首先平衡二叉树是一种二叉排序树**，其次要么是空树，要么满足：
- 1.左右子树高度差的绝对值不超过1
- 2.左右子树仍然为平衡二叉树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example5.png)

平衡二叉树的每个节点的平衡因子，只能是1、0、-1。绝对值超过1时，该二叉排序树就是严格不平衡的。

> 平衡因子：BF = 左子树深度 - 右子树深度

为了保证树的平衡，降低树深度，提高查询效率，需要一定的机制来实现树的平衡，如AVL、Treap（树堆）、红黑树等。

> 常见平衡二叉树：
- AVL：严格的平衡二叉树，通过旋转操作，恢复插入、删除后的平衡状态。满足平衡二叉树的所有定义
- 红黑树：非严格的平衡二叉树（左右子树高度差的绝对值可能超过1）。通过为节点增加颜色，来降低增删节点后的旋转次数（与AVL相比）

AVL适合增删次数较少的情况。虽然红黑树不是严格的平衡二叉树，但它仍是相对平衡的（平均高度依然是log2_T，最坏情况不会超过2log2_T），综合性能好，应用比AVL多。

> 平衡二叉树的应用
- AVL：在Windows NT内核中广泛使用
- 红黑树：Linux的进程调度、C++的STL、Java中的TreeMap、TreeSet、Java8中的HashMap等


---
# III.二叉排序树

BST（Binary Search Tree）。以二叉排序树（左< 父 ≤ 右）为例，叙述二叉树节点的查找、插入、删除和遍历等。

> 不论是查找、插入、删除或遍历等，大都需要从根节点开始遍历。

这里只记录实现思路，完整代码参考[study-datastructure](https://github.com/wocaishiliuke/study-datastructure)中的tree包。其中递归方式较简单，非递归方式需要使用循环（while）来代替递归操作。

## 1.查找节点

- 从root开始比较
    - 小于：继续查找左子树
    - 等于：查找结束
    - 大于：继续查找右子树

如果二叉树是比较平衡的，则每次比较都能将比较范围缩小一半（二分法），效率很高。（**其实是把时间成本放到了插入时的比较上**。

## 2.查找最值

即查找最左或最右节点

## 3.插入节点

- 从root开始比较
    - 1.如果此时root为空，作为root节点即可
    - 2.如果此时root不为空，和root比较
        + 小于：如果左孩子为空，作为root的左孩子即可；否则继续和左孩子比较...
        + 等于大于：如果右孩子为空，作为root的右孩子即可；否则继续和右孩子比较...

## 4.遍历节点

对于二叉排序树，中序遍历是有序的，先、后序遍历的结果是无序的。

> 中序：左-根-右，先序：根-左-右，后序：左-右-根

具体实现包括递归和非递归方式，参考源码。源码中还包括了层次遍历的实现

## 5.删除节点

#### 5.1 假删除

不改变原有树结构，通过设置节点属性达到删除效果。

#### 5.2 真删除

删除后需要保证仍是二叉排序树，即需要选择替补节点，分三种情况：
- 1.查找目标节点、目标节点的父节点，以及确定目标节点是父节点的左孩子还是右孩子（isLeftChild）
- 2.删除目标节点
    + 2.1 目标节点是叶子节点（不需要替补）
        * 断绝父子关系即可，剩余交由GC处理
    + 2.2 目标节点只有左或右孩子（左或右孩子直接替补）
        * 将目标节点的父节点原本指向目标节点的引用，改为指向该节点的子节点即可
    + 2.2 目标节点有两个子节点
        * a.先确定替补者、替补者的父节点。这里替补者使用目标节点的右子树的最小值（最左最深），**此时替补者肯定没有左孩子**
        * b.处理替补者被带走后的残局，即处理替补者替补前的上下代关系：如果有右孩子，移动到替补者的位置）
        * c.替补，即处理替补者替补后的上下代关系

> 上述2.2.a中，替补者也可以使用左子树的最大值（最右最深），则该替补者没有右孩子

**BST在插入或删除的时候会导致树倾斜**，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是斜树，高度为N。平衡树应运而生，常见的有AVL树和红黑树。AVL树实现比较复杂，而且插入和删除性能差，不如红黑树常用。


---
# IV.AVL树

这里着重讲述，AVL如何恢复插入、删除后的平衡。

## 1.最小不平衡子树

距离插入结点最近，且BF的绝对值大于1的结点为根的子树。（一般是从最接近插入点的BF=±2的节点开始）

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/min-no-balance-tree.png)

图中上面的整棵树都是最小不平衡树；下面的3-4-5是最小不平衡树

## 2.旋转操作

旋转（Rotate）是为了使BST重新达到平衡。分为left-rotate（左旋）、right-rotate（右旋）。

- 左旋：顺时针，待旋转的节点从左边上升到父节点
- 右旋：逆时针，待旋转的节点从右边上升到父节点

细分为：
- LL型平衡旋转法
- RR型平衡旋转法
- LR型平衡旋转法
- RL型平衡旋转法

旋转操作的流程：
- 计算节点的平衡因子BF，找到最小不平衡子树
- 如果最小不平衡子树中存在BF符号相反的情况，需要先做一次旋转
- 然后最小不平衡子树整体，根据BF的正负，进行旋转
    + BF正数：右转
    + BF负数：左旋。

## 3.旋转示例

依次插入{3, 2, 1, 4, 5, 6, 7, 10, 9, 8}。二叉排序树和平衡二叉树的对比：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rotate-compare.png)

下面就逐步分析，通过旋转操作达到上图右侧的平衡。

- 1.插入3, 2后，不用旋转。当插入1后：

整棵树都是最小不平衡树，节点3的BF为+2，所以将其左节点右旋（**RR型平衡旋转法**）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate1.png)

- 2.插入4后，不用旋转。当插入5后：

最小不平衡子树：3-4-5，将4左旋（**LL型平衡旋转法**）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate2.png)

- 3.插入6后：

最小不平衡子树：整棵树，将4左旋。4成为根节点。但其只能有两个子节点，所以将3挂到2下。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate3.png)

- 4.插入7后：

最小不平衡子树：5-6-7，将4左旋。4成为根节点。但其只能有两个子节点，所以将3挂到2下。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate4.png)

- 5.插入10后，不用旋转。当插入9后：

最小不平衡子树：7-10-9。如果只是简单的左旋10，由于7和9都小于10，不可能都做左子节点，不符合BST的规则。导致这一情形的原因：之前的几次旋转中，最小不平衡子树的根结点与它的子结点的BF符号相同。而此时节点7的BF是-2，节点10的BF是1，符号相反，所以先进行一次旋，将他们的BF符号统一，再进行平衡旋转。（**RL型平衡旋转法**。与之对应的先左旋，后右旋，成为LR型平衡旋转法）

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate5.png)

- 6.最后插入8：

最小不平衡子树：以6为根的子树。和上面相似，需要先旋转一次，将BF符号统一，再旋转完成平衡。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate6.png)


---
# V.红黑树

## 1.概述

RBTree（Red-Black Tree）

> 定义

首先是一棵BST树，其次：
- 1.任何一个节点都有颜色，黑色或者红色
- 2.根节点是黑色的
- 3.父子节点之间不能出现两个连续的红节点
- 4.任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等
- 5.空节点也被认为是黑色的

RBTree的查找操作就是BST的查找操作，区别在于增删操作。RBTree插入和删除操作需要维持树的平衡，保证树的高度在[logN,logN+1]。这样查找、删除、插入的时间复杂度都始终保持在O(logN)。

> 应用

Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等，Java中的TreeMap、TreeSet，C++ STL的map、multimap、multiset等。Java 8中的HashMap也使用了RBTree取代链表，性能有所提升。

> 和平衡二叉树的区别

**红黑树属于平衡二叉树，但它不严格控制左、右子树高度差≤1**。不过，红黑树的平均高度依然是log2_T，且最坏情况不会超过2log2_T。

为节点增加颜色，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高

> 插入、删除后的恢复

在红黑树上进行插入、删除操作，可能会导致不再符合红黑树的性质。恢复红黑树属性，需要少量的颜色变更（很快）和不超过3次的旋转（插入操作是2次）。任何不平衡都会在3次旋转之内解决，这一点是AVL树所不具备的。

## 2.

旋转（Rotate）是为了使节点颜色符合定义，让RBTree重新达到平衡。分为left-rotate（左旋）、right-rotate（右旋）。


## 3.查找节点

参考上述BST的查找。

## 4.插入节点

RBTree与BST的插入操作相同，只不过在插入后，可能会导致树不平衡。此时就需要对树进行旋转和颜色修复，使其重新符合RBTree的定义。

新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。即只有在父节点为红色节点时，才需要插入修复操作（父子节点不能同时为红节点）。

当新插入节点的父节点为红色时，需要进行插入修复操作。此时又分为三种情况：
- case1：叔叔节点也为红色
- case2：叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上
- case3：叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上

#### 插入修复case1

即父节点、叔叔节点都为红色时。此时将父节点、叔叔节点与祖父节点的颜色互换。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case1.png)

如果图中节点7的父节点不是黑色的话，则继续做修复操作。

#### 插入操作case2

即没有叔叔节点，且祖父节点、父节点、新节点处于一条斜线上。此时将父节点右旋，并和祖父节点互换颜色。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case2.png)

case2就是通过【左/右旋+颜色互换】来完成。

#### 插入操作case3

即没有叔叔节点，且祖父节点、父节点、新节点不处于一条斜线上。此时将新节点左旋，这样就转化成了case2，然后进行商户case2操作即可。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case3.png)

#### 插入操作总结

插入后的修复操作，是向root节点回溯的过程，一旦牵涉到的节点都符合了红黑树的定义，则修复操作结束。

之所以会向上回溯，是由于case1操作会将父节点、叔叔节点和祖父节点调换颜色，有可能会导致祖父节点不平衡。此时就需要以祖父节点为起点，继续向上回溯，直到root节点。由于root节点永远是黑色的，所以最后可能会用到case3中的调节。

上述3种情况中，如果对应的操作是在右子树上，做对应的镜像旋转操作即可。

---
# V.参考

- [文章中的源码实现](https://github.com/wocaishiliuke/study-datastructure)
- [红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)