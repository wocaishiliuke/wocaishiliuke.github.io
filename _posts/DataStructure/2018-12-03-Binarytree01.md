---
title: 二叉树
date: 2018-12-03 19:01:09
categories:
    - DataStructure
tags:
    - DataStructure
    - BinaryTree
---

本文将介绍二叉树的基本原理。

<!-- more -->

##### 目录
+ I.树
+ II.二叉树
+ III.二叉排序树
+ IV.AVL树
+ V.2-3树
+ VI.红黑树
+ VII.参考


---

# I.树

## 1.树的简介

**树**（tree）是一种非线性抽象数据模型，用来模拟树状结构的数据集合。二叉树是其中一种常用的数据结构（如二叉排序树、Huffman编码等），其他的还有红黑树、B树等

> 文件系统和数据库系统一般都采用树（特别是B树）结构，主要考虑到排序和查询效率。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/tree-example.png)

常见术语：
- 根节点、父节点、（左右）子节点、兄弟节点、堂兄弟节点、层、深度、高度
- 节点的度：节点的子树个数
- 树的度：该树中最大的节点的度
- 叶子节点：度为0的节点
- 分支节点：度不为0的节点
- 节点的层：根节点为第1层，以此类推
- 深度：从根到该节点的唯一路径长，根的深度为0
- 高度：从该节点到某叶子节点的最长路径，所有叶子节点的高度为0

> Java中，节点一般代表对象实例，边代表引用（成员变量）

## 2.树的效率

树、数组、链表的比较

- **数组**：查找快，但增删慢，需要平均移动N/2次后面的数据
- **链表**：增删很快，只需要改变一些引用值，但查找慢，需要从第一个数据遍历，平均比较N/2次
- **树**：同时具备数组查找快、链表增删快的优点

二叉树为例：
- 查询时间复杂度：例如某节点在第x层，查找时间为t，则约t/2的时间消耗在第x层，约t/4消耗在第(x-1)层...
- 查询操作复杂度：例如1024个数据的链表或无序数组，查询需要平均比较512次，而二叉树平均只需要比较10次
- 删除复杂度：例如1024个数据的数组，查找节点很快，但增删需要平均移动512次；而二叉树查找需要约10次比较，然后很少的时间来处理断点替换和上下代关系建立

树的效率取决于该节点所在层数。以二叉树为例：
- 每层最多2^(i-1)个节点
- K层树最多T=2^K-1个节点
- 增删查的时间复杂度都是为O(log2_T)（增删时维护上下代关系的时间很短）。


---
# II.二叉树

每个节点都有0-2个子节点的树。分为左右子树，每个子树也是二叉树（二叉树有递归含义）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example.png)

## 1.二叉树的存储结构

二叉树是一种非线性数据结构。每个节点最多一个前驱，可以有多个后继。一般采用数组、链表存储结构来实现。

#### 1.1 数组结构

按层次遍历，从左到右依次存储树的每一层。根节点在arr[0]，arr[1]是根的左子节点，以此类推。

树的每个位置无论是否存在节点，都对应数组中的一个位置。即数组长度为2^K-1（K为树高度），没有的节点在数组中用0或者null表示

> 索引为index的元素对应的节点，其左子节点是2×index+1，右子节点是2×index+2，父节点是(index-1)/2。

一般情况，使用数组表示树，效率较低。不满的节点和删除掉的节点都会在数组中留下洞，浪费空间。更糟糕的情况是，删除节点如果需要移动子树时，子树中的每个节点都要移到数组中的新位置，非常费时。如果不允许真删除时，数组表示可能会有用。

#### 1.2 链表结构

用非连续存储的链表表示：
- 二叉链表：每个节点包含三个域：数据域、左、右指针域
- 三叉链表：比二叉链表多一个域：父指针域

使用三叉链表，节点可以直接访问到父节点，但也增加了空间开销。一般使用二叉链表。

## 2.二叉树的特性

所有二叉树的通用特性：
- 1.非空二叉树的第i层（i≥1），最多有2^(i-1)个节点（等比数列）
- 2.深度为K的非空二叉树（k>=1)，最多有2^k-1个节点（等比数列之和）
- 3.如果非空二叉树的叶子节点个数为n0，度数为2的节点个数为n2，则n0=n2+1

> 设叶子节点个数为n0，度数为1的节点个数为n1，度数为2的节点个数为n2，则节点总数T=n0+n1+n2，那么连线（边）的个数为：T-1=n0+n1+n2-1=2×n2+n1，所以n0=n2+1

## 3.二叉树的遍历

- 深度优先遍历
    + 先序遍历（Pre-Order Traversal）
    + 中序遍历（In-Order Traversal）
    + 后序遍历（Post-Order Traversal）
- 广度优先遍历（层次遍历）

## 4.二叉树的分类

根据不同的特点，常见的二叉树可分为如下几种。稍后重点介绍最常用的二叉排序树

#### 4.1 斜树

所有节点都只有左子树（左斜树）或右子树（右斜树）。不需要像排序树一样比较大小排位

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example2.png)

> 这种树高度高，退化成了链表，应用较少

#### 4.2 满二叉树

所有分支节点都有左子树和右子树，并且所有叶子节点都在最后一层。不需要向排序树一样比较大小排位
- 叶子都在最下一层
- 非叶子节点的度一定是2
- 同深度的二叉树中，满二叉树的节点个数最多，叶子树（节点）最多

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example3.png)

#### 4.3 完全二叉树

对有n个节点的二叉树，按层序编号（从上向下，从左向右），如果编号为i的节点（i从1-n），与同深度的满二叉树编号为i的节点位置相同，就是完全二叉树。不需要向排序树一样比较大小。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example4.png)

- 叶子节点都在最后一层或倒数第二层（满二叉树都在最后一层）
- 最下层的叶子节点一定集中在左部连续位置
- 倒数第二层，如有叶子节点，一定出现在右部连续位置。
- 相同节点数的二叉树，完全二叉树（或满二叉树）的高度最小

> 如果完全二叉树最后一层恰好排满就是满二叉树。即满二叉树是完全二叉树，反之不一定。

除上述二叉树通用特性外，完全二叉树还有下述特点：
- 1.深度为k的完全二叉树节点数为T：2^(k-1)-1 < T ≤ 2^k-1
- 2.节点总数为T的完全二叉树，深度为：[log2_T]+1
- 3.对完全二叉树的n个节点按层次序编号，对任一层编号为i的节点（1<=i<=n）有
    - 3.1 如果i=1，则节点i是二叉树的根。如果i>1，则其父节点编号为[i/2]（向下取整）
    - 3.2 如果2i>n，则节点i是叶子节点；如果2i=n，则其左孩子为2i，没有右孩子；如果2i< n，则其左孩子为2i，右孩子为2i+1

> 2由1推算而来（T是正整数）：2^(k-1) ≤ T ≤ 2^k-1 < 2^k，即k-1 ≤ log2_T < k

#### 4.4 二叉排序树

又称二叉搜索树，需要满足以下条件：
- 若左子树不为空，则左子树上所有节点的值均小于根节点的值
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉排序树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example1.png)

对二叉排序树进行**中序遍历，可以得到有序数列**，而先序和后序的遍历结果都是无序的。

> 对于值相等的节点可以根据业务需要，灵活的规定放在左或右节点，但规则必须在该树内统一

**二叉排序树保持了元素的顺序，是一种综合效率较高的数据结构。查找、插入、删除的效率都是O(h)，h为树的高度，即树的高度决定了它的查找效率。最坏情况为O(N)（退化成链表），树平衡时为O(log2_T)，T为节点数。即当高度为log2_T（向上取整时）时，此二叉排序树是平衡的。**

#### 4.5 平衡二叉树

二叉树最差的情况是斜树（链表），此时查询时间复杂度为O(N)。即使没有退化为链表，如果二叉排序树高度不平衡，效率也会很低。平衡二叉树就是为了提高查询效率，每次比较都缩小约一半的范围，查询时间复杂度O(log2_N)，效率近似于二分法。

**首先平衡二叉树是一种二叉排序树**，其次要么是空树，要么满足：
- 1.左右子树高度差的绝对值不超过1
- 2.左右子树仍然为平衡二叉树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bintree-example5.png)

平衡二叉树的每个节点的平衡因子，只能是1、0、-1。绝对值超过1时，该二叉排序树就是严格不平衡的。

> 平衡因子：BF = 左子树深度 - 右子树深度

为了保证树的平衡，降低树深度，提高查询效率，需要一定的机制来实现树的平衡，如AVL、Treap（树堆）、红黑树等。

##### 4.5.1 AVL和红黑树
- AVL：严格的平衡二叉树，通过旋转操作，恢复插入、删除后的平衡状态。满足平衡二叉树的所有定义
- 红黑树：非严格的平衡二叉树（左右子树高度差的绝对值可能超过1）。通过为节点增加颜色，来降低增删节点后的旋转次数（与AVL相比）

下面是同一组数据（arr=[7,10,15,4,6,8,5]）的不同二叉排序树的插入结果对比：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/bst-avl-rbtree.png)

AVL适合增删次数较少的情况。虽然红黑树不是严格的平衡二叉树，但它仍是相对平衡的（平均高度依然是log2_T，最坏情况不会超过2log2_T），综合性能好，应用比AVL多。

##### 4.5.2 平衡二叉树的应用
- AVL：在Windows NT内核中广泛使用
- 红黑树：Linux的进程调度、C++的STL、Java中的TreeMap、TreeSet、Java8中的HashMap等


---
# III.二叉排序树

BST（Binary Search Tree）。以二叉排序树（左< 父 ≤ 右）为例，叙述二叉树节点的查找、插入、删除和遍历等。

> 不论是查找、插入、删除或遍历等，大都需要从根节点开始遍历。

这里只记录实现思路，完整代码参考[study-datastructure](https://github.com/wocaishiliuke/study-datastructure)中的tree包。其中递归方式较简单，非递归方式需要使用循环（while）来代替递归操作。

## 1.查找节点

- 从root开始比较
    - 小于：继续查找左子树
    - 等于：查找结束
    - 大于：继续查找右子树

如果二叉树是比较平衡的，则每次比较都能将比较范围缩小一半（二分法），效率很高。（**其实是把时间成本放到了插入时的比较上**。

## 2.查找最值

即查找最左或最右节点

## 3.插入节点

- 从root开始比较
    - 1.如果此时root为空，作为root节点即可
    - 2.如果此时root不为空，和root比较
        + 小于：如果左孩子为空，作为root的左孩子即可；否则继续和左孩子比较...
        + 等于大于：如果右孩子为空，作为root的右孩子即可；否则继续和右孩子比较...

## 4.遍历节点

对于二叉排序树，中序遍历是有序的，先、后序遍历的结果是无序的。

> 中序：左-根-右，先序：根-左-右，后序：左-右-根

具体实现包括递归和非递归方式，参考源码。源码中还包括了层次遍历的实现

## 5.删除节点

#### 5.1 假删除

不改变原有树结构，通过设置节点属性达到删除效果。

#### 5.2 真删除

删除后需要保证仍是二叉排序树，即需要选择替补节点，分三种情况：
- 1.查找目标节点、目标节点的父节点，以及确定目标节点是父节点的左孩子还是右孩子（isLeftChild）
- 2.删除目标节点
    + 2.1 目标节点是叶子节点（不需要替补）
        * 断绝父子关系即可，剩余交由GC处理
    + 2.2 目标节点只有左或右孩子（左或右孩子直接替补）
        * 将目标节点的父节点原本指向目标节点的引用，改为指向该节点的子节点即可
    + 2.2 目标节点有两个子节点
        * a.先确定替补者、替补者的父节点。这里替补者使用目标节点的右子树的最小值（最左最深），**此时替补者肯定没有左孩子**
        * b.处理替补者被带走后的残局，即处理替补者替补前的上下代关系：如果有右孩子，移动到替补者的位置）
        * c.替补，即处理替补者替补后的上下代关系

> 上述2.2.a中，替补者也可以使用左子树的最大值（最右最深），则该替补者没有右孩子

**BST在插入或删除的时候会导致树倾斜**，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是斜树，高度为N。平衡树应运而生，常见的有AVL树和红黑树。AVL树实现比较复杂，而且插入和删除性能差（旋转较多），不如红黑树常用。


---
# IV.AVL树

这里着重讲述，AVL如何恢复插入、删除后的平衡。

## 1.最小不平衡子树

距离插入结点最近，且BF的绝对值大于1的结点为根的子树。（一般是从最接近插入点的BF=±2的节点开始）

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/min-no-balance-tree.png)

图中上面的整棵树都是最小不平衡树；下面的3-4-5是最小不平衡树

## 2.旋转操作

旋转（Rotate）是为了使BST重新达到平衡。分为left-rotate（左旋）、right-rotate（右旋）。

- 左旋：顺时针，待旋转的节点从左边上升到父节点
- 右旋：逆时针，待旋转的节点从右边上升到父节点

细分为：
- LL型平衡旋转法
- RR型平衡旋转法
- LR型平衡旋转法
- RL型平衡旋转法

**旋转操作的流程**：
- 计算节点的平衡因子BF，找到最小不平衡子树
- 如果最小不平衡子树中存在BF符号相反的情况，需要先做一次旋转
- 然后最小不平衡子树整体，根据BF的正负，进行旋转
    + BF正数：右转
    + BF负数：左旋。

## 3.旋转示例

依次插入{3, 2, 1, 4, 5, 6, 7, 10, 9, 8}。二叉排序树和AVL树的对比：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rotate-compare.png)

下面就逐步分析，通过旋转操作达到上图右侧的平衡。

- 1.插入3, 2后，不用旋转。当插入1后：

整棵树都是最小不平衡树，节点3的BF为+2，所以将其左节点右旋（**RR型平衡旋转法**）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate1.png)

- 2.插入4后，不用旋转。当插入5后：

最小不平衡子树：3-4-5，将4左旋（**LL型平衡旋转法**）。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate2.png)

- 3.插入6后：

最小不平衡子树：整棵树，将4左旋。4成为根节点。但其只能有两个子节点，所以将3挂到2下。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate3.png)

- 4.插入7后：

最小不平衡子树：5-6-7，将4左旋。4成为根节点。但其只能有两个子节点，所以将3挂到2下。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate4.png)

- 5.插入10后，不用旋转。当插入9后：

最小不平衡子树：7-10-9。如果只是简单的左旋10，由于7和9都小于10，不可能都做左子节点，不符合BST的规则。导致这一情形的原因：之前的几次旋转中，最小不平衡子树的根结点与它的子结点的BF符号相同。而此时节点7的BF是-2，节点10的BF是1，符号相反，所以先进行一次旋，将他们的BF符号统一，再进行平衡旋转。（**RL型平衡旋转法**。与之对应的先左旋，后右旋，成为LR型平衡旋转法）

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate5.png)

- 6.最后插入8：

最小不平衡子树：以6为根的子树。和上面相似，需要先旋转一次，将BF符号统一，再旋转完成平衡。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-rotate6.png)


---
# V.2-3树

讲述2-3-4树，是为了方便红黑树的理解，了解红黑树产生的原因。

为了解决二叉查找树的不平衡，2-3树孕育而生，2-3树能够很好的实现树的平衡

## 1.节点类型

- 2节点：存1个值，最多2个子节点
- 3节点：存2个值，最多3个子节点
- 临时4节点：存3个值，最多4个子节点，会转化成子树

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/2-3tree_node.png)

> 为了方便区分，本文中的2节点使用○表示，3节点使用□表示

## 2.查找节点

和BST的思想一样，迭代比较。

## 3.插入

原则：
- 2-3树在插入过程中，始终保持平衡
- 临时4节点会分裂，**（中子）会向上增长**
    + 父节点为null时，4节点转化为3个2节点
    + 父节点为2节点时，临时4节点的中子转化为父节点的值，父节点转化为3节点
    + 父节点为3节点时，临时4节点的中子转化为父节点的值，父节点转化为临时4节点，中子接着上移

这里以依次插入[1,2,3...,9,10]为例。

- 插入1，2，3

3节点变为临时4节点后，会分裂，中值变为左右值的父。**即父节点为null时，4节点转化为3个2节点**

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/2-3tree1.png)

- 插入4，5

**父节点为2节点时，临时4节点的中子转化为父节点的值，父节点转化为3节点**

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/2-3tree2.png)

- 插入6，7

父节点为3节点时，临时4节点的中子转化为父节点的值，父节点转化为临时4节点。而爷爷节点为null，4节点就向上转化为3个2节点。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/2-3tree3.png)

## 4.和红黑树的类比

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/2-3tree_rbtree.png)

---
# VI.红黑树

## 1.概述

RBTree（Red-Black Tree）

#### 1.1 定义

首先是一棵BST树，其次：
- 1.任何一个节点都是黑色或者红色（2-3树节点都是2节点、3节点）
- 2.根节点是黑色的
- 3.父子节点之间不能出现两个连续的红节点（2-3树不能有4节点（临时的））
- 4.任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等
- 5.空节点也被认为是黑色的

RBTree能够确保，任何一个节点的左右子树的高度差，不会超过二者中较低的那个的一倍。

RBTree的查找操作就是BST的查找操作，区别在于增删操作。RBTree插入和删除操作需要维持树的平衡，保证树的高度在[logN,logN+1]。这样查找、删除、插入的时间复杂度都始终保持在O(logN)。

#### 1.2 红黑树和AVL树

**红黑树属于平衡二叉树，但它不严格控制左、右子树高度差≤1**。不过，红黑树的平均高度依然是log2_T，且最坏情况不会超过2log2_T。

红黑树通过为节点增加颜色，用非严格的平衡来换取增删时旋转次数的降低。而AVL是严格平衡树，在增删节点时，旋转次数可能会比红黑树要多。所以红黑树的增删效率更高（综合效率）。

- 首先，AVL相较RB-Tree更平衡，那么在增删node时也更容易引起unbalance。所以在频繁增删的场景中，AVL需要更频繁的rebalance，此时RB-Tree效率更高
- 其次，对比以下两者的增删操作：
    + 插入一个node引起的不平衡，AVL和RB-Tree都最多只需要2次旋转操作，即都是O(1)
    + 删除一个node引起的不平衡：
        * AVL在最坏情况下，需要维护从被删除node到root上的所有node的平衡性，旋转量级O(logN)
        * RB-Tree最多只需3次旋转，O(1)的复杂度
- 再次，由于AVL高度平衡，因此AVL的search效率稍高，但也相差无几（可能会多比较一次）
- 综上，RB-Tree的综合效率更高。

- 如果有一些增删操作，使用RB-Tree
- 如果增删操作很少，可以使用AVL
- 如果是静态数据，没有增删操作，可以使用哈希表

#### 1.3 应用

Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等，Java中的TreeMap、TreeSet，C++ STL的map、multimap、multiset等。Java 8中的HashMap也使用了RBTree取代链表，性能有所提升。

#### 1.4 恢复操作

在红黑树上进行插入、删除操作，可能会导致不再符合红黑树的性质。恢复操作包括两类：
- 颜色调整
- 旋转。

**红黑树往往只需要少量的颜色变更（很快）和不超过3次的旋转（插入操作是2次）。任何不平衡都会在3次旋转之内解决，这一点是AVL树所不具备的**。

## 2.旋转和颜色变更

旋转（Rotate）是为了使节点颜色符合定义，让RBTree重新达到平衡。也分为left-rotate（左旋）、right-rotate（右旋），对应2-3树中的临时4节点的分裂。

颜色变更是为了，让该树重新符合红黑树定义，降低旋转次数。

## 3.查找节点

参考上述BST的查找。

## 4.插入节点

RBTree与BST的插入操作相同，只不过在插入后，可能会导致树不平衡。此时就需要对树进行旋转和颜色修复，使其重新符合RBTree的定义。

**新插入的节点是红色，所以只有在父节点为红色节点时，才需要插入修复操作（父子节点不能同时为红节点）。修复操作直到遇到父节点为黑色时结束**。

> 设定插入节点是红色的，是为了避免违背定义中的第4条，减少调整步骤。

- 当插入的节点是根节点时，直接涂黑
- 当插入的节点的父节点是黑色时，无需修复，不会破坏（颜色）平衡
- 当插入的节点的父节点是红色时，需要修复。此时又分为三种情况：
    - case1：叔叔节点也为红色
    - case2：叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上
    - case3：叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上

> 这里叔叔节点为空，即黑色的null节点。网上别处都说成黑色的叔叔节点，实际应该（暂不确定TODO）不会出现【父节点红色，叔叔节点黑色，父节点还能插入】的情况，因为此时从root到null节点的黑色节点数会不同。他们说的应该是fixup过程中的情况，而非插入后立即出现的情况（见插入示例）。

#### 插入修复case1

**当红父红叔时。此时将父节点、叔叔节点与祖父节点的颜色互换**。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case1.png)

这就是使用颜色修复避免了旋转操作（如果是AVL，就需要旋转）。如果图中节点7的父节点不是黑色，则继续向上修复。

> 此时，无论父节点在祖父节点的左边还是右边，无论新节点是父节点的左孩子还是右孩子，修复操作都一样（即此时包括了具体4种情形，都只需调整颜色，不需要旋转）

case1只需要【颜色互换】就可完成。

#### 插入操作case2

**当没有叔叔节点，且祖父节点、父节点、新节点处于一条斜线上时。将父节点右旋，并和祖父节点互换颜色**。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case2.png)

> 如果直接将9涂成黑色，会增加黑节点个数和树高，不平衡，影响查询效率。

case2通过【左/右旋+颜色互换】来完成。如果9和8都是右子节点，对应使用左转即可。

#### 插入操作case3

**当没有叔叔节点，且祖父节点、父节点、新节点不处于一条斜线上时。先将他们调整到一条直线上，即将新节点左旋，就转化成case2，然后进行case2的操作**。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/rbtree-case3.png)

case3通过【2次旋转+颜色互换】来完成。如果9和8是镜像位置，对应先右转再左转即可。

#### 插入示例

准备红黑树：按[11,2,14,15,1,7,5,8]插入生成一个红黑树（图1），然后插入4，演示上述case的fixup

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/DataStructure/brtree-insert-example.png)

#### 插入操作总结

插入后的修复操作，是向root节点回溯的过程，一旦牵涉到的节点都符合了红黑树的定义，则修复操作结束。

之所以会向上回溯，是由于case1操作会将父节点、叔叔节点和祖父节点调换颜色，有可能会导致祖父节点不平衡。此时就需要以祖父节点为起点，继续向上回溯，直到root节点。

上述3种情况中，如果对应的操作是在右子树上，做对应的镜像旋转操作即可。

## 5.删除节点

- 先做和BST一样的删除：
    - 如果是叶子节点，直接删除
    - 如果是非叶子节点，使用对应的中序遍历的后继节点来顶替要删除的节点
- 然后，做删除后的修复操作，使其仍然符合红黑树的定义。

删除后的修复操作，在遇到被删除节点是红色节点或者到达root节点时，则修复操作完毕。

**删除修复操作是针对删除黑色节点才有的**。当黑色节点被删除后，会让整颗树不符合RBTree定义的第4条。需要从兄弟节点上借调黑色节点，如果兄弟节点没有黑节点，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。

> 删除修复的思想是：从兄弟节点借调黑色节点，如果达到了局部平衡，就看整颗树是否平衡，如果不平衡就接着向上追溯调整。

删除修复操作分为4种情况（删除黑节点后）：
- case1：待删除节点的兄弟节点是红节点
- case2：待删除节点的兄弟节点是黑节点，且兄弟节点的子节点都是黑色的
- case3：待删除节点的兄弟节点是黑节点，且兄弟节点的子节点不都是黑色的，且
    + 如果兄弟节点在右边，兄弟节点的左子节点是红色的，右子节点是黑色的
    + 如果兄弟节点在左边，兄弟节点的右子节点是红色的，左子节点是黑色的
- case4：待删除节点的兄弟节点是黑节点，且兄弟节点的子节点不都是黑色的，且
    + 如果兄弟节点在右边，右子节点是红色的
    + 如果兄弟节点在左边，则就是对应的就是左节点是红色的。

#### 5.1 删除修复case1

由于兄弟节点是红色节点，无法借调黑节点，所以需要将兄弟节点提升到父节点。由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点一定是黑色的，就可以从它的子节点借调了。

case 1这样转换之后就会变成后面的case2、case3、case4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。

之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。
















---
# VII.参考

- [文章中的源码实现](https://github.com/wocaishiliuke/study-datastructure)
- [红黑树深入剖析及Java实现](https://tech.meituan.com/2016/12/02/redblack-tree.html)
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)