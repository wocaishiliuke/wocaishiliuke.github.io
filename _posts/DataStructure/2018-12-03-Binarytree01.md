---
title: Binary Tree
date: 2018-12-03 19:01:09
categories:
    - DataStructure
tags:
    - DataStructure
    - BinaryTree
---

本文将介绍二叉树的基本原理。

<!-- more -->

##### 目录
+ I.简介
+ II.二叉排序树
+ III.哈夫曼(Huffman)编码


---

# I.简介

## 1.概念

#### 1.1 树

**树**（tree）是一种非线性抽象数据模型，用来模拟树状结构的数据集合。二叉树是其中一种常用的数据结构（如二叉排序树、Huffman编码等），其他的还有红黑树、2-3-4树等

> **数组**查找快，但增删慢，需要平均移动N/2次后面的数据。**链表**增删很快，只需要改变一些引用值，但查找慢，需要从第一个数据遍历，平均比较N/2次。**树**结构同时具备了数组查找快、链表增删快的优点。

树的效率：查找时间取决于该节点所在层数。每一层最多2^(i-1)个节点，K层树共有T=2^K-1个节点，（增删查的）时间复杂度都为O(log2_T)。增删时维护上下代关系的时间很短

> - 查询时间复杂度：例如某节点在第x层，查找时间为t，则接近t/2的时间消耗在第x层，有接近t/4时间消耗在第(x-1)层...
> - 查询操作复杂度：例如1024个数据的链表或无序数组，查询需要平均比较512次，而二叉树中平均只需要10次
> - 删除复杂度：例如1024个数据的数组，查找节点很快，但增删需要平均移动512次；而二叉树查找需要约10次比较，然后很少的时间来处理断点替换和上下代关系建立

#### 1.2 二叉树

**二叉树**的每个节点都有0-2个子节点，分为左右子树，每个子树也是二叉树，所以二叉树有递归含义

- 术语：根节点、父节点、（左右）子节点、兄弟节点、叶子节点、边、（左右）子树、层、深度、高度

> Java中，节点一般代表对象实例，边代表引用（成员变量）

#### 1.3 二叉树表示

###### 1.数组表示

节点在数组中的位置对应于它在树中的位置。下标为0的节点是根下标为1的节点是根的左子节点，以此类推，按照从左到右的顺序存储树的每一层（层次遍历）

> 无论是否存在节点，都对应数组中的一个位置，树中没有节点的在数组中用0或者null表示

索引为index的元素对应的节点，其左子节点是2*index+1，右子节点是2*index+2，父节点是（index-1）/2。

> 一般情况，使用数组表示树的效率很低，不满的节点和删除掉的节点都会在数组中留下洞，浪费存储空间。更糟糕的情况是，删除节点如果需要移动子树的话，子树中的每个节点都要移到数组中新的位置，非常费时。如果不允许删除操作，数组表示可能会有用。

#### 1.4 二叉树通用特性

- 1.非空二叉树的i层（i≥1），最多有2^(i-1)个节点（等比数列）
- 2.深度为K的非空二叉树（k>=1)，最多有2^k-1个结点（等比数列之和）
- 3.如果非空二叉树的叶子节点个数为n0，度数为2的节点个数为n2，则n0=n2+1

> 如果叶子节点个数为n0，度数为1的节点个数为n1，度数为2的节点个数为n2，节点总数T=n0+n1+n2。那么连线（边）的个数为：T-1=n0+n1+n2-1=2×n2+n1，所以n0=n2+1

#### 1.5 完全二叉树特性

> 完全二叉树定义见下述，这里先叙述其特性

除上述二叉树通用特性外，完全二叉树还有下述特点：

- 1.深度为k的完全二叉树节点数为T：2^(k-1)-1 < T ≤ 2^k-1
- 2.节点总数为T的完全二叉树，深度为：[log_2T]+1

> 由1可得（T是正整数）：2^(k-1) ≤ T ≤ 2^k-1 < 2^k，即k-1 ≤ log_2T < k

- 3.对完全二叉树的n个节点按层次序编号，对任一层编号为i的节点（1<=i<=n）有
    - 3.1 如果i=1，则节点i是二叉树的根。如果i>1，则其父节点编号为[i/2]，向下取整
    - 3.2 如果2i>n，则节点i是叶子节点；如果2i=n，则其左孩子为2i，没有右孩子；如果2i<\n，则其左孩子为2i，右孩子为2i+1

## 2.分类

根据不同的特点，常见的二叉树可分为：

#### 2.1 二叉排序树

又称二叉搜索树，需要满足以下条件：

- 若左子树不为空，则左子树上所有节点的值均小于根节点的值
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉排序树

> - 对于值相等的节点可以根据业务需要，灵活的规定放在左或右节点，但规则必须在该树内统一
> - **对二叉排序树进行中序遍历，可以得到有序数列**，而先序和后序遍历的结果都是无序的

#### 2.2 斜树

所有节点都只有左子树（左斜树）或右子树（右斜树）。不需要向排序树一样比较大小排位

> 这种树的深度高，相当于链表，应用较少

#### 2.3 满二叉树

所有分支节点都有左子树和右子树，并且所有叶子节点都在最后一层。不需要向排序树一样比较大小排位

- 叶子都在最下一层
- 非叶子节点的度一定是2
- 同深度的二叉树中，满二叉树的节点个数最多，叶子树（节点）最多

#### 2.4 完全二叉树

对一棵具有n个节点的二叉树按层序编号（从上向下，从左向右），如果编号为i的节点与同深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树

> - 完全二叉树就是从上向下，从左向右依次排，如果最后一层恰好排满（即倒数第二层没有叶子节点）就是满二叉树。不需要向排序树一样比较大小
> - 满二叉树是完全二叉树，反之不一定

- 叶子节点都在最后一层或倒数第二层（满二叉树都在最后一层）
- 最下层的叶子节点一定集中在左部连续位置
- 倒数第二层，如有叶子节点，一定出现在右部连续位置。
- 相同节点数的二叉树，完全二叉树（或满二叉树）的深度最小

#### 2.5 平衡二叉树

即AVL树。是一种二叉排序树，要么是空树，要么满足：

- 1.左右子树深度之差的绝对值不超过1
- 2.左右子树仍然为平衡二叉树

> 平衡二叉树采用二分法思想，把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：




---

# II.二叉排序树

这里以二叉排序树为例（左< 父 ≤ 右），叙述二叉树节点的查找、插入、删除和遍历等。

> 不论是查找、插入、删除或遍历等，大都需要从根节点开始遍历

这里只记录实现思路，完整代码参考[study-datastructure-package tree](https://github.com/wocaishiliuke/study-datastructure)。其中递归方式较简单，非递归方式需要使用循环（while）来模拟递归操作

## 1.查找节点

- 从root开始比较
    - 小于：继续查找左子树
    - 等于：查找结束
    - 大于：继续查找右子树


## 2.查找最值

即查找最左或最右节点

## 3.插入节点

- 从root开始比较
    - 1.如果此时root为空，作为root节点即可
    - 2.如果此时root不为空，和root比较
        + 小于：如果左孩子为空，作为root的左孩子即可；否则继续和左孩子比较...
        + 等于大于：如果右孩子为空，作为root的右孩子即可；否则继续和右孩子比较...

## 4.遍历节点

对于二叉排序树，中序遍历是有序的，先、后序遍历的结果是无序的

> 中序：左-根-右，先序：根-左-右，后序：左-右-根

具体实现包括递归和非递归方式，参考源码

> 源码中还包括了层次遍历的实现

## 5.删除节点

#### 5.1 方式一、假删除

不改变原有树结构，通过设置节点属性达到删除效果

#### 5.2 方式二、真删除

保证删除后，仍是二叉排序树

> 为了保证仍是二叉排序树，需要考虑删除后，替补节点的选取，分三种情况

- 1.查找目标节点、目标节点的父节点，以及确定目标节点是父节点的左孩子还是右孩子（isLeftChild）
- 2.删除目标节点
    + 2.1 目标节点是叶子节点（不需要替补）
        * 断绝父子关系即可，剩余交由GC处理
    + 2.2 目标节点只有左或右孩子（左或右孩子直接替补）
        * 将目标节点的父节点原本指向目标节点的引用，改为指向该节点的子节点即可
    + 2.2 目标节点有两个子节点
        * a.先确定替补者、替补者的父节点。这里替补者使用目标节点的右子树的最小值（最左最深）（**则替补者肯定没有左孩子**）
        * b.处理替补者被带走后的残局，即处理替补者替补前的上下代关系：如果有右孩子，移动到替补者的位置）
        * c.替补，即处理替补者替补后的上下代关系

> 上述2.2.a中，替补者也可以使用左子树的最大值（最右最深），则该替补者没有右孩子


---

# III.哈夫曼(Huffman)编码