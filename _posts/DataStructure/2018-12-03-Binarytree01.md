---
title: Binary Tree
date: 2018-12-03 19:01:09
categories:
    - DataStructure
tags:
    - DataStructure
    - BinaryTree
---

本文将介绍二叉树的基本原理。

<!-- more -->

##### 目录
+ I.简介
+ II.二叉排序树


---

# I.简介

## 1.概念

#### 1.1 树

**树**（tree）是一种非线性抽象数据模型，用来模拟树状结构的数据集合。二叉树是其中一种数据结构，其他的还有红黑树、2-3-4树等

> **数组**查找快，但插入或删除慢，需要平均移动N/2次后面的数据。**链表**插入和删除很快，只需要改变一些引用值，但查找慢，需要第一个数据遍历，平均比较N/2次。**树**结构同时具备了数据查找快、链表增删快的优点。

#### 1.2 二叉树

**二叉树**的每个节点有0-2个子节点，分为左右子树，每个子树也是一个二叉树，所以二叉树有递归含义。

- 术语：根节点、父节点、（左右）子节点、兄弟节点、叶子节点、边、（左右）子树、层、深度、高度

> Java中，节点一般代表对象实例，边代表引用

#### 1.3 二叉树通用特性

- 1.非空二叉树的i层（i≥1），最多有2^(i-1)个节点（等比数列）
- 2.深度为K的非空二叉树（k>=1)，最多有2^k-1个结点（等比数列之和）
- 3.如果非空二叉树的叶子节点个数为n0，度数为2的节点个数为n2，则n0=n2+1

> - 叶子节点个数为n0，度数为1的节点个数为n1，度数为2的节点个数为n2，节点总数T=n0+n1+n2
> - 连线（边）的个数为：T-1=n0+n1+n2-1=2×n2+n1，所以n0=n2+1

#### 1.4 完全二叉树通用特性

完全二叉树定义见下述，这里先叙述其特性

- 1.深度为k的完全二叉树节点数为T：2^(k-1)-1 < T ≤ 2^k-1
- 2.节点总数为T的完全二叉树，深度为：\[log_2T\]+1

> 由1可得（T是正整数）：2^(k-1) ≤ T ≤ 2^k-1 < 2^k，即k-1 ≤ log_2T < k


## 2.分类

根据不同的特点，常见的二叉树可分为：

#### 2.1 二叉排序树

又称二叉搜索树，需要满足以下条件：

- 若左子树不为空，则左子树上所有节点的值均小于根节点的值
- 若右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉排序树

> - 对于值相等的节点可以根据业务需要，灵活的规定放在左或右节点，但规则必须在该树内统一
> - 对二叉排序树进行中序遍历，可以得到有序数列，而先序和后序遍历的结果都是无序的

#### 2.2 斜树

所有节点都只有左子树（左斜树）或右子树（右斜树）。不需要向排序树一样比较大小排位

> 这种树的深度高，相当于链表，应用较少

#### 2.3 满二叉树

所有分支节点都有左子树和右子树，并且所有叶子节点都在最后一层。不需要向排序树一样比较大小排位

- 叶子都在最下一层
- 非叶子节点度一定是2
- 同深度的二叉树中，满二叉树的节点个数最多，叶子树（节点）最多

#### 2.4 完全二叉树

对一棵具有n个节点的二叉树按层序编号（从上向下，从左向右），如果编号为i的节点与同深度的满二叉树编号为i节点在二叉树中位置完全相同，就是完全二叉树

> - 完全二叉树就是从上向下，从左向右依次排，如果最后一层恰好排满（即倒数第二层没有叶子节点）就是满二叉树。不需要向排序树一样比较大小
> - 满二叉树是完全二叉树，反之不一定

- 叶子节点都在最后一层或倒数第二层（满二叉树都在最后一层）
- 最下层的叶子节点一定集中在左部连续位置
- 倒数第二层，如有叶子节点，一定出现在右部连续位置。
- 相同节点数的二叉树，完全二叉树（或满二叉树）的深度最小



---

# II.二叉排序树

这里以二叉排序树为例，叙述二叉树节点的查找、插入、删除和遍历等。

> - 对于二叉排序树，不论是查找、插入、删除或遍历等，**都要从根节点开始比较**
> - 中序遍历的顺序为：左-根-右（增序），先序：根-左-右（无序），后序：左-右-根（无序）。一般使用中序遍历

