---
title: 设计模式-工厂
date: 2019-01-03 19:02:09
categories:
    - DesignPatterns
tags:
    - DesignPatterns

---

本文将介绍简单工厂、工厂方法、抽象工厂3种设计模式，其中简单工厂不属于23种GOF模式。

<!-- more -->

##### 目录
+ I.简单工厂模式
+ II.工厂方法模式
+ III.抽象工厂模式
+ IV.三者对比


# I.简单工厂模式

又称静态工厂方法（Static Factory Method）模式。定义一个工厂类，对实现了同一接口的类创建实例。

## 1.实现

```java
public interface Car {
    String getName();
}

public class Benz implements Car {
    public String getName() {
        return "Benz";
    }
}

public class BMW implements Car {
    public String getName() {
        return "BMW";
    }
}
```

- 方式1

```java
// 简单工厂1
public class SimpleFactory {
    public Car getCar(String name){
        if (name.equals("BMW")){
            return new BMW();
        }else if (name.equals("Benz")){
            return new Benz();
        }else {
            System.out.println("不好意思，这个品牌的汽车生产不了");
            return null;
        }
    }
}

// 测试类
public class SimpleFactoryTest {
    public static void main(String[] args){
        SimpleFactory simpleFactory = new SimpleFactory();
        System.out.println(simpleFactory.getCar("BMW").getName());
    }
}
```

- 方式2

之所以又称静态工厂方法，是因为也可以使用下列的实现方式

```java
// 简单工厂2
public class SimpleFactory {
    public static Car getBenz(){
        return new Benz();
    }
    public static Car getBMW(){
        return new BMW();
    }
}

// 测试类
public class SimpleFactoryTest {
    public static void main(String[] args){
        SimpleFactory simpleFactory = new SimpleFactory();
        System.out.println(simpleFactory.getBenz().getName());
    }
}
```

## 2.优缺点

- 优点：对象创建和使用分离；方便了调用者
- 缺点：违背了OCP，扩展需要改动原有逻辑；实现类较多时，复杂不灵活

## 3.示例

java.text.DateFormat

DateFormat：jdk中的一个工具类java.text.DateFormat,用来格式化一个本地日期与时间

通过源码我们可以知道DateFormat是一个抽象类（abstract），下面的源代码就是这个类里包含的方法，其实这些就是静态工厂方法，通过静态方法来提供自己的实例是完全可以的（抽象类本身不能进行实例化）。从源码可以看出getDateInstance()方法做了两件事情：

运用了多态性：由于SimpleDateFormat是DateFormat的子类，而getDateInstance()声明的类型为DateFormat而实际返回类型为子类SimpleDateFormat
使用了静态工厂方法（static）：由于DateFormat是抽象类不能进行实例化，因此也就不能调用其中的普通方法（非静态方法）。因此我们必须将其声明为static,才能返回实例
通过上面做的两件事情就将具体子类的实例化过程隐藏起来了，调用者不必考虑具体子类的实例化，因为抽象类会提供它的合适子类实例

```java
 public final static DateFormat getDateInstance()
    {
        return get(0, DEFAULT, 2, Locale.getDefault());
    }

    public final static DateFormat getDateInstance(int style)
    {
        return get(0, style, 2, Locale.getDefault());
    }

    public final static DateFormat getDateInstance(int style,
                                                 Locale aLocale)
    {
        return get(0, style, 2, aLocale);
    }
    
    private static DateFormat get(int timeStyle, int dateStyle,
                                  int flags, Locale loc) {
        if ((flags & 1) != 0) {
            if (timeStyle < 0 || timeStyle > 3) {
                throw new IllegalArgumentException("Illegal time style " + timeStyle);
            }
        } else {
            timeStyle = -1;
        }
        if ((flags & 2) != 0) {
            if (dateStyle < 0 || dateStyle > 3) {
                throw new IllegalArgumentException("Illegal date style " + dateStyle);
            }
        } else {
            dateStyle = -1;
        }
        try {
            // Check whether a provider can provide an implementation that's closer 
            // to the requested locale than what the Java runtime itself can provide.
            LocaleServiceProviderPool pool =
                LocaleServiceProviderPool.getPool(DateFormatProvider.class);
            if (pool.hasProviders()) {
                DateFormat providersInstance = pool.getLocalizedObject(
                                                    DateFormatGetter.INSTANCE,
                                                    loc, 
                                                    timeStyle,
                                                    dateStyle,
                                                    flags);
                if (providersInstance != null) {
                    return providersInstance;
                }
            }

            return new SimpleDateFormat(timeStyle, dateStyle, loc);
        } catch (MissingResourceException e) {
            return new SimpleDateFormat("M/d/yy h:mm a");
        }
    }
```


---

# II.工厂方法模式

Factory Method。为每一种产品提供一个工厂类，不同的工厂实例创建不同的产品实例。

是对简单工厂的进一步抽象，使其满足OCP。

## 1.实现

```java
// 工厂接口
public interface Factory {
    Car getCar();
}

// 奔驰工厂
public class BenzFactory implements Factory {
    public Car getCar() {
        return new Benz();
    }
}

// 宝马工厂
public class BMWFactory implements Factory{
    public Car getCar() {
        return new BMW();
    }
}

// 测试类
public class FactoryTest {
    public static void main(String[] args){
       Factory bmwFactory = new BMWFactory();
       System.out.println(bmwFactory.getCar().getName());
       Factory benzFactory = new BenzFactory();
       System.out.println(benzFactory.getCar().getName());
    }
}
```

## 2.优缺点

- 优点：遵循OCP，扩展性比简单工厂好
- 缺点：把简单工厂中的逻辑判断，转移到了客户端。并且各个工厂类增加了代码量


---

# III.抽象工厂模式

```java
// 抽象工厂
public abstract class AbstractFactory {

    protected abstract Car getCar();

     // 动态配置，固定模式的委派
    public Car getCar(String name){
        if("BMW".equalsIgnoreCase(name)){
            return new BmwFactory().getCar();
        }else if("Benz".equalsIgnoreCase(name)){
            return new BenzFactory().getCar();
        }else if("Audi".equalsIgnoreCase(name)){
            return new AudiFactory().getCar();
        }else{
            System.out.println("这个产品产不出来");
            return null;
        }
    }
}

// 默认工厂
public class DefaultFactory extends AbstractFactory {

    private AudiFactory defaultFactory = new AudiFactory();

    public Car getCar() {
        return defaultFactory.getCar();
    }
}

// 宝马工厂
public class BMWFactory extends AbstractFactory {
    public Car getCar() {
        return new BMW();
    }
}

// 奔驰工厂
public class BenzFactory extends AbstractFactory {
    public Car getCar() {
        return new Benz();
    }
}

// 测试类
public class AbstractFactoryTest {
    public static void main(String[] args) {
        DefaultFactory factory = new DefaultFactory();
        System.out.println(factory.getCar("Benz").getName());
    }
}
```


---

# IV.三者对比

- 简单工厂：只有一个工厂类，一个生产方法。根据参数不同生产不同的产品
- 工厂方法：每个工厂类只负责生产一种产品。好比一条生产线只生产一种产品
- 抽象工厂：每个工厂类提供多个方法，可以生产不同的产品。好比多条生产线可以生产多种产品