---
title: Shiro集成Spring Web环境
date: 2018-07-03 19:01:09
categories:
    - Shiro
tags:
    - Shiro
    - Basic
    - Java
---

本文在上篇入门的基础上，介绍和Spring web环境的集成

<!-- more -->

##### 目录
+ I.项目集成

---


# I.项目集成

## 1.工程目录

```
shiro-spring$ tree
.
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── baicai
    │   │           ├── controller
    │   │           │   └── LoginController.java
    │   │           ├── dao
    │   │           │   ├── impl
    │   │           │   │   └── UserDaoImpl.java
    │   │           │   └── UserDao.java
    │   │           ├── pojo
    │   │           │   └── User.java
    │   │           ├── realm
    │   │           │   └── MyJdbcRealm.java
    │   │           └── service
    │   │               ├── impl
    │   │               │   └── UserServiceImpl.java
    │   │               └── UserService.java
    │   ├── resources
    │   │   ├── druid.properties
    │   │   ├── log4j.properties
    │   │   └── spring
    │   │       ├── applicationContext-shiro.xml
    │   │       ├── applicationContext.xml
    │   │       └── springmvc-servlet.xml
    │   └── webapp
    │       ├── 403.html
    │       ├── index.html
    │       ├── login.html
    │       └── WEB-INF
    │           └── web.xml
    └── test
        └── java
```

## 2.配置文件

- pom.xml

```xml
<!-- Spring -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>
<!-- Shiro -->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-core</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-web</artifactId>
</dependency>
<!-- mysql（注意8.0的驱动推荐MySQL Connector/J 8.0） -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
</dependency>
<!-- 日志 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
</dependency>
```

- web.xml

> 配置Shiro过滤器，拦截所有请求

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">

    <!-- 加载Spring配置 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <!-- 也可以在其中一个使用import导入其他配置 -->
        <param-value>classpath:spring/applicationContext*.xml</param-value>
    </context-param>

    <!-- DispatcherServlet -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/springmvc-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <!-- spring过滤器解决POST乱码（GET手动解决）-->
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- shiro过滤器 -->
    <filter>
        <filter-name>shiroFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>shiroFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- 静态资源处理 -->
    <servlet-mapping>
        <servlet-name>default</servlet-name>
        <url-pattern>*.html</url-pattern>
        <url-pattern>*.css</url-pattern>
        <url-pattern>*.js</url-pattern>
    </servlet-mapping>
</web-app>
```

- springmvc-servlet.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 注解驱动（自动配置、JSON支持等） -->
    <mvc:annotation-driven/>

    <!-- Controller包扫描 -->
    <context:component-scan base-package="com.baicai.controller"/>
</beans>
```

- applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- Service包扫描-->
    <context:component-scan base-package="com.baicai.service,com.baicai.dao"/>

    <!-- 数据源 -->
    <context:property-placeholder location="classpath:druid.properties"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="driverClassName" value="${druid.driverClassName}"/>
        <property name="url" value="${druid.url}"/>
        <property name="username" value="${druid.username}"/>
        <property name="password" value="${druid.password}"/>
    </bean>

    <!-- 访问数据库 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 静态资源处理-->
    <!--<mvc:resources mapping="/*" location="/"/>-->
    <!--<mvc:default-servlet-handler/>-->
</beans>
```

- applicationContext-shiro

> Spring整合Shiro配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Shiro过滤器 -->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <property name="loginUrl" value="login.html"/>
        <property name="successUrl" value="index.html"/>
        <property name="unauthorizedUrl" value="403.html"/>
        <property name="filterChainDefinitions">
            <value>
                /login.html = anon
                /login = anon
                /* = authc
            </value>
        </property>
    </bean>

    <!-- SecurityManager -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="realm"/>
    </bean>

    <!-- Realm-->
    <bean id="realm" class="com.baicai.realm.MyJdbcRealm">
        <property name="credentialsMatcher" ref="hashedCredentialsMatcher"/>
    </bean>

    <!-- 加密 -->
    <bean id="hashedCredentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <property name="hashAlgorithmName" value="MD5"/>
        <property name="hashIterations" value="1"/>
    </bean>
</beans>
```

- 其他配置

> druid.properties

```java
druid.driverClassName=com.mysql.cj.jdbc.Driver
druid.url=jdbc:mysql://localhost:3306/test
druid.username=root
druid.password=root
```

> log4j.properties文件不再赘述

## 3.代码部分

#### 3.1 Controller测试接口

- LoginController

```java
@Controller
public class LoginController {

    @PostMapping(value = "/login", produces = "application/json;charset=utf-8")
    @ResponseBody
    public String login(User user) {
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());
        try {
            subject.login(token);
        } catch (AuthenticationException e) {
            return e.getMessage();
        }
        return "登录成功";
    }

    @GetMapping(value = "/testRoleAndPerm", produces = "application/json;charset=utf-8")
    @ResponseBody
    public String testRoleAndPerm() {
        Subject subject = SecurityUtils.getSubject();
        StringBuffer sb = new StringBuffer();
        sb.append(subject.hasRole("admin1") ? "" : "没").append("有admin1角色...\n");
        sb.append(subject.hasRole("admin8") ? "" : "没").append("有admin8角色...\n");
        sb.append(subject.isPermitted("user:insert") ? "" : "没").append("有user:insert权限...\n");
        sb.append(subject.isPermitted("user:select") ? "" : "没").append("有user:select权限...\n");
        sb.append(subject.isPermittedAll("user:insert", "user:delete") ? "" : "没").append("有user:insert && user:delete(同时)权限...\n");
        return sb.toString();
    }
}
```

> Subject的操作：login，hasRole，isPermitted等，都会使用配置中的自定Realm：MyJdbcRealm来完成认证或授权等

#### 3.2 自定义MyJdbcRealm

> - 1.使用继承AuthorizingRealm的方式（而AuthorizingRealm又继承自AuthenticatingRealm）
> - 2.自定义Realm需要访问数据库，查询User的认证、角色、权限等信息，所以提供了UserService、UserDao层，方便数据的查询

- MyJdbcRealm.java

```java
public class MyJdbcRealm extends AuthorizingRealm {
    {
        //设置自定义Realm的名称
        super.setName("myJdbcRealm");
    }

    @Autowired
    private UserService userService;

    /** 获取角色、权限源数据 */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        //1.从主体Token中获取用户名
        String username = (String) principals.getPrimaryPrincipal();
        //2.查询用户角色和权限
        List<String> roles = userService.getRolesByUsername(username);
        List<String> permissions = userService.getPermissionsByRoles(roles);
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.setRoles(roles == null ? null : new HashSet<>(roles));
        info.setStringPermissions(permissions == null ? null : new HashSet<>(permissions));
        return info;
    }

    /** 获取认证源数据 */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        //1.从主体Token中获取用户名
        String username = (String) token.getPrincipal();
        //2.通过用户名查询数据库（模拟）
        User exitUser = userService.getUserByUsername(username);
        if (exitUser == null)
            return null;
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, exitUser.getPassword(), this.getName());
        info.setCredentialsSalt(ByteSource.Util.bytes("salt"));//加盐(数据库中的加密密码使用了盐)
        return info;
    }
}
```

- UserServiceImpl.java

> 这里省略展示接口代码，只展示实现类

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    /** 根据用户名，查询用户 */
    @Override
    public User getUserByUsername(String username) {
        return userDao.getUsersByUsername(username);
    }

    /** 根据用户名，查询用户角色 */
    @Override
    public List<String> getRolesByUsername(String username) {
        if (username == null) return null;
        return userDao.getRolesByUsername(username);
    }

    /** 根据角色名，查询角色权限 */
    @Override
    public List<String> getPermissionsByRoles(List<String> roleNames) {
        if (CollectionUtils.isEmpty(roleNames)) return null;
        return userDao.getPermissionsByRoles(roleNames);
    }
}
```

- UserDaoImpl.java

```java
@Repository
public class UserDaoImpl implements UserDao {

    protected static final String AUTHENTICATION_QUERY = "SELECT * FROM users WHERE username = ?";
    protected static final String USER_ROLES_QUERY = "SELECT role_name FROM user_roles WHERE username = ?";
    protected static final String PERMISSIONS_QUERY = "SELECT permission FROM roles_permissions WHERE role_name in (:roleNames)";

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    /** 根据用户名，查询用户 */
    @Override
    public User getUsersByUsername(String username) {
        List<User> users = this.jdbcTemplate.query(AUTHENTICATION_QUERY, new String[]{username}, new RowMapper<User>() {
            @Override
            public User mapRow(ResultSet rs, int i) throws SQLException {
                return new User(rs.getString("username"), rs.getString("password"));
            }
        });
        return CollectionUtils.isEmpty(users) ? null : users.get(0);
    }

    /** 根据用户名，查询用户角色 */
    @Override
    public List<String> getRolesByUsername(String username) {
        return this.jdbcTemplate.query(USER_ROLES_QUERY, new String[]{username}, new RowMapper<String>() {
            @Override
            public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                return rs.getString("role_name");
            }
        });
    }

    /** 根据角色名，查询角色权限 */
    @Override
    public List<String> getPermissionsByRoles(List<String> roleNames) {
        //jdbcTemplate不支持in，这里使用NamedParameterJdbcTemplate代替
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        Map<String, Object> params = new HashMap<>(4);
        params.put("roleNames", roleNames);
        return namedParameterJdbcTemplate.query(PERMISSIONS_QUERY, params, new RowMapper<String>() {
            @Override
            public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                return rs.getString("permission");
            }
        });
    }
}
```

> 数据库数据参考[Shiro入门（一）](http://blog.wocaishiliuke.cn/shiro/2018/07/01/Shiro01/)中JdbcRealm默认SQL对应的表数据，注意密码需要加盐加密

#### 3.3 页面

- login.html

```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
</head>
<body>
    <form action="/login" method="post">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="username"></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="password"></td>
            </tr>
            <tr>
                <td><input type="submit" value="登录"></td>
            </tr>
        </table>
    </form>
</body>
</html>
```

## 4.测试

- 1.访问http://localhost:9100/testRoleAndPerm，由于未登录，返回302重定向到login.html
- 2.登录页，分别使用错误账号、错误密码登录，查看返回的异常信息
- 3.登录页，使用正确的账号、密码登录
- 4.访问http://localhost:9100/testRoleAndPerm，测试登录后的角色、权限校验

## 5.注解权限控制

上述testRoleAndPerm方法中使用的是编程方式，完成角色、权限的校验，Shiro也提供了注解方式。

#### 