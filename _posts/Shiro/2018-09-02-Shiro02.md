---
title: Shiro集成Spring Web环境
date: 2018-09-02 19:01:09
categories:
    - Shiro
tags:
    - Shiro
    - Basic
    - Java
---

本文在上篇入门的基础上，介绍和Spring web环境的集成，包括自定义Realm、Filter、SessionDao、SessionManager

<!-- more -->

##### 目录
+ I.与Spring Web集成
+ II.Shiro过滤器
+ III.Shiro会话管理
+ IV.Shiro缓存管理
+ V.RememberMe

---


# I.项目集成

## 1.工程目录

```
shiro-spring$ tree
.
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── baicai
    │   │           ├── controller
    │   │           │   └── LoginController.java
    │   │           ├── dao
    │   │           │   ├── impl
    │   │           │   │   └── UserDaoImpl.java
    │   │           │   └── UserDao.java
    │   │           ├── pojo
    │   │           │   └── User.java
    │   │           ├── realm
    │   │           │   └── MyJdbcRealm.java
    │   │           └── service
    │   │               ├── impl
    │   │               │   └── UserServiceImpl.java
    │   │               └── UserService.java
    │   ├── resources
    │   │   ├── druid.properties
    │   │   ├── log4j.properties
    │   │   └── spring
    │   │       ├── applicationContext-shiro.xml
    │   │       ├── applicationContext.xml
    │   │       └── springmvc-servlet.xml
    │   └── webapp
    │       ├── 403.html
    │       ├── index.html
    │       ├── login.html
    │       └── WEB-INF
    │           └── web.xml
    └── test
        └── java
```

## 2.配置文件

- pom.xml

```xml
<!-- Spring -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>
<!-- Shiro -->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-core</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-web</artifactId>
</dependency>
<!-- mysql（注意8.0的驱动推荐MySQL Connector/J 8.0） -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
</dependency>
<!-- 日志 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
</dependency>
```

- web.xml

> 配置Shiro过滤器，拦截所有请求

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0">

    <!-- 加载Spring配置 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <!-- 也可以在其中一个使用import导入其他配置 -->
        <param-value>classpath:spring/applicationContext*.xml</param-value>
    </context-param>

    <!-- DispatcherServlet -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/springmvc-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <!-- spring过滤器解决POST乱码（GET手动解决）-->
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- shiro过滤器 -->
    <filter>
        <filter-name>shiroFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>shiroFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- 静态资源处理 -->
    <servlet-mapping>
        <servlet-name>default</servlet-name>
        <url-pattern>*.html</url-pattern>
        <url-pattern>*.css</url-pattern>
        <url-pattern>*.js</url-pattern>
    </servlet-mapping>
</web-app>
```

- springmvc-servlet.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 注解驱动（自动配置、JSON支持等） -->
    <mvc:annotation-driven/>

    <!-- Controller包扫描 -->
    <context:component-scan base-package="com.baicai.controller"/>
</beans>
```

- applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- Service包扫描-->
    <context:component-scan base-package="com.baicai.service,com.baicai.dao"/>

    <!-- 数据源 -->
    <context:property-placeholder location="classpath:druid.properties"/>
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
        <property name="driverClassName" value="${druid.driverClassName}"/>
        <property name="url" value="${druid.url}"/>
        <property name="username" value="${druid.username}"/>
        <property name="password" value="${druid.password}"/>
    </bean>

    <!-- 访问数据库 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 静态资源处理-->
    <!--<mvc:resources mapping="/*" location="/"/>-->
    <!--<mvc:default-servlet-handler/>-->
</beans>
```

- applicationContext-shiro.xml

> Spring整合Shiro配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Shiro过滤器 -->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <property name="loginUrl" value="login.html"/>
        <property name="successUrl" value="index.html"/>
        <property name="unauthorizedUrl" value="403.html"/>
        <property name="filterChainDefinitions">
            <value>
                /login.html = anon
                /login = anon
                /* = authc
            </value>
        </property>
    </bean>

    <!-- SecurityManager -->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="realm"/>
    </bean>

    <!-- Realm-->
    <bean id="realm" class="com.baicai.realm.MyJdbcRealm">
        <property name="credentialsMatcher" ref="hashedCredentialsMatcher"/>
    </bean>

    <!-- 加密 -->
    <bean id="hashedCredentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
        <property name="hashAlgorithmName" value="MD5"/>
        <property name="hashIterations" value="1"/>
    </bean>
</beans>
```

- 其他配置

> druid.properties

```java
druid.driverClassName=com.mysql.cj.jdbc.Driver
druid.url=jdbc:mysql://localhost:3306/test
druid.username=root
druid.password=root
```

> log4j.properties文件不再赘述

## 3.代码部分

#### 3.1 Controller测试接口

- LoginController

```java
@Controller
public class LoginController {

    @PostMapping(value = "/login", produces = "application/json;charset=utf-8")
    @ResponseBody
    public String login(User user) {
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());
        try {
            subject.login(token);
        } catch (AuthenticationException e) {
            return e.getMessage();
        }
        return "登录成功";
    }

    @GetMapping(value = "/testRoleAndPerm", produces = "application/json;charset=utf-8")
    @ResponseBody
    public String testRoleAndPerm() {
        Subject subject = SecurityUtils.getSubject();
        StringBuffer sb = new StringBuffer();
        sb.append(subject.hasRole("admin1") ? "" : "没").append("有admin1角色...\n");
        sb.append(subject.hasRole("admin8") ? "" : "没").append("有admin8角色...\n");
        sb.append(subject.isPermitted("user:insert") ? "" : "没").append("有user:insert权限...\n");
        sb.append(subject.isPermitted("user:select") ? "" : "没").append("有user:select权限...\n");
        sb.append(subject.isPermittedAll("user:insert", "user:delete") ? "" : "没").append("有user:insert && user:delete(同时)权限...\n");
        return sb.toString();
    }
}
```

> Subject的操作：login，hasRole，isPermitted等，都会使用配置中的自定Realm：MyJdbcRealm来完成认证或授权等

#### 3.2 自定义MyJdbcRealm

> - 1.使用继承AuthorizingRealm的方式（而AuthorizingRealm又继承自AuthenticatingRealm）
> - 2.自定义Realm需要访问数据库，查询User的认证、角色、权限等信息，所以提供了UserService、UserDao层，方便数据的查询

- MyJdbcRealm.java

```java
public class MyJdbcRealm extends AuthorizingRealm {
    {
        //设置自定义Realm的名称
        super.setName("myJdbcRealm");
    }

    @Autowired
    private UserService userService;

    /** 获取角色、权限源数据 */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        //1.从主体Token中获取用户名
        String username = (String) principals.getPrimaryPrincipal();
        //2.查询用户角色和权限
        List<String> roles = userService.getRolesByUsername(username);
        List<String> permissions = userService.getPermissionsByRoles(roles);
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        info.setRoles(roles == null ? null : new HashSet<>(roles));
        info.setStringPermissions(permissions == null ? null : new HashSet<>(permissions));
        return info;
    }

    /** 获取认证源数据 */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        //1.从主体Token中获取用户名
        String username = (String) token.getPrincipal();
        //2.通过用户名查询数据库（模拟）
        User exitUser = userService.getUserByUsername(username);
        if (exitUser == null)
            return null;
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username, exitUser.getPassword(), this.getName());
        info.setCredentialsSalt(ByteSource.Util.bytes("salt"));//加盐(数据库中的加密密码使用了盐)
        return info;
    }
}
```

- UserServiceImpl.java

> 这里省略展示接口代码，只展示实现类

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    /** 根据用户名，查询用户 */
    @Override
    public User getUserByUsername(String username) {
        return userDao.getUsersByUsername(username);
    }

    /** 根据用户名，查询用户角色 */
    @Override
    public List<String> getRolesByUsername(String username) {
        if (username == null) return null;
        return userDao.getRolesByUsername(username);
    }

    /** 根据角色名，查询角色权限 */
    @Override
    public List<String> getPermissionsByRoles(List<String> roleNames) {
        if (CollectionUtils.isEmpty(roleNames)) return null;
        return userDao.getPermissionsByRoles(roleNames);
    }
}
```

- UserDaoImpl.java

```java
@Repository
public class UserDaoImpl implements UserDao {

    protected static final String AUTHENTICATION_QUERY = "SELECT * FROM users WHERE username = ?";
    protected static final String USER_ROLES_QUERY = "SELECT role_name FROM user_roles WHERE username = ?";
    protected static final String PERMISSIONS_QUERY = "SELECT permission FROM roles_permissions WHERE role_name in (:roleNames)";

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    /** 根据用户名，查询用户 */
    @Override
    public User getUsersByUsername(String username) {
        List<User> users = this.jdbcTemplate.query(AUTHENTICATION_QUERY, new String[]{username}, new RowMapper<User>() {
            @Override
            public User mapRow(ResultSet rs, int i) throws SQLException {
                return new User(rs.getString("username"), rs.getString("password"));
            }
        });
        return CollectionUtils.isEmpty(users) ? null : users.get(0);
    }

    /** 根据用户名，查询用户角色 */
    @Override
    public List<String> getRolesByUsername(String username) {
        return this.jdbcTemplate.query(USER_ROLES_QUERY, new String[]{username}, new RowMapper<String>() {
            @Override
            public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                return rs.getString("role_name");
            }
        });
    }

    /** 根据角色名，查询角色权限 */
    @Override
    public List<String> getPermissionsByRoles(List<String> roleNames) {
        //jdbcTemplate不支持in，这里使用NamedParameterJdbcTemplate代替
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        Map<String, Object> params = new HashMap<>(4);
        params.put("roleNames", roleNames);
        return namedParameterJdbcTemplate.query(PERMISSIONS_QUERY, params, new RowMapper<String>() {
            @Override
            public String mapRow(ResultSet rs, int rowNum) throws SQLException {
                return rs.getString("permission");
            }
        });
    }
}
```

> 数据库数据参考[Shiro入门（一）](http://blog.wocaishiliuke.cn/shiro/2018/07/01/Shiro01/)中JdbcRealm默认SQL对应的表数据，注意密码需要加盐加密

#### 3.3 页面

- login.html

```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登录</title>
</head>
<body>
    <form action="/login" method="post">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="username"></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="password"></td>
            </tr>
            <tr>
                <td><input type="submit" value="登录"></td>
            </tr>
        </table>
    </form>
</body>
</html>
```

## 4.测试

- 1.访问http://localhost:9100/testRoleAndPerm，由于未登录，返回302重定向到login.html
- 2.登录页，分别使用错误账号、错误密码登录，查看返回的异常信息
- 3.登录页，使用正确的账号、密码登录
- 4.访问http://localhost:9100/testRoleAndPerm，测试登录后的角色、权限校验

## 5.注解权限控制

上述testRoleAndPerm方法中使用的是编程方式，完成角色、权限的校验，Shiro也提供了注解方式。

#### 5.1 增加配置

> 注意是在**SpringMVC的配置文件**中增加下列配置

```xml
<!-- 在SpringMVC的配置文件中，配置Shiro注解方式（Shiro注解使用在Controller上） -->
<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor" />
<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
    <property name="securityManager" ref="securityManager"/>
</bean>
```

#### 5.2 测试代码

```java
@RequiresRoles(value = "admin8")
@RequestMapping(value = "/testAnnoRoleAdmin8", produces = "application/json;charset=utf-8")
@ResponseBody
public String testAnnoRoleAdmin1() { return "同时有[admin8]角色(anno)..."; }

@RequiresPermissions(value = "user:insert")
@RequestMapping(value = "/testAnnoPermInsert", produces = "application/json;charset=utf-8")
@ResponseBody
public String testAnnoPermInsert() { return "有[user:insert]权限(anno)..."; }

@RequiresPermissions(value = "user:select")
@RequestMapping(value = "/testAnnoPermSelect", produces = "application/json;charset=utf-8")
@ResponseBody
public String testAnnoPermSelect() { return "有[user:select]权限(anno)..."; }
```

- 1.访问http://localhost:9100/login.html完成登录
- 2.分别访问下列地址，测试权限注解的使用：

```java
http://localhost:9100/testAnnoRoleAdmin1
http://localhost:9100/testAnnoRoleAdmin8
http://localhost:9100/testAnnoPermInsert
http://localhost:9100/testAnnoPermSelect
```

> 此时无权访问的接口，也不会跳到403.html。因为只有配置了AuthorizationFilter的子类，即perms，roles，ssl，rest，port才会跳转，而anon，authcBasic，auchc，user是AuthenticationFilter，不跳转


---


# II.Shiro过滤器

## 1.内置filter

- 认证相关：anon，authcBasic，auchc，user，logout
- 授权相关：perms，roles，ssl，rest，port

> 在shiroFilter中配置过滤器链

- applicationContext-shiro.xml

```xml
<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
    <property name="securityManager" ref="securityManager"/>
    <property name="loginUrl" value="login.html"/>
    <property name="successUrl" value="index.html"/>
    <property name="unauthorizedUrl" value="403.html"/>
    <property name="filterChainDefinitions">
        <value>
            /login.html = anon
            /login = anon
            /testRole = roles["admin1"]
            /testRoles = roles["admin1", "admin8"]
            /testPerm = perms["user:insert"]
            /testPerms = perms["user:insert", "user:select"]
            /* = authc
        </value>
    </property>
</bean>
```

- LoginController.java

```java
@RequestMapping(value = "/testRole", produces = "application/json;charset=utf-8")
@ResponseBody
public String testRole() { return "有该角色..."; }

@RequestMapping(value = "/testRoles", produces = "application/json;charset=utf-8")
@ResponseBody
public String testRoles() { return "有该些角色..."; }

@RequestMapping(value = "/testPerm", produces = "application/json;charset=utf-8")
@ResponseBody
public String testPerm() { return "有该权限..."; }

@RequestMapping(value = "/testPerms", produces = "application/json;charset=utf-8")
@ResponseBody
public String testPerms() { return "有该些权限..."; }
```

- 测试

> 先登录，依次访问各接口，没有权限访问时，会跳到配置的403页面（unauthorizedUrl）

## 2.自定义filter

> 实现**或关系**的Roles filter（内置的Roles filter，需要具备所有角色才能访问）

用于认证的，继承AuthenticationFilter。用于授权的继承AuthorizationFilter

- RolesOrFilter.java

```java
/** 自定义角色过滤器，满足一个Role即可访问 */
public class RolesOrFilter extends AuthorizationFilter {
    /** @param o 角色数组 */
    @Override
    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) throws Exception {
        Subject subject = this.getSubject(servletRequest, servletResponse);
        String[] roles = (String[]) o;
        if (roles == null || roles.length == 0) return true;
        for (String role : roles) {
            //有一个就可以访问
            if (subject.hasRole(role)) return true;
        }
        return false;
    }
}
```

- applicationContext-shiro.xml

> 将自定义过滤器交给Spring，并配置到Shiro中，在过滤器链中配置要过滤的接口

```xml
<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
    <property name="securityManager" ref="securityManager"/>
    <property name="loginUrl" value="login.html"/>
    <property name="successUrl" value="index.html"/>
    <property name="unauthorizedUrl" value="403.html"/>
    <!-- 配置过滤器链 -->
    <property name="filterChainDefinitions">
        <value>
            /login.html = anon
            /login = anon

            /testRole = roles["admin1"]
            /testRoles = roles["admin1", "admin8"]
            /testPerm = perms["user:insert"]
            /testPerms = perms["user:insert", "user:select"]

            /testRolesOr = rolesOr["admin11", "admin8"]

            /* = authc
        </value>
    </property>
    <!-- 配置自定义过滤器 -->
    <property name="filters">
        <map>
            <entry key="rolesOr" value-ref="rolesOrFilter"/>
        </map>
    </property>
</bean>

<!-- 自定义过滤器 -->
<bean id="rolesOrFilter" class="com.baicai.filter.RolesOrFilter"/>
```

> 修改rolesOr中的角色信息，完成自定义过滤器的测试，不满足时跳到403


---


# III.Shiro会话管理

Shiro有一套特有的Session管理机制，在非Web环境（Servlet或Tomcat等）下，仍可以使用Session

## 1.自定义SessionDao

使用Redis实现Session共享，主要重写Session的CRUD方法（**这里先自定义SessionDao，稍后自定义SessionManager**）

#### 1.1 代码部分

- RedisSessionDao.java

> Redis中Session的键值对：
> k:(SHIRO_SESSION_PREFIX + sessionId).getBytes()
> v:SerializationUtils.serialize(session)

```java
/** 基于Redis的SessionDao */
public class RedisSessionDao extends AbstractSessionDAO {

    private static final String SHIRO_SESSION_PREFIX = "baicai-session:";

    @Autowired
    private JedisUtil jedisUtil;

    /** 存入Session */
    @Override
    protected Serializable doCreate(Session session) {
        // 为当前Session创建新的sessionId，并捆绑
        System.out.println("write session...");
        Serializable sessionId = generateSessionId(session);
        assignSessionId(session, sessionId);
        // 存入redis
        saveSession(session);
        return sessionId;
    }

    /** 获取Session */
    @Override
    protected Session doReadSession(Serializable sessionId) {
        System.out.println("read session...");
        if (sessionId == null)
            return null;
        byte[] key = getKey(sessionId.toString());
        byte[] value = jedisUtil.get(key);
        return (Session) SerializationUtils.deserialize(value);
    }

    /** 更新Session */
    @Override
    public void update(Session session) throws UnknownSessionException {
        saveSession(session);
    }

    /** 删除Session */
    @Override
    public void delete(Session session) {
        if (session == null || session.getId() == null)
            return;
        byte[] key = getKey(session.getId().toString());
        jedisUtil.del(key);
    }

    /** 获取所有Session */
    @Override
    public Collection<Session> getActiveSessions() {
        // 根据前缀获取所有key
        Set<byte[]> keys = jedisUtil.keys(SHIRO_SESSION_PREFIX);
        Collection<Session> sessions = null;
        if (CollectionUtils.isEmpty(keys))
            return sessions;
        for (byte[] key : keys) {
            sessions.add((Session) SerializationUtils.deserialize(jedisUtil.get(key)));
        }
        return sessions;
    }

    /** 获取redis中的key */
    private byte[] getKey(String originalKey) {
        return (SHIRO_SESSION_PREFIX + originalKey).getBytes();
    }

    /** 存入或更新redis中的session */
    private void saveSession(Session session) {
        // 将session存入redis
        byte[] key = getKey(session.getId().toString());
        byte[] value = SerializationUtils.serialize(session);
        jedisUtil.set(key, value);
        jedisUtil.expire(key, 600);//10min
    }
}
```

- JedisUtil.java

> 操作redis的Jedis工具类

```java
/** Jedis工具类 */
@Component
public class JedisUtil {

    private static final Logger logger = LoggerFactory.getLogger(JedisUtil.class);

    @Autowired
    private JedisPool jedisPool;

    /** 获取连接 */
    private Jedis getResource() {
        return jedisPool.getResource();
    }

    /** 存入 */
    public void set(byte[] key, byte[] value) {
        Jedis jedis = getResource();
        try {
            jedis.set(key, value);
        } catch (Exception e) {
            logger.error("存入redis出错");
            e.printStackTrace();
        } finally {
            // 确保连接关闭
            jedis.close();
        }
    }

    /** 取出 */
    public byte[] get(byte[] key) {
        Jedis jedis = getResource();
        byte[] value = null;
        try {
            value = jedis.get(key);
        } catch (Exception e) {
            logger.error("取出redis出错");
            e.printStackTrace();
        } finally {
            jedis.close();
        }
        return value;
    }

    /** 删除 */
    public void del(byte[] key) {
        Jedis jedis = getResource();
        try {
            jedis.del(key);
        } catch (Exception e) {
            logger.error("删除redis报错");
            e.printStackTrace();
        } finally {
            jedis.close();
        }
    }

    /** 根据前缀，获取key */
    public Set<byte[]> keys(String prefix) {
        Jedis jedis = getResource();
        Set<byte[]> keys = null;
        try {
            keys = jedis.keys((prefix + "*").getBytes());
        } catch (Exception e) {
            logger.error("删除redis报错");
            e.printStackTrace();
        } finally {
            jedis.close();
        }
        return keys;
    }

    /** 过期时间 */
    public void expire(byte[] key, int second) {
        Jedis jedis = getResource();
        try {
            jedis.expire(key, second);
        } catch (Exception e) {
            logger.error("设置过期时间报错");
            e.printStackTrace();
        } finally {
            jedis.close();
        }
    }
}
```

#### 1.2 配置部分

- applicationContext.xml中增加对工具包的扫描

```xml
<!-- Service包扫描-->
<context:component-scan base-package="...,com.baicai.util"/>
```

- applicationContext-shiro.xml中配置自定义的SessionDao

```xml
<!-- SecurityManager -->
<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
    <property name="realm" ref="realm"/>
    <property name="sessionManager" ref="sessionManager"/>
</bean>

...

<!-- Session管理器 -->
<bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
    <property name="sessionDAO" ref="redisSessionDao"/>
</bean>
<!-- 自定义SessionDao -->
<bean id="redisSessionDao" class="com.baicai.session.RedisSessionDao"/>
```

#### 1.3 测试

- 1.打开redis服务

```shell
cd /opt/redis-4.0.11/
./src/redis-server
```

- 2.启动工程，访问登录页http://localhost:9100/login.html，此时redis中已有

```shell
keys bai*
1) "baicai-session:1875208f-cca3-4b1c-90b2-0de7a9ca05e6"
```

```java
2018-11-20 11:07:29,366 [http-nio-9100-exec-1] [org.apache.shiro.session.mgt.AbstractValidatingSessionManager]-[DEBUG] No sessionValidationScheduler set.  Attempting to create default instance.
2018-11-20 11:07:29,368 [http-nio-9100-exec-1] [org.apache.shiro.session.mgt.AbstractValidatingSessionManager]-[INFO] Enabling session validation scheduler...
2018-11-20 11:07:29,377 [http-nio-9100-exec-1] [org.apache.shiro.session.mgt.DefaultSessionManager]-[DEBUG] Unable to resolve session ID from SessionKey [org.apache.shiro.web.session.mgt.WebSessionKey@2b749874].  Returning null to indicate a session could not be found.
2018-11-20 11:07:29,484 [http-nio-9100-exec-2] [org.apache.shiro.session.mgt.DefaultSessionManager]-[DEBUG] Unable to resolve session ID from SessionKey [org.apache.shiro.web.session.mgt.WebSessionKey@50822b8f].  Returning null to indicate a session could not be found.
2018-11-20 11:07:29,489 [http-nio-9100-exec-2] [org.apache.shiro.session.mgt.DefaultSessionManager]-[DEBUG] Creating new EIS record for new session instance [org.apache.shiro.session.mgt.SimpleSession,id=null]
write session...
2018-11-20 11:07:29,530 [http-nio-9100-exec-2] [org.apache.shiro.web.servlet.SimpleCookie]-[DEBUG] Added HttpServletResponse Cookie [JSESSIONID=1875208f-cca3-4b1c-90b2-0de7a9ca05e6; Path=/; HttpOnly]
read session...
2018-11-20 11:07:29,549 [http-nio-9100-exec-2] [org.apache.shiro.web.servlet.SimpleCookie]-[DEBUG] Found 'JSESSIONID' cookie value [1875208f-cca3-4b1c-90b2-0de7a9ca05e6]
read session...
read session...
read session...
read session...
read session...
read session...
read session...
read session...
read session...
read session...
```

#### 1.3 待优化问题

从测试中看到，每次访问都会多次到redis中读取session，增加redis压力。查看获取Session的源码，即DefaultWebSessionManager继承DefaultSessionManager的retrieveSession()

```java
protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {
    Serializable sessionId = getSessionId(sessionKey);
    if (sessionId == null) {
        log.debug("Unable to resolve session ID from SessionKey [{}].  Returning null to indicate a " +
                "session could not be found.", sessionKey);
        return null;
    }
    // 每次都要使用sessionDAO获取readSession
    Session s = retrieveSessionFromDataSource(sessionId);
    if (s == null) {
        //session ID was provided, meaning one is expected to be found, but we couldn't find one:
        String msg = "Could not find session with ID [" + sessionId + "]";
        throw new UnknownSessionException(msg);
    }
    return s;
}

protected Session retrieveSessionFromDataSource(Serializable sessionId) throws UnknownSessionException {
    return sessionDAO.readSession(sessionId);
}
```

> 源码中，每次执行retrieveSession时都会根据sessionId，调用sessionDAO（自定义的RedisSessionDao）的readSession，即访问redis。下面使用自定义SessionManager，重写该部分代码，改从request中直接获取

## 2.自定义SessionManager

#### 2.1 代码部分

- CustomSessionManager.java

```java
public class CustomSessionManager extends DefaultWebSessionManager {

    private static final Logger log = LoggerFactory.getLogger(CustomSessionManager.class);

    @Override
    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {
        Serializable sessionId = getSessionId(sessionKey);
        if (sessionId == null) {
            log.debug("Unable to resolve session ID from SessionKey [{}].  Returning null to indicate a " +
                    "session could not be found.", sessionKey);
            return null;
        }
        Session s = null;

        // 1.先从request中获取
        ServletRequest request = null;
        if (sessionKey instanceof WebSessionKey) {
            request = ((WebSessionKey) sessionKey).getServletRequest();
            if (request != null) {
                s = (Session) request.getAttribute(sessionId.toString());
                if (s != null)
                    return s;
            }
        }

        // 2.没有request 或 request中获取不到时，再从SessionDao中获取，并放入request
        s = super.retrieveSessionFromDataSource(sessionId);
        if (s == null) {
            //session ID was provided, meaning one is expected to be found, but we couldn't find one:
            String msg = "Could not find session with ID [" + sessionId + "]";
            throw new UnknownSessionException(msg);
        }
        if (request != null)
            request.setAttribute(sessionId.toString(), s);
        return s;
    }
}
```

#### 2.2 配置部分

applicationContext-shiro.xml中替换默认的SessionDao

```xml
<!-- 自定义Session管理器 -->
<!--<bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">-->
<bean id="sessionManager" class="com.baicai.session.CustomSessionManager">
    <property name="sessionDAO" ref="redisSessionDao"/>
</bean>
```

#### 2.3 测试

> 每次请求，只会打印read session...一次。即该请求中只从redis读取一次，之后从该次request对象中获取session


---


# IV.Shiro缓存管理

一般只做授权的缓存（认证信息没有必要），提升访问性能。常用集成缓存ehcache、redis等。

> 还可以将权限数据存入内存中做二级缓存（如Map），当Map中没有命中时，再去查redis，redis也没有才去查DB，并存入两级缓存。这里只实现redis缓存

## 1.自定义CacheManager和Cache实现类

#### 1.1 代码部分

- RedisCacheManager.java

```java
/** 基于redis自定义CacheManager实现类 */
public class RedisCacheManager implements CacheManager {

    @Autowired
    private RedisCache redisCache;

    /** 获取缓存实例 */
    @Override
    public <K, V> Cache<K, V> getCache(String name) throws CacheException {
        return redisCache;
    }
}
```

- RedisCache.java

> Redis中的(权限)缓存：
> k:(SHIRO_CACHE_PREFIX + new String(SerializationUtils.serialize(k))).getBytes()
> v:SerializationUtils.serialize(v)

```java
/** 自定义基于redis的cache */
@Component
public class RedisCache<K,V> implements Cache<K,V> {

    private static final String SHIRO_CACHE_PREFIX = "shiro-cahce:";

    @Autowired
    private JedisUtil jedisUtil;

    /** 取出 */
    @Override
    public V get(K k) throws CacheException {
        System.out.println("从redis获取授权数据...");
        byte[] value = jedisUtil.get(getKey(k));
        if (value != null)
            return (V) SerializationUtils.deserialize(value);
        return null;
    }

    /** 存入 */
    @Override
    public V put(K k, V v) throws CacheException {
        System.out.println("存入redis授权数据...");
        byte[] key = getKey(k);
        byte[] value = SerializationUtils.serialize(v);
        jedisUtil.set(key, value);
        jedisUtil.expire(key, 600);
        return v;
    }

    /** 删除 */
    @Override
    public V remove(K k) throws CacheException {
        byte[] key = getKey(k);
        byte[] value = jedisUtil.get(key);
        jedisUtil.del(key);
        return value == null ? null : (V) SerializationUtils.deserialize(value);
    }

    /** 清除所有（授权）缓存 */
    @Override
    public void clear() throws CacheException {
        Set<byte[]> byteKeys = jedisUtil.keys(SHIRO_CACHE_PREFIX);
        if (!CollectionUtils.isEmpty(byteKeys)) {
            for (byte[] key : byteKeys) {
                jedisUtil.del(key);
            }
        }
    }

    /**（授权）缓存数量 */
    @Override
    public int size() {
        Set<byte[]> byteKeys = jedisUtil.keys(SHIRO_CACHE_PREFIX);
        return byteKeys == null ? 0 : byteKeys.size();
    }

    /** 获取redis中所有key对应的K实例 */
    @Override
    public Set<K> keys() {
        Set<byte[]> byteKeys = jedisUtil.keys(SHIRO_CACHE_PREFIX);
        Set<K> keys = null;
        if (!CollectionUtils.isEmpty(byteKeys)) {
            // byte[]和K之间的转换
            for (byte[] byteKey : byteKeys) {
                K k = (K) new String(byteKey).substring(SHIRO_CACHE_PREFIX.length()).getBytes();
                keys.add(k);
            }
        }
        return keys;
    }

    /** 获取redis中所有缓存实例 */
    @Override
    public Collection<V> values() {
        Set<byte[]> byteKeys = jedisUtil.keys(SHIRO_CACHE_PREFIX);
        Set<V> values = null;
        if (!CollectionUtils.isEmpty(byteKeys)) {
            for (byte[] key : byteKeys) {
                values.add((V) SerializationUtils.deserialize(jedisUtil.get(key)));
            }
        }
        return values;
    }

    /** 计算redis中cache的key */
    private byte[] getKey(K k) {
        /*if (k instanceof String) return (SHIRO_CACHE_PREFIX + k).getBytes();*/
        return (SHIRO_CACHE_PREFIX + new String(SerializationUtils.serialize(k))).getBytes();
    }
}
```

#### 1.2 配置部分

- applicationContext.xml中增加cache包的扫描

```xml
<context:component-scan base-package="..,com.baicai.cache"/>
```

- applicationContext-shiro.xml中配置缓存管理器

```xml
<!-- SecurityManager -->
<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
    <property name="realm" ref="realm"/>
    <property name="sessionManager" ref="sessionManager"/>
    <property name="cacheManager" ref="redisCacheManager"/>
</bean>

...

<!-- Cache管理器 -->
<bean id="redisCacheManager" class="com.baicai.cache.RedisCacheManager"/>
```

#### 1.3 测试

为方便测试，增加标记代码：

- 1.UserDaoImpl中标记从数据库查询认证、授权（角色、权限）信息

```java
public class UserDaoImpl implements UserDao {
    ...

    /** 根据用户名，查询用户 */
    @Override
    public User getUsersByUsername(String username) {
        System.out.println("从数据库获取认证数据...");
        ...
    }

    /** 根据用户名，查询用户角色 */
    @Override
    public List<String> getRolesByUsername(String username) {
        System.out.println("从数据库获取角色数据...");
        ...
    }

    /** 根据角色名，查询角色权限 */
    @Override
    public List<String> getPermissionsByRoles(List<String> roleNames) {
        System.out.println("从数据库获取权限数据...");
        ...
    }
}
```

- 2.RedisCache中标记从redis查询/存入认证、授权（角色、权限）信息

```java
public class RedisCache<K,V> implements Cache<K,V> {
    ...

    /** 取出 */
    @Override
    public V get(K k) throws CacheException {
        System.out.println("从redis获取权限数据...");
        ...
    }

    /** 存入 */
    @Override
    public V put(K k, V v) throws CacheException {
        System.out.println("存入redis权限数据...");
        ...
    }
    ...
}
```

- 3.测试如下

> 认证信息不缓存，只缓存授权相关的角色、权限信息

```
# 登录接口返回：
从数据库获取认证数据...

# 第一次访问http://localhost:9100/testRole
从redis获取权限数据...
从数据库获取角色数据...
从数据库获取权限数据...
存入redis权限数据...

# 第二次访问http://localhost:9100/testRole
从redis获取权限数据...
```

> redis中数据如下

```shell
keys *
1) "shiro-cahce:\xef\xbf\xbd\xef\xbf\xbd\x00\x05sr\x002org.apache.shiro.subject.SimplePrincipalCollection\xef\xbf\xbd\x7fX%\xc6\xa3\bJ\x03\x00\x01L\x00\x0frealmPrincipalst\x00\x0fLjava/util/Map;xpsr\x00\x17java.util.LinkedHashMap4\xef\xbf\xbdN\\\x10l\xef\xbf\xbd\xef\xbf\xbd\x02\x00\x01Z\x00\x0baccessOrderxr\x00\x11java.util.HashMap\x05\a\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\x16`\xef\xbf\xbd\x03\x00\x02F\x00\nloadFactorI\x00\tthresholdxp?@\x00\x00\x00\x00\x00\x0cw\b\x00\x00\x00\x10\x00\x00\x00\x01t\x00\x0bmyJdbcRealmsr\x00\x17java.util.LinkedHashSet\xef\xbf\xbdl\xef\xbf\xbdZ\xef\xbf\xbd\xef\xbf\xbd*\x1e\x02\x00\x00xr\x00\x11java.util.HashSet\xef\xbf\xbdD\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd4\x03\x00\x00xpw\x0c\x00\x00\x00\x02?@\x00\x00\x00\x00\x00\x01t\x00\x04tonyxx\x00w\x01\x01q\x00~\x00\x05x"
2) "shiro-session:f6f8dd6d-3edb-46df-b6e5-bd801bdc6f38"
```

---


# V.RememberMe

## 1.代码部分

- 1.1 修改页面，增加rememberMe选项

```xml
<form action="/login" method="post">
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="password"></td>
        </tr>
        <tr>
            <td>记住我？</td>
            <td><input type="checkbox" name="rememberMe"></td>
        </tr>
        <tr>
            <td><input type="submit" value="登录"></td>
        </tr>
    </table>
</form>
```

- 1.2 User接参修改

```java
public class User {
    private String username;
    private String password;
    private boolean rememberMe;
    ...
}
```

- 1.3 接口修改

> 在token中设置RememberMe

```java
@PostMapping(value = "/login", produces = "application/json;charset=utf-8")
@ResponseBody
public String login(User user) {
    Subject subject = SecurityUtils.getSubject();
    UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());
    token.setRememberMe(user.getRememberMe());
    try {
        subject.login(token);
    } catch (AuthenticationException e) {
        return e.getMessage();
    }
    return "登录成功";
}
```

## 2.配置部分

- aapplicationContext-shiro.xml中配置RememberMe管理器

```xml
<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
    <property name="realm" ref="realm"/>
    <property name="sessionManager" ref="sessionManager"/>
    <property name="cacheManager" ref="redisCacheManager"/>
    <property name="rememberMeManager" ref="cookieRememberMeManager"/>
</bean>

...

<!-- RememberMe -->
<bean id="cookieRememberMeManager" class="org.apache.shiro.web.mgt.CookieRememberMeManager">
    <property name="cookie" ref="simpleCookie"/>
</bean>
<bean id="simpleCookie" class="org.apache.shiro.web.servlet.SimpleCookie">
    <!-- name属性，设置到Cookie中的key -->
    <constructor-arg value="rememberMe"/>
    <!-- 有效期（秒），默认一年 -->
    <property name="maxAge" value="120"/>
</bean>
```

## 3.测试

- 1.访问登录页，不选择“记住我”，登录，查看Cookies（只有JSESSIONID）
- 2.访问http://localhost:9100/testRole，可以访问
- 3.关闭浏览器，重新打开，然后直接访问http://localhost:9100/testRole，不可以访问
- 4.访问登录页，选择“记住我”，登录，查看Cookies（有JSESSIONID和rememberMe）
- 5.访问http://localhost:9100/testRole，可以访问；重启浏览器后，可以直接访问（记住我！）

```
JSESSIONID=e6fb376b-f63a-46d0-91b1-60c19ae54ca2
rememberMe=f5YMCvOUVHxn5p1w1BRY0g6IT4ol8+o2/15y0QWJKzeGnQeR93JxZfmJ4ECNXYnXdzvxKx8QhUjVPS0sNK8YkvDq81BRstEeVB669zruYC5UKCKkj0RQFlHylxYTMDCjBvHn3CK4e7DhEYF9rWhOcgXgmW7rP+COu1JPK9IGAnqRF3zy9LRTvU/mAWWrLhhT2om5E0BOfYDD1jKkxDF4tB6Ygsea2+trpscdNxuCjOYRF1ngkYAqy5XZUPtst+Z50aczPEIZCazpJVlV+fC9z9DajVhQkxbFitkmfWr6uVWww1z8WESrb2Mzw9sy8UayGLMMFFxpi0eZ5WiTMtSfBDUdJqFyKaCk9FQh13Qw9wXW+1SRuZ4SWxS8fhjLCxf1S88VPMtsSZynWS7oJjNAOsxCG+CCxa9a76sfAkxEPg9tp+Lhv1nkodrnYdEzkvMRcLVmM+71qNKPrGFrPVOK7BUMmIW8GaLcDW8aFax4KQi3IxFalcxl+YvwXoy5B20X
```

