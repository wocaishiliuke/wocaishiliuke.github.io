---
title: RabbitMQ入门
date: 2019-04-01 19:01:09
categories:
    - Middleware
tags:
    - RabbitMQ
    - MQ
---

[RabbitMQ](https://www.rabbitmq.com/)是一款开源的、实现AMQP、Erlang编写的消息中间件。其他MQ实现还有ActiveMQ、RocketMQ、Kafka等。本文将根据官方教程，介绍RabbitMQ的基本使用。

##### 目录

+ I.简介
+ II.教程


---
# I.简介

## 1.安装

这里基于Ubuntu 18.04 LTS进行安装，具体参考[Ubuntu环境搭建](https://blog.wocaishiliuke.cn/linux/2018/06/02/Ubuntu01/)。

## 2.管理界面

- 使用默认的guest:guest账户登录localhost:15672
- 创建用户root:root，赋予administrator权限
- 使用root账号登录，创建virtual hosts虚拟主机，命名/vhost_test
- 在User:root中，为其添加可访问/vhost_test

> 在RabbitMQ中，每个virtual host都是一个独立的RabbitMQ服务器，相互之间隔离，exchange、queue、message等不能互通，类似mysql的db。命名一般以/开头。

在Overview的Ports and contexts中，可以看到Rabbit监听的端口：

|Protocol|Bound to|Port|
|:-------|:-------|:---|
|amqp|::|5672|
|clustering（集群）|::|25672|
|http|::|15672|

|Context|Bound to|Port|SSL|Path|
|:------|:-------|:---|:--|:---|
|RabbitMQ Management|0.0.0.0|15672|○|/|

RabbitMQ实现了AMQP，理解AMQP便于学习RabbitMQ：[Understanding AMQP, the protocol used by RabbitMQ](https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/)。

## 3.管理命令

这里简单介绍[rabbitmqctl](https://www.rabbitmq.com/rabbitmqctl.8.html)：RabbitMQ节点的管理工具，更多请查看官网。

```shell
sudo rabbitmqctl list_vhosts
# 查看/vhost_test主机下的队列（不指定-p，默认为/主机）
sudo rabbitmqctl -p /vhost_test list_queues
sudo rabbitmqctl -p /vhost_test list_queues name messages_ready messages_unacknowledged
sudo rabbitmqctl -p /vhost_test list_exchanges
sudo rabbitmqctl -p /vhost_test list_bindings
```

## 4.客户端

RabbitMQ的Java客户端为[rabbitmq-java-client](https://github.com/rabbitmq/rabbitmq-java-client)。RabbitMQ、客户端、JDK的对应关系：

||RabbitMQ|JDK|
|:-|:-----|:--|
|RabbitMQ Java Client 5.x|3.x|Java 8 or higher|
|RabbitMQ Java Client 4.x|3.x|Java 6 or higher|

截至目前，最新的RabbitMQ Java Client是5.7.1。最新的spring-rabbit版本是2.1.6.RELEASE，包含的是
RabbitMQ Java Client 5.4.3和Spring-xxxx-5.1.6.RELEASE。

> 因为服务端版本为：rabbitmq 3.7.15、Erlang 21.3.8.2、JDK8，所以这里可以使用RabbitMQ Java Client5.4.3。

## 5.安装测试

完成服务端安装、账号和虚拟主机配置后，使用Java代码的最简测试Demo如下：

```xml
<dependency>
    <groupId>org.springframework.amqp</groupId>
    <artifactId>spring-rabbit</artifactId>
    <version>2.1.6.RELEASE</version>
</dependency>
```
```java
public class HelloWorld {
    public static void main(String[] args) {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setHost("127.0.0.1");
        connectionFactory.setPort(5672);
        connectionFactory.setUsername("root");
        connectionFactory.setPassword("root");
        connectionFactory.setVirtualHost("/vhost_test");
        AmqpAdmin admin = new RabbitAdmin(connectionFactory);
        admin.declareQueue(new Queue("myqueue"));

        AmqpTemplate template = new RabbitTemplate(connectionFactory);
        template.convertAndSend("myqueue", "foo");
        String foo = (String) template.receiveAndConvert("myqueue");
        System.out.println(foo);
    }
}
```

断点查看控制台和RabbitMQ管理页面，观察测试情况。

## 6.基本概念

- producer：publisher/sender，消息的生产者，类似"发信人"
- consumer：receiver，消息的消费者，类似"收信人"
- [queue](https://www.rabbitmq.com/queues.html)：消息队列，存在RabbitMQ中，"类似邮筒"
- Connection：AMQP0-9-1 Connection，是socket连接的封装，包括协议版本（AMQP0-9-1）、认证等
- Channel：AMQP0-9-1 Channel对象，包含了大部分AMQP操作API
- exchange：RabbitMQ中所有的消息都必须要通过exchange发送到各queue里
    + 默认交换机(unnamed)：隐式地绑定到每个queue，其路由键等于队列名称。无法显式绑定到默认交换器或从默认交换器解绑定，也不能被删除。
- binding：队列和交换机的绑定
- Envelope：信封
- DeliveryTag：对于每个Channel，每条消息都有一个DeliveryTag，一般用接收顺序1,2,3..来表示

> 特点

- 消息由producer产生后，必须经exchange发送到queue，然后由consumer消费
- 虽然消息贯穿RabbitMQ和应用，但消息只能存储在queue（exchange中无法保存）
- 队列的本质是个消息缓冲区（message buffer），只受主机内存和磁盘大小的限制
- 多个生产者可以发消息到同一个queue，多个消费者也可以同时监听同一个queue
- 在RabbitMQ中，消息的获取分为推模式和拉模式，分别对应basicConsume()和basicGet()
    + 推模式：服务端主动推送消息到消费者，消费者在回调方法中处理消息，然后响应服务端
    + 拉模式：消费者每次主动从队列中拉起单条消息消费，然后响应服务端

## 6.常用API

Channel中包含了大部分AMQP操作API，详细可参考[RabbitMQ Java Client API](https://rabbitmq.github.io/rabbitmq-java-client/api/current/)，这里稍作说明。

#### 6.1 Channel.queueDeclare

队列声明

```java
// 声明一个非持久的、排他的、自动删除的队列，名称由rabbitMQ自动生成
Queue.DeclareOk queueDeclare() throws IOException;

/**
 * 声明一个队列
 * @param queue 队列名
 * @param durable 是否持久化（true：持久化，重启后可恢复）
 * @param exclusive 排他性（true：只对当前connection可见，并且当前连接断开后，自动删除该队列）
 * @param autoDelete 是否自动删除（true：没有任何消费者时，被删除）
 * @param arguments 
 */
Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments) throws IOException;
```

#### 6.2 Channel.basicPublish

发布消息到指定交换器

```java
void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;
void basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body) throws IOException;
void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;
```

- exchange：交换机名，""会默认使用"amq.direct"这个exchange（创建queue时，默认会新建一个和queue同名的routingKey绑定到这个默认的exchange上）
- routingKey: 消息到路由键
- mandatory：消息到达交换机后无法路由到队列时的处理方式。true表示如果根据路由key匹配不到队列，将该消息返回给生产者；否则直接丢弃（只有队列才能存储消息）
- immediate：RabbitMQ 3.0+不再支持immediate标志
- props：消息属性，如header、deliveryMode、contentType等
- body：消息

#### 6.3 Channel.basicConsume()

推方式的消息消费。Channel中提供了很多个basicConsume重载方法，这些方法的常有参数如下：
- queue：队列名称
- autoAck：是否自动确认。
    + true：消费者收到消息后自动向服务端发送ack信号，服务端收到该信号后认为消息已被消费，将消息从队列中删除
    + false：需要消费者手动进行ack
- consumerTag：消费者标签，用来区分多个消费者
- noLocal：true表示不能将同一个Connection中生成者生产的消息传递给该Connection中的消费者
- exclusive：是否排他
- arguments：其他结构化参数
- callback：Consumer实现类实例，作用同deliverCallback，用于定义消费消息过程
- deliverCallback：消费者回调函数，在其中处理发送过来的消息
- cancelCallback：消费者取消订阅时的回调方法
- shutdownSignalCallback：channel或者connection关闭时的回调方法

最主要的参数是callback或deliverCallback，包含了消费者消费消息的流程，可以使用Consumer接口、DefaultConsumer类或DeliverCallback接口来实现（即匿名类、自定义实现类、函数式接口等方式）。DefaultConsumer是Consumer接口的实现，官方的解释：是用来缓冲RabbitMQ服务推送的消息。

> 早期版本的QueueingConsumer已过时。

#### 6.4 Channel.basicAck()

```java
/**
 * 确认接收到一个或多个消息
 * @param deliveryTag 消息的运输标签，从Deliver或GetOk中获取
 * @param multiple true：批量确认比deliveryTag小的消息；false只确认当前deliveryTag
 */
void basicAck(long deliveryTag, boolean multiple) throws IOException;
```

#### 6.4 Channel.basicQos()

QoS，quality of service服务质量

> 如果RabbitMQ将生产者发布的大量消息都推送给消费者，可能导致消费者压力过大。为了保证服务质量，RabbitMQ允许消费者对接收的消息进行限制。

```java
/**
 * Request specific "quality of service" settings.
 *
 * These settings impose limits on the amount of data the server
 * will deliver to consumers before requiring acknowledgements.
 * Thus they provide a means of consumer-initiated flow control.
 * @see com.rabbitmq.client.AMQP.Basic.Qos
 * @param prefetchSize 可接收的消息内容大小，0表示无限制
 * @param prefetchCount 可接收的消息最大数（最多可不确认数），0表示无限制
 * @param global true表示该设置作用域整个channel，而不是每一个consumer
 */
void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;
void basicQos(int prefetchCount, boolean global) throws IOException;
void basicQos(int prefetchCount) throws IOException;
```

#### 6.5 

队列和交换机的绑定

```java
/**
 * 绑定queue和exchange
 * @param queue 队列名
 * @param exchange 交换机名
 * @param routingKey 用于绑定的routing key
 */
Queue.BindOk queueBind(String queue, String exchange, String routingKey) throws IOException;

/**
 * 绑定queue和exchange
 * @param queue 队列名
 * @param exchange 交换机名
 * @param routingKey 用于绑定的routing key
 * @param arguments 其他绑定参数
 */
Queue.BindOk queueBind(String queue, String exchange, String routingKey, Map<String, Object> arguments) throws IOException;
```


---
# II.教程

官方提供了[RabbitMQ Tutorials](https://www.rabbitmq.com/getstarted.html)，包含6种模式，代码可参考[rabbitmq/rabbitmq-tutorials](https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java)。

- Hello World：入门
- Work queues：each task is delivered to exactly one worker
- publish/subscribe：deliver a message to multiple consumers

教程只是入门，更多需要参考[Documentation](https://www.rabbitmq.com/documentation.html)、[Publisher Confirms and Consumer Acknowledgements](https://www.rabbitmq.com/confirms.html)、[Production Checklist](https://www.rabbitmq.com/production-checklist.html)、[Monitoring](https://www.rabbitmq.com/monitoring.html)。

> 官方使用SLF4j作为测试日志，但生产环境推荐Logback。

## 1.Hello World

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_hello.png)

#### 1.1 代码

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.4.3</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
</dependency>
```
```java
log4j.rootLogger=DEBUG,A1
log4j.logger.com.taotao = DEBUG
log4j.logger.org.mybatis = DEBUG

log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
```
```java
public class ConnectionUtil {
    public static Connection getConnection() throws IOException, TimeoutException {
        // 连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        // 获取连接
        factory.setHost("localhost");
        factory.setPort(5672);
        factory.setVirtualHost("/vhost_test");
        factory.setUsername("root");
        factory.setPassword("root");
        return factory.newConnection();
    }
}
```
```java
// 生产者
public class Send {
    private final static String QUEUE_NAME = "hello";
    public static void main(String[] argv) throws Exception {
        try (// 获取连接和通道，两者实现了Closeable(extends AutoCloseable)，会自动关流
             Connection connection = ConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            // 声明要发布到的队列
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            // 发布消息
            String message = "Hello World!";
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            System.out.println(" [x] Sent '" + message + "'");
        }
    }
}
```

> basicPublish的第一个参数""，表示使用默认的exchange，其routingKey为QUEUE_NAME（和queue同名）。

```java
// 消费者
public class Recv {
    private final static String QUEUE_NAME = "hello";
    public static void main(String[] argv) throws Exception {
        // 获取到连接和通道
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();
        // 声明要消费的队列，和Send中的对应
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
        // 消费
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");
        };
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });// true表示自动确认Ack
    }
}
```

> 这里消费也可以使用上述basicConsume的重载方法：

```java
channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, "UTF-8");
        System.out.println(" [x] Received '" + message + "'");
    }
});
```

#### 1.2 测试

可以先启动Recv，然后再启动Send发送消息；也可以先启动Send发送消息，再启动Recv，此时会消费掉全部消息（推模式）。通过查看控制台和UI管理界面，查看测试结果。

#### 1.3 要点

- 声明队列是幂等的：只有不存在时才会新建
- Recv没有使用try-with-resource，是因为消费者需要保持该process持续异步的监听消息
- RabbitMQ消费者可以使用推/拉模式来消费消息，这里使用推模式（拉模式用basicGet）
- 消息内容是字节数组，可以灵活的使用编码
- deliverCallback回调包含了消费消息的过程，consumerTag -> { }取消订阅时的回调函数

## 2.Work Queues

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_work.png)

#### Preparation

官方教程中Work Queues的前期准备和hello world几乎一样，这里直接讲述轮询分发。

#### Round-robin dispatching

**轮询分发**：RabbitMQ默认按顺序逐条将消息发送给消费者，每个消费者平均得到的消息数相同。

> 示例：在hello world基础上修改。使用一个生产者每隔一秒发布一条消息，消息中的dot数体现了处理该消息所需的时间，比如'.'需要1s，'..'需要2s。使用两个消费者接收消息。

```java
// 生产者
public class WorkQueuesSend {
    public static void main(String[] argv) throws Exception {
        try (Connection connection = ConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            channel.queueDeclare("hello", false, false, false, null);
            // 每隔一秒发布一条消息
            String s = "";
            for (int i = 0; ; i++) {
                String message = i + s;
                channel.basicPublish("", TASK_QUEUE_NAME, null, message.getBytes("UTF-8"));
                System.out.println(" [x] Sent '" + message + "'");
                s = s + ".";
                Thread.sleep(1000);
            }
        }
    }
}
```
> 这里使用的也是默认exchange。

```java
// 消费者1
public class WorkQueuesRecv1 {
    public static void main(String[] argv) throws Exception {
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare("hello", false, false, false, null);
        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");
            try {
                doWork(message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(" [x] Done");
            }
        };
        channel.basicConsume("hello", true, deliverCallback, consumerTag -> { });
    }

    private static void doWork(String task) throws InterruptedException {
        for (char ch: task.toCharArray()) {
            if (ch == '.') Thread.sleep(1000);
        }
    }
}
```
```java
// 消费者2
public class WorkQueuesRecv2 {
    // 同上
}
```

> 测试：先开启两个消费者，再开启生产者

```
// C1
[*] Waiting for messages. To exit press CTRL+C
[x] Received '0'
[x] Done
[x] Received '2..'
[x] Done

// C2
[*] Waiting for messages. To exit press CTRL+C
[x] Received '1.'
[x] Done
[x] Received '3...'
[x] Done
```

虽然两个消费者处理消息的时间都逐渐变长，但两者**均匀地**消费了producer发布的消息。
- C1消费完成后自动autoAck
- 服务端收到确认信号后，删除该条消息，然后将下一条消息推给C2

> 三个或更多Consumer的情形相似，也是均匀消费。

#### Message acknowledgment

如果RabbitMQ将消息推送给某个consumer（worker）后，立刻将该消息从队列中删除，那么当该consumer宕机或其他消费失败的情况出现时，该消息（task）在没有被真正执行前，就不复存在了。理论上是希望所有的消息都能被执行，如果C1宕机，应该推送给C2消费。

为了确保消息永远不会丢失，RabbitMQ支持**消息确认[message acknowledgments](https://www.rabbitmq.com/confirms.html)**。consumer会发送一个ack(nowledgement)，通知RabbitMQ消息已经被接收和执行，服务端可以执行删除操作。

如果consumer在不发送ack的情况下宕机（channel关闭、connection关闭或TCP连接丢失），RabbitMQ将认为该消息没有被完全处理，并将re-queue该消息。如果有其他consumer在线，会很快将其发送给另一个consumer。这样可以确保信息不丢失。

**没有消息超时**，consumer处理消息的时间可以很长。consumer当宕机时，RabbitMQ会重新传递消息。

RabbitMQ默认需要手动消息确认（上述示例中，都使用了autoAck=true自动确认），当执行完任务（消息）后，worker需要返回信息。将WorkQueuesRecv1修改为手动确认如下：

```java
DeliverCallback deliverCallback = (consumerTag, delivery) -> {
    String message = new String(delivery.getBody(), "UTF-8");
    System.out.println(" [x] Received '" + message + "'");
    try {
        doWork(message);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println(" [x] Done");
        // 执行任务后，返回ack确认
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    }
};
// 开启手动确认
boolean autoAck = false;
channel.basicConsume("hello", autoAck, deliverCallback, consumerTag -> { });
```

> Ack必须使用和发送消息的同一个channel否则会导致一个channel层的协议异常

如果C1执行完任务，忘记basicAck就断开连接，那么C1执行的Messages会被redelivered，并且不会出队，RabbitMQ就会占用越来越多的内存。可以使用rabbitmqctl查看unacknowledged messages：

```shell
sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
```

#### Message durability

上述Message acknowledgment，能够确保即使consumer宕机，task也不会丢失。但如果是RabbitMQ服务端宕机，就需要对**queue和messages都使用持久化**，才能保证消息不会丢失。

- queue durable

```java
boolean durable = true;
channel.queueDeclare("hello", durable, false, false, null);
```

这段代码的修改本身没有错。但由于之前的程序运行后，名称为TASK_QUEUE_NAME的queue已经存在，并且是非持久化的。RabbitMQ不允许使用不同的参数重新定义已经存在的queue，会返回error。所以可以让producer和consumers都使用新的队列：

```java
boolean durable = true;
channel.queueDeclare("task_queue", durable, false, false, null);
```

- message durable

MessageProperties实现了BasicProperties接口。

```java
channel.basicPublish("", "task_queue", MessageProperties.PERSISTENT_TEXT_PLAIN,  message.getBytes());
```

> 测试

```shell
sudo service rabbitmq-server restart
```

**RabbitMQ的消息持久化并不完全可靠**。在RabbitMQ刚接收到消息还未保存到磁盘期间，虽然间隔可能很短，但此时服务宕机就会丢失消息。另外，RabbitMQ不会为每条message都执行fsync(2)，此时只是将消息写到了缓冲区，并未写到disk，如果OS出现文件，也会丢失（和Redis的AOF类似，Redis通过增加同步频率appendfsync来缓解该问题）。如果需要更可靠的保证，可以使用publisher confirms。

#### Fair dispatch

公平分发（多劳多得）

假设上述示例中，"奇数消息"的task都很繁重，"偶数消息"的task都很轻松，就会导致C1很忙，而C2很轻松。因为：**当一条消息发布到RabbitMQ时，RabbitMQ不会检查consumer的unacknowledged messages数，而是直接将n-th消息分发给n-th消费者**。可以使用以下方式实现公平分发：

```java
int prefetchCount = 1;
channel.basicQos(prefetchCount);
```

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_work_fair.png)

修改后的consumer：

```java
public class WorkQueuesRecv1 {
    private static final String TASK_QUEUE_NAME = "task_queue";
    public static void main(String[] argv) throws Exception {
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();
        // 队列持久化
        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);
        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        // 同时只能消费一条消息
        channel.basicQos(1);

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");
            try {
                doWork(message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(" [x] Done");
                // 手动确认
                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
            }
        };
        // 开启手动确认
        channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -> { });
    }

    private static void doWork(String task) throws InterruptedException {
        for (char ch: task.toCharArray()) {
            if (ch == '.') Thread.sleep(1000);
        }
    }
}
```
```java
public class WorkQueuesRecv2 {
    private static final String TASK_QUEUE_NAME = "task_queue";
    public static void main(String[] argv) throws Exception {
        Connection connection = ConnectionUtil.getConnection();
        Channel channel = connection.createChannel();
        // 队列持久化
        channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);
        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        // 同时只能消费一条消息
        channel.basicQos(1);

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");
            try {
                doWork(message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(" [x] Done");
                // 手动确认
                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
            }
        };
        // 开启手动确认
        channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -> { });
    }

    private static void doWork(String task) throws InterruptedException {
        for (char ch: task.toCharArray()) {
            // C2消费能力更强，公平分发后处理的消息也就更多
            if (ch == '.') Thread.sleep(100);
        }
    }
}
```

> 当然如果所有worker都很繁重，queue就会被填满。可以添加更多的worker或其他方法来避免。


## 3.Publish/Subscribe

#### Exchanges

之前的两个示例中，虽然都没有显示地提到exchange，但都使用了默认exchange。实际上，**在RabbitMQ中，producer只能将message发送到exchange**。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_exchange.png)

- 交换机用来接收message并推送到queue
- 交换机的工作方式由其类型决定：direct、topic、headers、fanout

Publish/Subscribe模式使用比较简单的fanout交换机：将收到的所有消息广播给绑定的所有queue。

> fanout交换机的声明和使用

```java
// 声明名为logs的fanout交换机
channel.exchangeDeclare("logs", "fanout");
...
// 发布消息到指定交换机（由于fanout交换机会忽略routingKey，这里使用""）
channel.basicPublish( "logs", "", null, message.getBytes());
```

> 查看交换机

```shell
$ sudo rabbitmqctl list_exchanges
Listing exchanges for vhost / ...
name    type
amq.headers headers
amq.fanout  fanout
amq.direct  direct
amq.topic   topic
amq.rabbitmq.trace  topic
amq.match   headers
    direct
```

> 无名交换机

即默认交换机，hello world和work queues模式中使用的

```java
channel.basicPublish("", "hello", null, message.getBytes());
```

#### Temporary queues

之前的hello world和work queues模式中，一个queue由多个producer和consumer共享，需要指定队列名。但Publish/Subscribe模式中不同：
- 首先，当连接到Rabbit时，需要的是一个新的空queue，此时可以创建一个随机名称的queue，或让服务端给出随机名称
- 其次，当consumer和queue断开连接时，需要自动删除queue

在Java client中，声明一个non-durable、exclusive、autodelete的queue，并自动生成一个名称：
```java
// queueName包含了一个随机队列名，如amq.gen-JzTY20BRgKO-HjmUJj0wLg
String queueName = channel.queueDeclare().getQueue();
```

Queue的常见属性如下，详细的说明可参考[Queues](https://www.rabbitmq.com/queues.html)。
- Name：队列名
- Durable：持久化
- Exclusive：只被一个connection使用，并且该链接断开时，该队列也自动删除
- Auto-delete (queue that has had at least one consumer is deleted when last consumer unsubscribes)
- Arguments：可选参数，用于指定message TTL、队列长度限制等

#### Bindings

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_bindings.png)

在创建了fanout exchange和queue后，需要将交换机和队列进行绑定，告诉该交换机发送消息到该队列。

```java
// 交换机和队列绑定
channel.queueBind(queueName, "logs", "");
```

```shell
# 查看绑定列表
sudo rabbitmqctl list_binding
```

完整的代码：

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_ps.png)

```java
// producer
public class EmitLog {
    private static final String EXCHANGE_NAME = "logs";
    public static void main(String[] argv) throws Exception {
        try (Connection connection = ConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            // 声明交换机
            channel.exchangeDeclare(EXCHANGE_NAME, "fanout");
            // 发布消息
            String s = "";
            for (int i = 0; ; i++) {
                String message = i + s;
                channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8"));
                System.out.println(" [x] Sent '" + message + "'");
                s = s + ".";
                Thread.sleep(1000);
            }
        }
    }
}
```
> 生产者发送消息到logs交换机，不再是默认的nameless交换机。另外生产者没有声明queue，所以如果先启动EmitLog，消息会丢失直到ReceiveLog将队列绑定到交换机为止。

```java
// consumer1
public class ReceiveLog1 {
    private static final String EXCHANGE_NAME = "logs";
    public static void main(String[] argv) throws Exception {
        final Connection connection = ConnectionUtil.getConnection();
        final Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");
        // 主动声明一个server-named、exclusive、autodelete、non-durable的queue
        String queueName = channel.queueDeclare().getQueue();
        channel.queueBind(queueName, EXCHANGE_NAME, "");

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" + message + "'");
        };
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});
    }
}
```
```java
// consumer2
public class ReceiveLog1 {
    // 同上
}
```
> 当没有consumer监听时，即没有queue绑定到exchange，消息会丢失。由于exclusive为true，consumer断开连接后，消息也会丢失。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_ps_bind.png)

## 4.Routing

在Publish/Subscribe中的log示例，将所有（未丢失的）消息广播给所有消费者。Routing模式是在Publish/Subscribe的基础上，允许消费者根据需要订阅部分消息，如只消费error消息（写到磁盘）。

#### Bindings

在Publish/Subscribe中也有绑定操作：

```java
// 将queue和exchange绑定，binding key为空（即使不为空，fanout类型的交换机也会忽略该参数）
channel.queueBind(queueName, EXCHANGE_NAME, "");
```

想要只消费部分消息，就需要指定binding key，用来匹配消息的routing key：

```java
channel.queueBind(queueName, EXCHANGE_NAME, "black");
```

#### Direct exchange

fanout exchange会忽略routing key和binding key（mindless broadcasting），所以还需要使用新类型的交换机：direct。Direct exchange的路由算法很简单：**比较消息的routing key和队列的binding key，相同时就将消息路由到该队列，而未匹配到队列的消息将被丢弃**。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_direct_exchange.png)

上图中，交换机X和队列Q1、Q2进行了绑定。Q1只有一个orange的绑定，而Q2有两个绑定black和green。

#### Multiple bindings

Direct exchange在下面特殊情况中类似于fanout exchange：routing key为black的消息，都会被同时广播到Q1和Q2。

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_direct_exchange_multiple.png)

#### 完整示例

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_routing.png)

```java
public class EmitLogDirect {
    private static final String EXCHANGE_NAME = "direct_logs";
    public static void main(String[] argv) throws Exception {
        try (Connection connection = ConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            // 声明交换机
            channel.exchangeDeclare(EXCHANGE_NAME, "direct");
            // 发布消息
            for (int i = 1;; i++) {
                String severity = getSeverity();
                String message = severity + "-" + i;
                // 发布时，设置消息的routing key
                channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes("UTF-8"));
                System.out.println(" [x] Sent '" + severity + "':'" + message + "'");
                Thread.sleep(1000);
            }
        }
    }

    public static String getSeverity() {
        String[] str = {"error", "warning", "info"};
        int random = (int) (Math.random() * 3);
        return str[random];
    }
}
```
```java
public class ReceiveLogDirect1 {
    private static final String EXCHANGE_NAME = "direct_logs";
    public static void main(String[] argv) throws Exception {
        final Connection connection = ConnectionUtil.getConnection();
        final Channel channel = connection.createChannel();
        // 声明exchange和queue
        channel.exchangeDeclare(EXCHANGE_NAME, "direct");
        String queueName = channel.queueDeclare().getQueue();
        // binding
        channel.queueBind(queueName, EXCHANGE_NAME, "error");
        // 消费
        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" +
                    delivery.getEnvelope().getRoutingKey() + "':'" + message + "'");
        };
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});
    }
}
```
```java
public class ReceiveLogDirect1 {
    private static final String EXCHANGE_NAME = "direct_logs";
    public static void main(String[] argv) throws Exception {
        ...
        // binding，多个binding key，需要绑定多次
        String[] str = {"error", "warning", "info"};
        for (String severity : str) {
            channel.queueBind(queueName, EXCHANGE_NAME, severity);
        }
        ...
    }
}
```

> UI管理界面和终端中，查看bindings

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_routing_bindings.png)

```shell
sudo rabbitmqctl -p /vhost_test list_bindings
Listing bindings for vhost /vhost_test...
source_name source_kind destination_name    destination_kind    routing_key arguments
    exchange    amq.gen-Fg0IRT-IDlAwY-Fo00uAag  queue   amq.gen-Fg0IRT-IDlAwY-Fo00uAag  []
    exchange    myqueue queue   myqueue []
    exchange    task_queue  queue   task_queue  []
    exchange    hello   queue   hello   []
    exchange    amq.gen-qVH3VuotfAdGDSKHIQjJjQ  queue   amq.gen-qVH3VuotfAdGDSKHIQjJjQ  []
direct_logs exchange    amq.gen-Fg0IRT-IDlAwY-Fo00uAag  queue   error   []
direct_logs exchange    amq.gen-qVH3VuotfAdGDSKHIQjJjQ  queue   error   []
direct_logs exchange    amq.gen-Fg0IRT-IDlAwY-Fo00uAag  queue   info    []
direct_logs exchange    amq.gen-Fg0IRT-IDlAwY-Fo00uAag  queue   warning []
```

## 5.Topics

在Routing中，使用了direct exchange解决了fanout exchange的"傻瓜式广播"，可以选择性的接收部分消息。

但有时需要同时根据多个条件，如日志级别（info/warn/error...）和日志来源（auth/cron/kern...）来路由消息。比如C1只需要监听来自cron的error日志。

#### Topic exchange

发送到topic exchange中的消息，不再拥有简单的routing key，而是一组dot分割的词组words（一般使用描述消息特性的词语组成）。如"quick.orange.rabbit"、"cron.error"等。词组个数随意，大小不超过255字节。

队列的binding key也要使用相同的格式。Topic exchange的匹配规则和direct exchange的类似，匹配的消息将被路由到对应队列，未匹配到队列的消息将被丢弃。不过相比于direct exchange，Topic exchange中的binding keys可以使用通配符：
- \*（star）代表一个word
- #（hash）代表0个或多个word

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_topic_exchange.png)

上图中的routing key词组，包含三个词：speed.colour.species。其中：
- Q1只关注orange animals
- Q2关注所有rabbits和所有lazy animals
例如：
- "quick.orange.rabbit"消息和"lazy.orange.elephant"消息都将被同时广播到Q1和Q2
- "quick.orange.fox"只会被分配到Q1，"lazy.brown.fox"只会被分配到Q2
- "lazy.pink.rabbit"尽管匹配了Q2的两个binding，但只会发送到Q2一次
- "quick.brown.fox"没有匹配到任何binding，将会被丢弃
- "orange"和"quick.orange.male.rabbit"也将会被丢弃
- "lazy.orange.male.rabbit"尽管是四个词，但会被匹配到Q2

Topic exchange功能更灵活，也可以用来实现另两种exchange。当某队列的binding key：
- 是"#"时，该队列将接收所有消息，相当于忽略routing key，相当于fanout exchange
- 没有使用通配符"*"和"#"时，相当于direct exchange

#### 完整示例

```java
public class EmitLogTopic {
    private static final String EXCHANGE_NAME = "topic_logs";
    public static void main(String[] argv) throws Exception {
        try (Connection connection = ConnectionUtil.getConnection();
             Channel channel = connection.createChannel()) {
            // 声明交换机
            channel.exchangeDeclare(EXCHANGE_NAME, "topic");
            // 发布消息
            for (int i = 1;; i++) {
                String routingKey = getRoutingKey();
                String message = routingKey + "-" + i;
                channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("UTF-8"));
                System.out.println(" [x] Sent '" + routingKey + "':'" + message + "'");
                Thread.sleep(1000);
            }
        }
    }

    public static String getRoutingKey() {
        String[] facilities = {"kern", "cron", "auth"};
        String[] severities  = {"error", "warning", "info"};
        return facilities[(int) (Math.random() * 3)] + "." + severities[(int) (Math.random() * 3)];
    }
}
```
```java
public class ReceiveLogTopic1 {
    private static final String EXCHANGE_NAME = "topic_logs";
    public static void main(String[] argv) throws Exception {
        final Connection connection = ConnectionUtil.getConnection();
        final Channel channel = connection.createChannel();

        // 声明exchange和queue
        channel.exchangeDeclare(EXCHANGE_NAME, "topic");
        String queueName = channel.queueDeclare().getQueue();

        // binding
        channel.queueBind(queueName, EXCHANGE_NAME, "*.error");

        System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Received '" +
                    delivery.getEnvelope().getRoutingKey() + "':'" + message + "'");
        };
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});
    }
}
```
```java
public class ReceiveLogTopic2 {
    private static final String EXCHANGE_NAME = "topic_logs";
    public static void main(String[] argv) throws Exception {
        ...
        // binding
        String[] str = {"auth.#", "cron.error"};
        for (String bindingKey : str) {
            channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);
        }
        ...
    }
}
```

> UI管理界面和终端中，查看bindings

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Middleware/RabbitMQ/rabbitmq_topic_bindings.png)

```shell
$ sudo rabbitmqctl -p /vhost_test list_bindings
Listing bindings for vhost /vhost_test...
source_name source_kind destination_name    destination_kind    routing_key arguments
    exchange    amq.gen--xmXDOzvXmwbFWO-yBOBCQ  queue   amq.gen--xmXDOzvXmwbFWO-yBOBCQ  []
    exchange    myqueue queue   myqueue []
    exchange    task_queue  queue   task_queue  []
    exchange    hello   queue   hello   []
    exchange    amq.gen-DvWZIz-lJzuj82EeXrdkNQ  queue   amq.gen-DvWZIz-lJzuj82EeXrdkNQ  []
topic_logs  exchange    amq.gen-DvWZIz-lJzuj82EeXrdkNQ  queue   *.error []
topic_logs  exchange    amq.gen--xmXDOzvXmwbFWO-yBOBCQ  queue   auth.#  []
topic_logs  exchange    amq.gen--xmXDOzvXmwbFWO-yBOBCQ  queue   cron.error  []
```