---
title: Spring入门（二）
date: 2018-08-22 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Java
---

本文延续[Spring入门（一）](http://blog.wocaishiliuke.cn/spring/2018/08/21/Spring01/)，将介绍Spring另一核心AOP。

<!-- more -->

##### 目录
+ I.AOP简介
+ II.静态代理
+ III.动态代理
+ IV.Spring1.2 AOP
+ V.Spring2.0 AOP
+ VI.代理切换
+ VII.参考

---

# I.AOP简介

- Aspect-Oriented Programming（AOP）面向切面编程
- Object-Oriented Programming（OOP）面向对象编程 

**AOP通过不同的编程思想，完成对OOP的补充。OOP的模块化单元是类class，而AOP的模块化单元是切面aspect**。AOP符合OCP原则（open for extension but closed for modifications）。

**AOP也是种编程思想。与OOP中继承的耦合编码方式不同，AOP采取横向抽取机制，多用于性能监视、事务管理、权限控制、缓存、日志记录等**。

> 两种增强方式：

||实现方式|关系|优缺点|
|:--|:---|:--|:----|
|继承方式的增强|方法重写、增加新方法|纵向，父子关系|代码侵入，耦合度高|
|AOP方式的增强|动态代理完成增强|横向，兄弟关系|代码非侵入，耦合度低|

通俗地讲，AOP基于动态代理机制，为目标对象，创建代理对象。在不修改目标对象代码的情况下，通过代理对象调用增强代码，完成对目标对象原有功能的增强

> IoC和AOP是Spring两个核心。IoC并不依赖AOP，AOP提供了一种中间件解决方式，对IoC进行补充。

## 1.AOP编程方式

Spring1.2开始支持AOP APIs编程，不需要专门的编译过程和类加载器（Java实现），在运行期通过代理方式向目标类植入增强代码，但编程复杂。Spring2.0开始支持基于Java的第三方AOP框架AspectJ，编程简单，官方推荐。

所以两种编程方式：

- Spring1.2：[Spring AOP APIs](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#aop-api)
- Spring2.0：[schema-based and @AspectJ-based AOP](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#aop)

> 不论是Spring1.2 AOP还是Spring2.0 AOP，面向切面编程的开发步骤都是：

- 1、确定目标对象（target）（交由spring管理的bean）
- 2、编写Advice类 （增强代码）
- 3、配置切入点和切面 （将Advice作用于target）

## 2.AOP概念

|概念|说明|
|：--|：--|
|Target（目标对象）|被代理的目标|
|Joinpoint（连接点）|目标对象中的方法|
|Pointcut（切入点）|指要对哪些joinpoint进行拦截和增强|
|Advice（通知）|即增强，对Pointcut要做的事情|
|Aspect（切面）|Advice+Pointcut，定义了在何处（Pointcut）做何增强（Advice）|
|Weaving（织入）|把Aspect应用到Target，创建代理对象的过程|
|Introduction（引入）|不修改代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field|

- Spring只支持方法类型的连接点。即AOP的最小操作单位是方法，不支持方法内的增强
- 增强分为前置通知、后置通知、异常通知、最终通知、环绕通知

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/aop-example.png)


---

# II.静态代理

在讲述动态代理前，先叙述下静态代理，便于对比。

**静态代理类是个真实的类，即在编码阶段需要编写完成**。

一般直接调用目标类即可，使用代理一般有两种情况：
- 1.调用者无法直接访问目标类。此时代理类扮演类似跳板或防火墙的角色，代替目标类或对调用者进行权限控制（也是种增强）等
- 2.对目标类增强

## 示例

现有消息推送接口MessagePush，短信消息推送SmsMessagePush是其实现类。

```java
public interface MessagePush {
    public void push(String receiver, String msg);
}
```

```java
public class SmsMessagePush implements MessagePush {
    @Override
    public void push(String receiver, String msg) {
        //do push
    }
}
```

现在要求在发送短信前，进行手机号校验（即增强），此时需要代理类：

```java
public class SmsMessagePushProxy implements MessagePush {

    private SmsMessagePush smsMessagePush;

    public SmsMessagePushProxy(SmsMessagePush smsMessagePush) {
        this.smsMessagePush = smsMessagePush;
    }

    @Override
    public void push(String mobile, String msg) {
        if (!checkMobile(mobile)){ return; }
        smsMessagePush.push(mobile, msg);
    }

    private Boolean checkMobile(String mobile) { //do check }
}
```

调用者：

```java
public void test() {
    SmsMessagePushProxy proxy = new SmsMessagePushProxy(new SmsMessagePush());
    proxy.push("15211111111", "还钱！");
}
```

**静态代理是在编码阶段就写好的，动态代理是在运行时通过类反射动态创建的**。


---

# III.动态代理

AOP会为目标对象创建代理对象。Spring AOP基于两种动态代理实现：JDK动态代理、CGLIB动态代理

> 动态代理和静态代理 

- 动态代理：运行时动态生成代理类，并不是真正存在的类，格式一般为：Proxy$$（Proxy$$Customer）
- 静态代理：实际存在的代理类（例如：struts2中Action的代理类ActionProxy、struts2的拦截器）

## 1.JDK动态代理

JDK动态代理，是对**目标对象的接口**进行代理，使用**JDK提供的Proxy类**，通过newProxyInstance()为目标对象创建代理对象（接口的实现类），目标类和代理类是兄弟关系。

缺点：不能直接代理目标类。**如果没有接口，就不能使用JDK动态代理**

JDK动态代理涉及的类主要放在java.lang.reflect下（由此可见是基于反射实现的）。主要涉及两个类:调用处理器java.lang.reflect.InvocationHandle和主类java.lang.reflect.Proxy。其中InvocationHandler接口只定义了一个方法：

```java
public interface InvocationHandler {
    //执行委托对象的具体方法
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

Proxy类中有很多静态方法，最常用的一个方法是newProxyInstance：

```java
/**
* 返回指定接口的代理类实例，将方法调用分派到指定的调用处理程序h
* loader：代理类的类加载器
* interfaces：代理类要实现的接口列表
* h：代理后的处理程序
*/
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException {
     ...
}
```

查看Proxy.newProxyInstance()源码可知，该方法相当于：

```java
Proxy.getProxyClass(loader, interfaces).getConstructor(new Class[] { InvocationHandler.class }).newInstance(new Object[] { handler });
```

关于动态代理的实现原理可参考[这篇文章](http://blog.jobbole.com/104433/)。

#### 1.1 示例

目标对象中有save()和find()。要求：在执行save()时，记录日志。

> a.创建目标类和其接口

```java
//JDK代理，目标类必须要有接口
public interface CustomerService {
    void save();
    int find();
}
```

```java
public class CustomerServiceImpl implements CustomerService {
    @Override
    public void save() {
        System.out.println("客户保存了...");
    }

    @Override
    public int find() {
        System.out.println("客户查询了...");
        return 100;
    }
}
```

> b.进行增强

这里使用工厂模式：创建代理工厂 + 并提供获取代理对象的方法。这样复用性高。

代理工厂有3种方案完成JDK动态代理，实际是"为接口创建实例"的3种方式，大同小异，匿名内部类更优雅。

###### 方式1.匿名内部类

创建InvocationHandler接口的匿名内部类

```java
public class JdkProxyFactory /*implements InvocationHandler*/ {
    //目标对象
    private Object target;
    
    //有参构造（用setter也可以）
    public JdkProxyFactory(Object target) { this.target = target; }
    
    //提供获取代理对象的方法
    public Object getProxyInstance() {
        //参数1：目标对象的类加载器；参数2：目标对象实现的接口；参数3：回调方法对象
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            //proxy：代理对象；method：代理对象中与目标对象对应的方法(对象)；args：方法参数
            public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
                //日志记录增强
                if ("save".equals(method.getName())) {
                    System.out.println("记录日志...");
                }
                //调用目标对象的原有方法，并且返回返回值
                Object object = method.invoke(target, args);
                return object;
            }
        });
    }
}
```

###### 方式2.自定义InvocationHandler接口实现类

自定义InvocationHandler接口内部实现类

```java
public class JdkProxyFactory /*implements InvocationHandler*/ {
    //目标对象
    private Object target;
    
    //有参构造（如果不用有参构造传入目标对象，用setter也行）
    public JdkProxyFactory(Object target) {
        this.target = target;
    }
    
    //提供获取代理对象的方法
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new MyInvocationHandler());
    }

    //自定义InvocationHandler接口实现类（private不能修饰类，但可以修饰内部类）
    private class MyInvocationHandler implements InvocationHandler {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            //日志记录增强
            if ("save".equals(method.getName())) {
                System.out.println("记录日志...");
            }
            //调用目标对象的原有方法，并且返回返回值
            return method.invoke(target, args);
        }
    }
}
```

###### 方式3.直接实现InvocationHandler接口

代理工厂直接实现InvocationHandler接口。

```java
public class JdkProxyFactory implements InvocationHandler {
    //目标对象
    private Object target;
    
    //有参构造（如果不用有参构造传入目标对象，用setter也行）
    public JdkProxyFactory(Object target) {
        this.target = target;
    }
    
    //提供获取代理对象的方法
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("save".equals(method.getName())) {
            System.out.println("记录日志...");//日志记录增强
        }
        Object object = method.invoke(target, args);//目标对象的原有方法，并且返回返回值
        return object;
    }
}
```

> c.测试

```java
@Test
public void testJdkProxy() {
    //目标对象
    CustomerService target = new CustomerServiceImpl();
    //代理工厂                 
    JdkProxyFactory proxyFactory = new JdkProxyFactory(target);
    //代理对象            
    CustomerService proxy = (CustomerService)proxyFactory.getProxyInstance();
    
    proxy.save();
    System.out.println("-----------------------------");
    proxy.find();
}
```

> d.结果

```java
记录日志...
客户保存了...
-----------------------------
客户查询了...
```

> e.断点查看

```java
proxy = {$Proxy4@795} "com.baicai.service.CustomerServiceImpl@e45f292"
 h = {JdkProxyFactory$1@793} 
  this$0 = {JdkProxyFactory@784} 
   target = {CustomerServiceImpl@783} 
```

代理类proxy={$Proxy4@795}和目标类target={CustomerServiceImpl@783}，是兄弟关系。

#### 1.2 结论

**JDK代理是对接口进行代理，代理类是目标接口的实现类，与目标类是兄弟关系。所以代理类中也有save,find方法。只不过只对save()增强了，而find()不变**。相当于（动态生成的，并非真正存在该类）：

```java
//JDK代理类伪代码
class $Proxy4 implements CustomerService {

    ICustomerService customerService = new CustomerServiceImpl(); 

    public void save() {
        writeLog()
        customerService.save();
    }

    public int find() { return customerService.find(); }

    private static void writeLog(){ System.out.println("记录日志了..."); }
}
```

## 2.CGLIB动态代理

[CGLIB](https://github.com/cglib/cglib)(Code Generation Library)是开源的Java字节码生成API类库，它可以在运行期扩展Java类与实现Java接口。常用于AOP、testing、data access frameworks。

引入CGLIB就是为了解决类的直接代理问题。即CGLIB不需要接口也可以代理。

> spring-core中已经包含了CGLIB，和CGLIB依赖的asm包（动态字节码的操作类库） 

#### 2.1 示例

需求同上：目标对象中有save()和find()。在执行save()时，记录日志。

> a.引入依赖，创建目标类（**不创建接口**）

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
```

```java
public class ProductServiceImpl {
    public void save() {
        System.out.println("商品保存了...");
    }

    public int find() {
        System.out.println("商品查询了...");
        return 22;
    }
}
```

> b.进行增强

同样使用工厂模式。使用CGLIB提供的Enhancer类来获取增强后的代理对象。

```java
public class CglibProxyFactory {
    //目标对象
    private Object target;
    
    //有参构造（setter也行）
    public CglibProxyFactory(Object target) { this.target = target; }
    
    //获取代理对象
    public Object getProxyInstance(){
        //1.使用代理对象生成器(工厂思想)
        Enhancer enhancer = new Enhancer();
        //2.在增强器上设置两个属性
        //设置目标对象
        enhancer.setSuperclass(target.getClass());
        //设置回调方法
        enhancer.setCallback(new MethodInterceptor() {
            /* proxy：代理对象、method：目标对象的方法对象；
            *  arg：方法对象的实参、methodProxy：代理对象的方法对象*/
            @Override
            public Object intercept(Object proxy, Method method, Object[] arg, MethodProxy methodProxy) throws Throwable {
                if ("save".equals(method.getName())) {
                    System.out.println("记录日志...");
                }
                Object object = method.invoke(target, arg);
                return object;
            }
        });
        //3.返回代理对象
        return enhancer.create();
    }
}
```

- Enhancer是ClassGenerator接口的实现类，可以对类、接口进行动态代理（setSuperclass()、setInterfaces()）
- MethodInterceptor是CallBack接口的子接口，设置回调函数enhancer.setCallback时，使用的是匿名内部类（当然也可以自定义内部类或该类自己实现MethodInterceptor接口传this，跟JDK代理中的InvocationHandler一样，有三种方式，这里只介绍一种。）

```java
public class Enhancer extends AbstractClassGenerator {
    public void setSuperclass(Class superclass) {
        if (superclass != null && superclass.isInterface()) {
            this.setInterfaces(new Class[]{superclass});
        } else if (superclass != null && superclass.equals(Object.class)) {
            this.superclass = null;
        } else {
            this.superclass = superclass;
        }
    }

    public void setInterfaces(Class[] interfaces) {
        this.interfaces = interfaces;
    }

    public void setCallback(Callback callback) {
        this.setCallbacks(new Callback[]{callback});
    }

    ...
}
```

> c.测试

```java
@Test
public void testCglibProxy() {
    //目标对象
    ProductServiceImpl target = new ProductServiceImpl();
    //代理工厂           
    CglibProxyFactory proxyFactory = new CglibProxyFactory(target); 
    //代理类
    ProductServiceImpl proxy = (ProductServiceImpl)proxyFactory.getProxyInstance();

    proxy.save();
    System.out.println("-------------------");
    proxy.find();
}
```

> d.结果

```
记录日志...
商品保存了...
-------------------
商品查询了...
```

> e.断点查看

```java
proxy = {ProductServiceImpl$$EnhancerByCGLIB$$892ed630@933} "com.baicai.service.ProductServiceImpl@543788f3"
 CGLIB$BOUND = true
 CGLIB$CALLBACK_0 = {CglibProxyFactory$1@932} 
  this$0 = {CglibProxyFactory@942} 
   target = {ProductServiceImpl@943} 

method = {Method@939} "public void com.baicai.service.ProductServiceImpl.save()"

methodProxy = {MethodProxy@941} 
 sig1 = {Signature@962} "save()V"
 sig2 = {Signature@963} "CGLIB$save$1()V"
```

#### 2.2 结论

**CGLIB生成的动态代理类，是目标类的子类（JDK代理是兄弟关系，两者都是接口的子类）。**相当于（动态生成的，并非真正存在该类）：

```java
//CGLIB代理类伪代码
Class ProductServiceImpl$$EnhancerByCGLIB$$892ed630 extends ProductServiceImpl {
    ProductServiceImpl productService= new ProductServiceImpl();

    public void save() {
        writeLog()
        productService.save();
    }

    public int find() { return productService.find(); }

    private static void writeLog(){ System.out.println("记录日志..."); }
}
```

## 2.动态代理总结

> 两种动态代理的对比

- JDK代理：使用JDK的Proxy。只能基于接口代理。会生成目标对象接口类型的子对象，代理对象和目标对象兄弟关系
- CGLIB代理：使用CGLIB库。可以基于类代理（可以没有接口）。基于类代理时会生成目标对象类型的子对象，代理对象和目标对象父子关系

> Spring中的代理

- Spring在运行期动态生成代理对象，不需要特殊的编译器
- Spring底层两种代理方式都有使用：
    + 若目标对象实现了若干接口，使用JDK的Proxy类进行代理
    + 若目标对象没有实现任何接口，则使用CGLIB库生成目标对象的子类

**Spring AOP优先对接口代理（JDK动态代理）；如果目标对象没有实现任何接口，才会对类进行代理（CGLIB动态代理）**

> 注意

- 1.对接口代理优于对类代理。因为会产生更加松耦合的系统，所以Spring默认是使用JDK代理。对类代理是让遗留系统或无法实现接口的第三方类库同样可以得到增强，算是备用方案。
- 2.被final修饰的方法不能够被通知/增强。Spring是为目标类产生子类。任何需要被通知的方法都要被复写，将通知织入。而final方法不允许重写的。
- 3.Spring只支持方法连接点（在方法前后增强），不提供属性接入点（不能进行方法内增强，侵入性低）。属性拦截（方法内增强）有悖于面向对象的思想：面向对象是对象处理工作，其他对象只能通过该对象调用其方法来得到结果。


---

# IV.Spring1.2 AOP

即未引入AspectJ之前的AOP编程方式。具体的开发步骤：

- 1.确定target
- 2.编写Advice（需要实现对应接口）
- 3.配置ProxyFactoryBean生成代理对象（较复杂）

## 1.传统方式的Advice

Advice，即通知或增强。狭义的指AOP联盟提供的org.aopalliance.aop.Advice接口（aopalliance-1.0.jar中）

为了遵循aop联盟的接口规范，Spring为Advice扩展了多个子接口，提供多个Advice实现方式（5种）。根据作用于目标类Pointcut的位置，将Advice划分成5种类型，使用每种通知必须实现对应的接口：

- 1.前置通知，org.springframework.aop.MethodBeforeAdvice（在Pointcut执行前增强）
- 2.后置通知，org.springframework.aop.AfterReturningAdvice（在Pointcut执行后增强）
- 3.环绕通知，org.aopalliance.intercept.MethodInterceptor（在Pointcut前后都增强）
- 4.抛出通知，org.springframework.aop.ThrowsAdvice（在Pointcut执行抛出异常时才增强）
- 5.引介通知，org.springframework.aop.IntroductionInterceptor（在目标类中添加新的方法和属性）

> 一个通知类可以同时实现多个接口，具备多种增强方式，但很少这么用（单一职责）。

## 2.示例

这里以CustomerServiceImpl（有接口）和ProductServiceImpl（无接口）作为 target，织入记录方法运行时间的环绕通知，并写入日志。

- 1.依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
</dependency>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>

<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>
```

- 2.log4j.properties

```java
### direct messages to stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} [method]%l%n%m%n

### direct messages to file
log4j.appender.file=org.apache.log4j.FileAppender
log4j.appender.file.File=/home/top/log.log
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} [method]%l%n%m%n

### set log levels
log4j.rootLogger=info,stdout,file
```

- 3.编写Advice通知类

Spring1.2 AOP的Advice必须实现对应接口。这里实现的是aopalliance的[MethodInterceptor](http://aopalliance.sourceforge.net/doc/org/aopalliance/intercept/MethodInterceptor.html)环绕通知接口。

> [MethodInvocation](http://aopalliance.sourceforge.net/doc/org/aopalliance/intercept/MethodInvocation.html)是目标类方法回调的包装类，通过该类可以获取调用方法的相关属性、方法名、调用该方法的对象等。

```java
//自定义环绕Advice，实现对应的接口，记录运行时间
public class TimeLogAdvice implements MethodInterceptor {

    private static Logger logger = Logger.getLogger(TimeLogAdvice.class);

    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        long begin = System.currentTimeMillis();
        //目标对象原有方法执行
        Object object = methodInvocation.proceed();
        logger.info(methodInvocation.getThis().getClass().getName() + "的" + methodInvocation.getMethod().getName() +
                "方法运行了" + (System.currentTimeMillis()-begin) + "ms");
        //放行
        return object;
    }
}
```

- 4.配置文件

将目标类和通知类交由IoC容器，并**配置切面**

> ProxyFactoryBean的配置复杂，开发中很少使用。所以这里采用AspectJ语法来代替（用aop:config），只为明确配置的原理

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 有接口的bean -->
    <bean id="customerService" class="com.baicai.service.CustomerServiceImpl"/>
    <!-- 无接口的bean -->
    <bean id="productService" class="com.baicai.service.ProductServiceImpl"/>

    <!-- 通知类 -->
    <bean id="timeLogAdvice" class="com.baicai.aop.trad.TimeLogAdvice"/>

    <!-- 切面: 切入点+通知 -->
    <aop:config>
        <!-- expression是aspectj语法，简单灵活 -->
        <aop:pointcut id="myPointcut" expression="bean(*Service*)"/>
        <aop:advisor advice-ref="timeLogAdvice" pointcut-ref="myPointcut"/>
    </aop:config>
</beans>
```

> 关于aspectJ表达式，详见下述。

- 5.测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-trad.xml")
public class AopTest {

    @Autowired
    private CustomerService customerService;    //有接口，注入的是代理对象
    @Autowired
    private ProductServiceImpl productService;  //无接口，注入的是代理对象

    @Test
    public void test(){
        //基于接口
        customerService.save();
        customerService.find();
        System.out.println("-------------");
        //基于类的
        productService.save();
        productService.find();
    }
}
```

> 断点查看

```java
customerService = {$Proxy13@2291} "com.baicai.service.CustomerServiceImpl@13e3c1c7"
productService = {ProductServiceImpl$$EnhancerBySpringCGLIB$$35f14531@2320} "com.baicai.service.ProductServiceImpl@650eab8"
```

> 控制台输出，也可以查看/home/top/log.log

```java
客户保存了...
com.baicai.service.CustomerServiceImpl的save方法运行了0ms
客户查询了...
com.baicai.service.CustomerServiceImpl的find方法运行了0ms
-------------
商品保存了...
com.baicai.service.ProductServiceImpl的save方法运行了68ms
商品查询了...
com.baicai.service.ProductServiceImpl的find方法运行了1ms
```

## 3.结论

运行时，注入的两个Service实例都是**代理对象**：

- customerService有接口，注入的是**JDK动态代理**生成的代理对象$Proxy13
- productService没有接口，注入的是**CGLIB动态代理**生成的代理对象ProductServiceImpl$$EnhancerBySpringCGLIB$$35f14531


---

# V.Spring2.0 AOP

即AspectJ方式的AOP编程。Spring2.0引入AspectJ语法，简化AOP开发。比如普通POJO就可作为Advice，不需要实现任何接口。

开发仍是三步：
- 1.确定目标对象（target-bean）
- 2.编写通知（advice）
- 3.配置切面（aspect）

> 与传统AOP开发相比：

- 1.通知类型+1
- 2.更灵活。advice不需要实现接口，普通pojo即可；并且一个通知类中可以编写多个方法实现不同类型的增强（传统方式需要多实现）
- 3.一个通知可以增强于多个连接点，一个连接点可以被多次增增强

## 1.AspectJ中的Advice

AspectJ中的Advice不需要实现接口，普通pojo即可；并且一个通知类中可以编写多个方法实现不同类型的增强（传统方式需要多实现），比较方便。

- 1.前置通知：Before，相当于BeforeAdvice
- 2.后置通知：AfterReturning，相当于AfterReturningAdvice
- 3.环绕通知：Around，相当于MethodInterceptor
- 4.抛出通知：AfterThrowing，相当于ThrowAdvice
- 5.最终通知：After，不管是否异常，该通知都会执行
- 6.引介通知：DeclareParents，相当于IntroductionInterceptor

相比传统的Spring AOP通知类型多了After最终通知。

## 2.AspectJ中的JoinPoint

AspectJ使用[org.aspectj.lang.JoinPoint](https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html)接口表示目标类的连接点对象。如果是环绕通知，使用org.aspectj.lang.ProceedingJoinPoint表示，它是JoinPoint的子接口。

任何增强方法都可以通过将第一个形参声明为JoinPoint，来访问连接点的信息。这两个接口的主要方法：

```java
public interface JoinPoint {
    //获取代理对象本身
    Object getThis();
    //获取连接点方法所在的目标对象
    Object getTarget();
    //获取连接点方法运行时的入参列表
    Object[] getArgs();
    //获取连接点方法签名对象
    Signature getSignature();
    ...
}
```

```java
//JoinPoint的子接口，新增了两个用于执行连接点方法的方法
public interface ProceedingJoinPoint extends JoinPoint {
    void set$AroundClosure(AroundClosure arc);
    //通过反射，执行目标对象的连接点方法
    public Object proceed() throws Throwable;
    //通过反射，执行目标对象的连接点方法，只不过是使用新的入参替换原来的入参
    public Object proceed(Object[] args) throws Throwable;
}
```

## 3.示例

同上：目标对象中有save()和find()。要求：在执行save()时，记录日志。

> 这里分为XML和注解方式。

#### 3.1 XML方式

- 1.依赖同上

CustomerService、CustomerServiceImpl、ProductServiceImpl也同上

- 2.编写Advice通知类

```java
public class MyAspectjAdvice {
    public void firstBefore() { System.out.println("第1个前置通知..."); }
    public void secondBefore() { System.out.println("第2个前置通知..."); }
}
```

- 3.配置文件

配置通知类和切面（省略了目标bean的配置）

```xml
<!-- 通知类 -->
<bean id="myAspectjAdvice" class="com.baicai.aop.trad.MyAspectjAdvice"/>

<aop:config>
    <!-- 方式1 -->
    <!-- <aop:aspect ref="myAspectjAdvice">
        <aop:before method="firstBefore" pointcut="within(com.baicai.service.*)"/>
    </aop:aspect> -->

    <!-- 方式2 -->
    <aop:pointcut id="myPointCut" expression="within(com.baicai.service.*)"/>
    <aop:aspect ref="myAspectjAdvice">
        <aop:before method="firstBefore" pointcut-ref="myPointCut"/>
    </aop:aspect>
</aop:config>
```

- 4.测试

修改引入的IOC容器配置文件，进行测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-aspe.xml")
public class AopTest {

    @Autowired
    private CustomerService customerService;    //有接口，注入的是代理对象
    @Autowired
    private ProductServiceImpl productService;  //无接口，注入的是代理对象

    @Test
    public void test(){
        //基于接口
        customerService.save();
        customerService.find();
        System.out.println("-------------");
        //基于类的
        productService.save();
        productService.find();
    }
}
```

> 断点查看

```java
customerService = {$Proxy13@2330} "com.baicai.service.CustomerServiceImpl@a8c1f44"
productService = {ProductServiceImpl$$EnhancerBySpringCGLIB$$ae22b4a1@2345} "com.baicai.service.ProductServiceImpl@5ed731d0"
```

> 控制台输出，/home/top/log.log中没有记录日志的增强

```
第1个前置通知...
客户保存了...
第1个前置通知...
客户查询了...
-------------
第1个前置通知...
商品保存了...
第1个前置通知...
商品查询了...
```

- 5.扩展

配置多个Advice时，是有执行顺序的，跟配置顺序一致

```xml
<aop:config>
    <aop:pointcut expression="within(com.baicai.service.*)" id="myPointCut"/>
    <aop:aspect ref="myAspectjAdvice">
        <aop:before method="secondBefore" pointcut-ref="myPointCut"/>
        <aop:before method="firstBefore" pointcut-ref="myPointCut"/>
    </aop:aspect>
</aop:config>
```

```
第2个前置通知...
第1个前置通知...
客户保存了...
第2个前置通知...
第1个前置通知...
客户查询了...
-------------
第2个前置通知...
第1个前置通知...
商品保存了...
第2个前置通知...
第1个前置通知...
商品查询了...
```


#### 3.2 注解方式

- 1.依赖同上

CustomerService、CustomerServiceImpl、ProductServiceImpl（无接口）同上。只不过使用注解配置bean，如：

```java
@Service("customerService")
public class CustomerServiceImpl implements CustomerService{
    ...
}
```

注意：这里的目标类id，会影响下面@Pointcut的正则匹配。（比如这里不指定id，默认id=CustomerServiceImpl，那么bean(\*Service)就匹配不到，bean(\*Service\*)才能匹配到）

- 2.配置文件

开启aspectj自动代理、包扫描（包括了注解驱动）（不仅扫目标类，还要扫到通知类哦）

```xml
<!--开启aspectj自动代理-->
<aop:aspectj-autoproxy/>
<!--包扫描（注解驱动）-->
<context:component-scan base-package="com.baicai.service,com.baicai.aop.trad"/>
```

- 3.切面

```java
@Aspect                      //标注为通知类
@Component("myAspectjAdvice")//注册到IoC容器
public class MyAspectjAdvice {
    //切入点（id就是方法名）
    @Pointcut("bean(*Service)")
    private void myPointCut() {}

    //前置通知
    @Before("myPointCut()")
    public void firstBefore() { System.out.println("第1个前置通知..."); }
    @Before("myPointCut()")
    public void secondBefore() { System.out.println("第2个前置通知..."); }
}
```

- 4.测试

更换IoC容器配置文件，进行测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-aspe-anno.xml")
public class AopTest {
    @Autowired
    private CustomerService customerService;    //有接口，注入的是代理对象
    @Autowired
    private ProductServiceImpl productService;  //无接口，注入的是代理对象

    @Test
    public void test(){
        //基于接口
        customerService.save();
        customerService.find();
        System.out.println("-------------");
        //基于类的
        productService.save();
        productService.find();
    }
}
```

```
第1个前置通知...
第2个前置通知...
客户保存了...
第1个前置通知...
第2个前置通知...
客户查询了...
-------------
第1个前置通知...
第2个前置通知...
商品保存了...
第1个前置通知...
第2个前置通知...
商品查询了...
```

## 4.Advice切面配置

上例中讲述了前置通知的注解方式和XML方式。这里也是使用这两种方式汇总讲解各种通知。

#### 4.1 XML方式

```xml
<!-- 有接口的bean -->
<bean id="customerService" class="com.baicai.service.CustomerServiceImpl"/>
<!-- 无接口的bean -->
<bean id="productService" class="com.baicai.service.ProductServiceImpl"/>

<!-- 通知类 -->
<bean id="myAdvice" class="com.baicai.advice.xml.MyAdvice"/>
<aop:config>
    <aop:pointcut id="myPointCut" expression="within(com.baicai.service.*)"/>
    <aop:aspect ref="myAdvice">
        <aop:before method="before" pointcut-ref="myPointCut"/>
        <!-- returning用来指定目标对象jointpoint方法返回值的接收参数，spring会自动将jointpoint的返回值，传入该afterReturing方法的该参数中 -->
        <aop:after-returning method="afterReturing" returning="returnVal" pointcut-ref="myPointCut"/>
        <aop:around method="around" pointcut-ref="myPointCut"/>
        <aop:after-throwing method="afterThrowing" throwing="ex" pointcut-ref="myPointCut"/>
        <aop:after method="after" pointcut-ref="myPointCut"/>
    </aop:aspect>
</aop:config>
```

```java
public class MyAdvice {

    /**
     * 前置通知
     * @param joinPoint 连接点对象
     */
    public void before(JoinPoint joinPoint) {
        System.out.println("before...");
        //JoinPoint接口的API，获取连接点的相关信息
        System.out.println("连接点方法:" + joinPoint.getSignature());
        System.out.println("目标对象:" + joinPoint.getTarget().getClass().getName());
        System.out.println("代理对象:" + joinPoint.getThis().getClass().getName());
        //权限拦截
        String name = "rose";
        if (!"admin".equals(name)) {
            throw new RuntimeException("无权访问" + joinPoint.getTarget().getClass().getName() + "中的" + joinPoint.getSignature());
        }
    }

    /**
     * 后置通知
     * @param joinPoint 连接点对象
     * @param returnVal 目标方法执行后的返回值,类型是object，参数名任意，会配置到xml
     */
    public void afterReturing(JoinPoint joinPoint, Object returnVal) {
        System.out.println("afterReturing...");
        System.out.println("尊敬的用户，您的余额为：" + returnVal);
    }

    /**
     * 环绕通知
     * @param proceedingJoinPoint (执行中的)连接点对象
     * @return 返回目标方法的返回值
     * @throws Throwable 必须抛出Throwable
     */
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("around...");
        System.out.println("开启事务...");
        //调用proceed()方法可以随时随地执行目标对象的方法
        Object returnVal = proceedingJoinPoint.proceed();
        System.out.println("提交事物...");
        return returnVal;
    }

    /**
     * 抛出通知
     * @param joinPoint 连接点对象
     * @param ex 目标方法抛出的异常，类型是Throwable，参数名任意，会配置到xml
     */
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        System.out.println("afterThrowing...");
        System.out.println("管理员" + joinPoint.getTarget().getClass().getName() + "的方法：" + joinPoint.getSignature().getName() + "发生了异常，异常为：" + ex.getMessage());
    }

    /**
     * 最终通知
     * @param joinPoint 连接点对象
     */
    public void after(JoinPoint joinPoint) {
        System.out.println("after...");
        System.out.println("执行" + joinPoint.getSignature().getName() + "完成连接释放");
    }
}
```

> 其中：

- 前置通知中的权限拦截，不满足时会报异常
- 测试抛出通知时，需要制造异常，如：

```java
@Service("productService")
public class ProductServiceImpl {
    public void save() {
        int i = 1/0;
        System.out.println("商品保存了...");
    }
    ...
}
```
- 测试最终通知时，应包括正常情况和抛出异常情况（切入点抛异常，理应仍执行最终通知）

#### 4.2 注解方式

> aspectj-autoproxy

Spring在内部采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的工作，只不过具体实现细节被aop:aspectj-autoproxy标签隐藏起来了。 

- 1.该配置会将@AspectJ注解的bean（切面类）配置到IoC容器。对该类中指定的切入点进行指定的增强（织入），相当于aop:config。
- 2.代理切换：该标签的**proxy-target-class属性**，默认为false，表示使用jdk动态代理生成代理对象。如果目标类没有声明接口，则自动使用CGLib动态代理；当poxy-target-class=true时，表示不管目标类有没有实现接口，都使用CGLib动态代理织入增强。

与上述XML方式等效的注解配置：

```xml
<!--开启aspectj自动代理-->
<aop:aspectj-autoproxy/>
<!--包扫描（注解驱动）-->
<context:component-scan base-package="com.baicai.service,com.baicai.advice.anno"/>
```

```java
@Service("productService")
public class ProductServiceImpl {...}

@Service("customerService")
public class CustomerServiceImpl implements CustomerService {...}
```

```java
@Aspect
@Component("myAdvice")
public class MyAdvice {

    @Pointcut("bean(*Service)")
    private void myPointCut() {}

    @Before("myPointCut()")
    public void before(JoinPoint joinPoint) {
        System.out.println("before...");
        //JoinPoint接口的API，获取连接点的相关信息
        System.out.println("连接点方法:" + joinPoint.getSignature());
        System.out.println("目标对象:" + joinPoint.getTarget().getClass().getName());
        System.out.println("代理对象:" + joinPoint.getThis().getClass().getName());
        //权限拦截
        String name = "rose";
        if (!"rose".equals(name)) {
            throw new RuntimeException("无权访问" + joinPoint.getTarget().getClass().getName() + "中的" + joinPoint.getSignature());
        }
    }

    @AfterReturning(value="myPointCut()", returning="returnVal")
    public void afterReturing(JoinPoint joinPoint, Object returnVal) {
        System.out.println("afterReturing...");
        System.out.println("尊敬的用户，您的余额为：" + returnVal);
    }

    @Around("myPointCut()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        System.out.println("around...");
        System.out.println("开启事务...");
        //调用proceed()方法可以随时随地执行目标对象的方法
        Object returnVal = proceedingJoinPoint.proceed();
        System.out.println("提交事物...");
        return returnVal;
    }

    @AfterThrowing(pointcut="myPointCut()", throwing="ex")
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        System.out.println("afterThrowing...");
        System.out.println("管理员" + joinPoint.getTarget().getClass().getName() + "的方法：" + joinPoint.getSignature().getName() + "发生了异常，异常为：" + ex.getMessage());
    }

    @After("myPointCut()")
    public void after(JoinPoint joinPoint) {
        System.out.println("after...");
        System.out.println("执行" + joinPoint.getSignature().getName() + "完成连接释放");
    }
}
```

#### 4.3 切入点配置方式

和xml方式一样，注解方式定义切入点，也有2种方式。以前置为例：

###### 方式1

使用@Pointcut单独配置pointcut

```java
@Pointcut("bean(*Service)")
private void myPointCut1() {}
@Pointcut("bean(customerService)")
private void myPointCut2() {}

@Before("myPointCut1() || myPointCut2()")
public void before() { System.out.println("before..."); }
```

该方式要求：

- 1.切入点方法格式：private void 无参数、无方法体，方法名为切入点的id
- 2.一个通知方法，如@Before上，可以使用多个切入点，使用"||"分隔，表示作用于多个切入点。运算的结果是"补集"（即有重复覆盖的切入点，也只执行一次增强。上面customerService的切入点只增强一次before）

###### 方式2

配置切面时，同时配置pointcut

```java
@Before("bean(*Service)")
public void before() { System.out.println("before..."); }
```

#### 4.4 通知总结

- 1.AfterReturning后置通知可以获取到目标类JointPoint的返回值，如果想对返回值进行操作，就使用后置通知，如短信通知等
- 2.使用Around环绕通知可以实现其他四种效果

```java
try {
    //前置通知
    Object result = proceedingJoinPoint.proceed();
    //后置通知
}catch(Exception){
    //抛出通知
}finally{
    //最终通知
}
```
- 3.不管目标方法是否发生异常，After最终通知都会执行（类似于finally）。应用释放资源等
- 4.各种Advice方法格式

|通知类型|输入参数(可选)|返回值类型|其他|使用场景|
|:------|:-----------|:--------|:--|:------|
|Before前置通知|JoinPoint（静态连接点信息）|void||权限控制、日志记录|   
|AfterReturning后置通知|JoinPoint, Object|void||短信功能|
|Around环绕通知|ProceedingJoinPoint（可执行的连接点信息）|Object|throws Throwable|性能监控、事务管理|
|AfterThrowing抛出通知|JoinPoint, Throwable|void||处理异常（一般是不可预知的异常）记录日志、通知管理员操作|
|After最终通知|JoinPoint|void||释放资源（关闭文件、数据库连接、网络连接，释放内存对象）|

> 这些通知的方法名任意，需要配置到xml中

## 5.aspectJ表达式

aspectJ表达式灵活多样，举例如下：

```xml
<aop:config>
    <!-- 方式1:配置切面时，同时定义切入点 -->
    <aop:advisor advice-ref="timeLogAdvice" pointcut="bean(*Service*)"/>
    
    <!-- 方式2:切入点、切面分开配置，更灵活 -->
    <aop:pointcut expression="bean(*ServiceImpl)" id="myPointCut"/>
    <aop:pointcut expression="target(com.aop.UserServiceImpl)" id="myPointCut"/>
    <aop:pointcut expression="execution(* com.aop.*ServiceImpl.*(..))" id="myPointCut"/>
    <aop:pointcut expression="execution(* com.aop.UserServiceImpl.find(..))" id="myPointCut"/>
    <aop:pointcut expression="execution(int com.aop.UserServiceImpl.*(..))" id="myPointCut"/>
    <aop:pointcut expression="within(com.aop..*)" id="myPointCut"/>
    <!-- 通知 -->
    <aop:advisor advice-ref="timeLogAdvice" pointcut-ref="myPointCut"/>
</aop:config>
```

```java
//指定bean中的所有方法
bean(bean id/name)
bean(tradeService)
bean(*Service)

//execution表达式，除返回类型、方法名、参数为必填项，其余非必填
//参数：()表示匹配空参方法连接点，(..)表示匹配任意数量（0或多个）参数的方法连接点
execution([访问修饰符] 返回类型 [包名.]方法名(参数) [异常]) 
//返回类型任意，任意包中及其子包中所有类，中的所有方法，参数任意
execution(* *..*.*(..))
//返回类型任意，任意包中及其子包中所有类，中的所有方法，参数任意 
execution(* *(..))
//任意公共方法
execution(public * *(..))
//任何名字以"set"开头的方法
execution(* set*(..))
//AccountService接口的所有方法
execution(* com.xyz.service.AccountService.*(..))
//service包中的所有方法
execution(* com.xyz.service.*.*(..))
//service包或其子包中的所有方法
execution(* com.xyz.service..*.*(..))
//就是指任意的（私有或公开的等）void UserServiceImpl.save(*,String)
execution(void com.aop.UserServiceImpl.save(*,java.lang.String))

//指定包的类的所有方法
within(包.类)
//service包下的所有方法
within(com.xyz.service.*)
//service包和其子包下的所有方法
within(com.xyz.service..*)

//对代理对象有效
this(完整类型)
//所有实现了AccountService的代理类的所有方法
this(com.xyz.service.AccountService)

//对目标对象有效
target(完整类型)
//所有实现了AccountService的目标类的所有方法
target(com.aop.UserServiceImpl)

//AspectJ表达式中的通配符
*：匹配单个任何长度的字符串
..：匹配多个任何长度额字符串（比如所有子包、不限形参数量）
+：匹配指定类型的子类型（只能作为后缀放在类型模式的后边）
```

更多如args、@target、@within等，可参考[aop-pointcuts-examples](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#aop-pointcuts-examples)。


---

# VI.代理切换

**Spring AOP基于动态代理，目标类有接口时，默认对接口代理（JDK），没有实现接口时默认对类代理（CGLIB）**。

**代理切换**：当然，如果目标类有接口，也可以强制使用CGLIB对类代理，而不是用JDK动态代理。**主要用在实现类特有的方法**。

## 示例

在上述CustomerServiceImpl实现类中，新增特有方法，即接口中未定义

```java
@Service("customerService")
public class CustomerServiceImpl implements CustomerService {
    @Override
    public void save() { System.out.println("客户保存了..."); }

    @Override
    public int find() {
        System.out.println("客户查询了...");
        return 100;
    }

    //实现类特有的方法
    public void code() { System.out.println("code..."); }
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext-anno.xml")
public class SpringTest {
    @Autowired
    private CustomerService customerService;//有接口的target实例
    
    @Test
    public void test(){
        //多态弊端：要调用实现类特有的方法，需要向下强转
        ((CustomerServiceImpl) customerService).code();
    }
}
```

- 1.首先不对CustomerServiceImpl.code()进行增强，即排除在切入点之外

此时运行正常，没有增强

- 2.对CustomerServiceImpl.code()进行增强

再次测试，抛出异常：

```java
java.lang.ClassCastException: com.sun.proxy.$Proxy21 cannot be cast to com.baicai.service.CustomerServiceImpl
```

> 原因

未增强时customerService = {CustomerServiceImpl@2202}，可以强转回CustomerServiceImpl类型。但增强后，**customerService引用指向的是JDK动态代理后的代理对象com.sun.proxy.$Proxy21**。该对象是接口的子类型（代理类）的对象，和（目标类）CustomerServiceImpl是**兄弟关系，但不是同一类型或父子类型，不能强转**。

解决：对有接口的CustomerServiceImpl，也进行CGLIB代理，而非JDK代理。此时代理类是目标类的子类，就可以进行强转了。接口（CustomerService）--目标类（CustomerServiceImpl）--代理类。

## 切换

- XML方式

```xml
<aop:config proxy-target-class="true">
    ...
</aop:config>
```

- 注解方式

```xml
<!-- 
    aspectj自动代理：注册@Aspect的bean，配置切面，相当于:<aop:config>
    proxy-target-class:默认false，表示尽量使用jdk接口代理；true表示对类代理，即使有接口，也使用cglib代理
-->
<aop:aspectj-autoproxy proxy-target-class="true"/>
```

```
around...
开启事务...
before...
连接点方法:void com.baicai.service.CustomerServiceImpl.code()
目标对象:com.baicai.service.CustomerServiceImpl
代理对象:com.baicai.service.CustomerServiceImpl$$EnhancerBySpringCGLIB$$36afd93d
code...
提交事物...
after...
执行code完成连接释放
afterReturing...
尊敬的用户，您的余额为：null
```


---

# VII.参考

- 1.[Aspect Oriented Programming with Spring](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#aop)（Spring2.0 AOP）
- 2.[Spring AOP APIs](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#aop-api)（Spring1.2 AOP）