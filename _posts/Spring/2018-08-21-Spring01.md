---
title: Spring入门
date: 2018-08-21 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Basic
    - Java
---

本文将介绍Spring Framework核心概念之一的IoC相关内容。

<!-- more -->

##### 目录
+ I.Spring简介
+ II.IoC+DI介绍
+ III.IoC容器
+ IV.装配Bean
+ V.获取Bean
+ VI.依赖注入
+ VII.Bean作用域
+ VIII.生命周期回调

---

# I.Spring简介

[Spring](https://spring.io/)是分层的、JavaSE/EE一站式(full-stack)、轻量级开源框架。这里基于[Spring Framework-4.3.22.RELEASE](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-introduction)讲解。

> Spring4提供了对Java8的一些特性的支持，最低要求Java6（JDK 6 update 18），推荐使用Java7和8。

经典三层结构：
- 表现层（页面数据渲染、跳转调度），JSP/Servlet/Struts/SpringMVC等
- 业务层（业务逻辑实现、事务控制），JavaBean、EJB、spring等
- 持久层（数据操作），JDBC/Hibernate/Mybatis/Spring Data JPA等

Spring取代了相对臃肿的EJB，对上述三层都提供了解决方案，并且使用spring编程是**非侵入式**的。

## 1.Spring核心

- IoC

将对象的创建和管理交给Spring工厂。由Book book = new Book()变为Book book = Spring工厂.getBook()。**工厂模式 + 反射**

> **IoC强调将对象的创建交由Spring容器；DI更强调Spring容器把对象间的依赖关系也维护了**，两者实际是相同的概念。

- AOP

基于**动态代理**进行增强

## 2.Spring优点

Spring的出现是为了解决JavaEE开发中的实际问题，降低JavaEE API的使用难度。俗称为粘合剂

- 解耦，简化开发：所有对象的创建和依赖关系的维护，都可以交给Spring管理
- AOP编程：面向切面编程，方便实现对程序的权限拦截、运行监控等功能
- 声明式事务：通过配置就可以完成事务管理，代替耦合的手动编程
- 方便测试：支持集成Junit，通过注解可以方便地测试Spring程序
- 集成第三方框架：提供了对各种优秀框架的集成支持，易扩展可插拔
- 降低JavaEE的使用难度：对JavaEE中的一些API（JDBC、JavaMail、远程调用等）提供封装，降低这些API的使用难度


## 3.模块

Spring is modular。Spring Framework包含大概20个模块。这些模块可划分为7类：Core Container、Data Access/Integration、Web、AOP、Instrumentation、Messaging和Test。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/spring-overview.png)

#### 3.1 Core Container

包括spring-core、spring-beans、spring-context、spring-context-support、spring-expression (SpEL)。

spring-core和spring-beans模块提供了Spring最基础的功能：IoC和DI特性。**BeanFactory**是工厂模式的实现，它消除了对程序实现单例（programmatic singletons）的需要，将依赖关系和配置从程序逻辑中分离出来。

spring-context模块基于core和beans，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。context模块继承了beans模块的特性，还增加了国际化（I18N）、事件传播、资源加载，以及透明地创建上下文，例如通过Servlet容器创建。另外，context模块支持一些JavaEE特性，如EJB、JMX和basic remoting。**ApplicationContext**接口是context模块的核心。context-support提供了将常见的第三方库集成到Spring上下文的支持，如caching（EhCache，Guava，JCache）、mailing（JavaMail）、scheduling（CommonJ，Quartz）和template engines（FreeMarker，JasperReports，Velocity）。

spring-expression模块，提供了一个强大的EL，在运行期间查询和操作object graph。SpEL是JSP 2.1规范中unified EL的扩展。SpEL支持访问和修改属性值，属性指定，方法调用，访问数组、容器和索引器，逻辑和数学运算，命名变量，以及支持从Spring容器中获取Bean。它还支持列表投影、选择和一般的列表聚合等。

#### 3.2 AOP and Instrumentation

spring-aop模块提供了符合AOP联盟规范的、面向切面的编程实现。方便定义如方法拦截器和切入点，减少代码耦合。利用源码级的元数据功能，还可以将各种行为信息合并到代码中（和.NET属性相似的方式）。

spring-aspects模块，提供了对AspectJ的集成。

spring-instrument模块提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用。spring-instrument-tomcat模块包含了spring对Tomcat的代理instrumentation。

#### 3.3 Messaging

Spring4引入了spring-messaging模块，其中包含来自Spring集成项目的关键抽象，如Message、MessageChannel、MessageHandler等，可以作为基于消息的应用程序的基础。该模块还包括一组用于将消息映射到方法的注释，类似SpringMVC的基于注释的编程模型。

#### 3.4 Data Access/Integration

Data Access/Integration层包括了JDBC、ORM、OXM、JMS、Transaction模块。

spring-jdbc模块，提供对JDBC的抽象，用来消除冗长的JDBC编码和解析数据库厂商特有错误代码。

spring-tx模块，对实现特定接口的类和POJO，支持程序式和声明式事务管理。

spring-orm模块，提供了对常用"对象-关系映射"APIs的集成支持。包括JPA、JDO、Hibernate。使用该模块，可以将ORM框架和Spring提供的特性相结合，如声明式事务管理。

spring-oxm模块，提供一个抽象层，用于支持集成Object和XML映射的实现，包括JAXB、Castor、XMLBeans、JiBX和XStream。

spring-jms模块（Java Messaging Service），提供了生产和消费消息的特性。从Spring4开始，它和spring-messaging模块一起提供集成。

#### 3.5 Web

Web层包括spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet模块。

spring-web模块，提供了基础的web功能。例如多文件上传、使用Servlet listeners和一个web-oriented的application context实例化IoC容器。它还包含了一个HTTP Client和对远程访问的支持。

spring-webmvc模块（aka Web-Servlet模块），提供了MVC和REST Web服务的实现。SpringMVC框架将domain model code和web forms分离，并且继承了Spring框架的特性。

spring-webmvc-portlet模块（aka Web-Portlet模块），提供了在Portlet环境下的MVC实现，mirror基于servlet的spring-webmvc模块的功能

#### 3.6 Test
spring-test模块支持使用JUnit和TestNG，对Spring组件进行单元测试和集成测试。它提供一致的ApplicationContexts和这些上下文的缓存。它还提供一些mock对象，用来独立的测试代码。


---

# II.IoC+DI介绍

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/container-magic.png)

**Inverse of Control，IoC控制反转是种思想。正转：应用程序掌握主动，需要什么资源主动出击（程序中主动创建对象）。反转：在IoC中，应用程序变得被动，等待IoC容器来创建并注入它所需要的资源。无论正转反转，控制的都是依赖资源的获取**。

**Spring采用【工厂模式 + 反射 + 配置文件/注解】的方式，对IoC思想做了实现。**

> IoC和DI的关系

IoC is also known as dependency injection (DI). 
它们是**同一概念的不同角度描述**。控制反转比较含糊，可能只能理解为IoC容器控制对象这一层面，很难让人联想到谁来维护对象间的依赖关系。所以2004年Martin Fowler又提出DI依赖注入，相比IoC，DI更明确描述了"**被注入对象依赖IoC容器配置依赖对象**"。

> 但这里还是把IoC和DI分开讲解，把IoC"理解成"容器管理对象，把DI"理解成"容器也管理对象间的依赖关系。拆开讲更清晰，但实际两者是同一概念。

## 1.IoC原理

这里对比3种开发方式，来理解IoC的实现原理

#### 1.1 传统方式

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //传统方式-自己实例化对象
        UserDao userDao = new UserDaoImpl();
        userDao.selectOne();
    }
}
```

**手动创建实例，应用程序主动获取它所依赖资源（正转）。对象间的依赖关系也是在业务代码中维护的，耦合度高，另外，（UserDao的）实现类的切换不灵活**。

#### 1.2 传统方式改进

使用工厂模式+反射+配置文件（IoC原理）

> 简单起见，这里省略了配置文件，直接使用了字符串。可参考下述Spring方式，将类全路径放入配置文件。

```java
public class UserDaoFactory {
    //方式1-耦合性仍然强: UserDaoFactory和UserDaoImpl耦合
    /*
    public UserDao getUserDao() {
        UserDao userDao = new UserDaoImpl();
        return userDao;
    }*/
    
    //方式2-反射创建实例
    public Object getBean() {
        Object bean = null;
        try {
            bean = Class.forName("com.test.IoC.principle.UserDaoImpl").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        UserDao userDao = (UserDao) factory.getBean();

        userDao.selectOne();
    }
}
```

#### 1.3 Spring方式

- a.引入依赖

不使用maven时，也可以手动加入[Spring相关jar](http://repo.spring.io/libs-release-local/org/springframework/spring/4.3.22.RELEASE/)。

> 这里最简可以只引入：spring-context、log4j

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
</dependency>
<!-- context中引用了core、beans、expression、aop -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
</dependency>

<!-- JCL + Log4j -->
<!-- spring-core中也有JCL-1.2，这里可以省略 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>
```

> 对Spring来说，日志很重要。首先，日志是Spring唯一的"强制性外部依赖"。其次，由于Spring集成的第三方库的日志实现各种各样。开发者需要在一个集中的地方，使用统一的日志配置，来管理整个应用的日志输出。这里采用JCL+Log4j。

- b.配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 一个bean标签对应spring工厂创建的一个实例(反射机制)
        id/name:对象引用, class:类全路径 -->
    <bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

</beans>
```

- c.工厂+反射

Spring为我们提供了ApplicationContext工厂，并内部实现了通过反射创建Bean。

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        //UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        //UserDao userDao = (UserDao) factory.getBean();

        //3.Spring方式
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        UserDao userDao = (UserDao) context.getBean("userDao");
        userDao.selectOne();
    }
}
```

Spring方式解决了类之间的耦合，但在每次获取对象的时候（比如Controller中依赖Service），都需要创建ApplicationContext，能不能更方便地获取对象，或更方便地解决userService依赖userDao?
答案就是DI依赖注入。既然这些对象都由Spring容器创建和管理，那么对象间的依赖关系也可以交由ApplicationContext维护。


## 2.DI原理

Dependency Injection，依赖注入

组件之间的依赖关系由Spring容器在运行期决定，即由容器动态的将依赖注入到组件中。DI是为了降低耦合度，提高组件重用性。通过依赖注入机制，无需任何代码，仅使用简单的配置就可以完成指定目标的依赖资源注入，完成自身的业务逻辑，而不需要关心依赖资源来自何处，由谁实现。
 
- 谁依赖于谁：应用程序依赖IoC容器（或一个Bean依赖另一个Bean）
- 为什么依赖：应用程序需要IoC容器来提供对象需要的外部资源
- 谁注入给谁：IoC容器注入依赖资源给应用程序
- 注入了什么：某对象所需要的外部资源（包括对象、资源、常量数据）

> 如上例子中，通过下面的依赖注入改造，就可以省去在UserServiceImpl中创建context，然后getBean。而是将UserService和UserDao的依赖关系交由Ioc容器管理，并在创建UserService实例后就注入UserDao。

```java
public class UserServiceImpl implements UserService {

    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void login() {
        System.out.println("service层被调用了");
        userDao.selectOne();
    }
}
```

```xml
<bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

<bean id="userService" class="com.baicai.service.UserServiceImpl">
    <property name="userDao" ref="userDao"/>
</bean>
```

> Junit测试时，不能new UserServiceImpl()了，要通过Spring容器获取userService（注入了UserDao的）

这里只是依赖注入的一种方式（setter），后面会详细汇总DI的实现方式


---

# III.IoC容器

又称应用上下文、Spring容器、Spring工厂等

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/ApplicationContext-System.png)

ApplicationContext是BeanFactory的子接口。官方推荐使用ApplicationContext（更强大），两者的对比参考[ctx-vs-beanfactory](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#context-introduction-ctx-vs-beanfactory)。

> 另外，BeanFactory是延迟加载，第一次getBean()时才会初始化Bean。

## 1.关闭non-web applications

尽量使用ConfigurableApplicationContext提供的registerShutdownHook()或close()来关闭Spring容器，会释放容器中的Bean，执行**单例Bean**的销毁回调方法。否则可能会有未释放的资源。

```java
//放在业务代码后面，一般在main()的最后
((ClassPathXmlApplicationContext) context).close();
//可以放在业务代码前
((ClassPathXmlApplicationContext) context).registerShutdownHook();
```

其中registerShutdownHook()是在JVM中注册一个shutdown hook，这个钩子不是默认注册的，需要手动注册。其他JVM应用也都有类似的关闭钩子，如Hadoop、SparkContext等。

> JVM的关闭钩子是通过Runtime#addShutdownHook(Thread hook)方法来实现的。所谓的shutdown hook就是一系例的已初始化但尚未执行的线程对象。JVM正常关闭时，这些shutdown hook线程会被执行，包括：操作系统正常关闭、用户注销、用户调用System.exit(0)、kill、Ctrl+C等。断电、kill -9等非正常关闭JVM时则不会被调用

> web-based的ApplicationContext的实现类中，已经有编码实现：当相关的Web应用关闭时，会优雅地关闭IoC容器。


---

# IV.装配Bean

即将Bean交由Spring IoC容器管理。Spring提供了4种方式[装配bean](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class)。

> 这里四种方式在注解开发中很少用到，偶尔使用第一种方式。其他方式在Spring底层和整合第三方框架时用的较多。

## 1.[无参构造](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-ctor)

Spring在创建bean时，自动调用无参构造来实例化对象。此时需要有无参构造，也是最常用的方式。

```java
public class Bean1 {
    //默认系统给空参构造
}
```

```xml
<bean id="bean1" class="com.test.IoC.bean.xml.Bean1"/>
```

> 如果Bean1中没有无参构造（只有有参构造），则报NoSuchMethodException: com.baicai.pojo.Bean1.<init>()

## 2.[静态工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-static-factory-method)

需要提供一个工厂类，其中包括一个静态方法

```java
public class Bean2 {    
}
```

```java
public class Bean2Factory {
    //静态方法，方便调用
    public static Bean2 getBean2() {
        //do other things,like Connection to Driver...
        return new Bean2();
    }
}
```

```xml
<bean id="bean2" class="com.baicai.pojo.Bean2Factory" factory-method="getBean2"/>
```

## 3.[工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method)

该方式需先配置工厂实例，区别于静态工厂方式。（因为是非静态方法，所以需要先创建工厂实例，才能调用方法）

```java
public class Bean3 {    
}
```

```java
public class Bean3Factory {
    //非静态方法，需要先创建工厂实例，才能调用
    public Bean3 getBean3() {
        //do other things,like Connection to Driver
        return new Bean3();
    } 
}
```

```xml
<bean id="bean3Factory" class="com.baicai.pojo.Bean3Factory"/>
<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"/>
```

## 4.实现FactoryBean接口

该方式在spring底层源码用的多。
Spring在实例化bean时，会判断是否实现了FactoryBean接口。如果实现了就调用getObject方法返回目标类型实例。

```java
public class Bean4 {    
}
```

```java
public class Bean4FactoryBean implements FactoryBean<Bean4> {
    @Override
    public Bean4 getObject() throws Exception {
        //do other things,like Connection to Driver
        return new Bean4();
    }

    @Override
    public Class<?> getObjectType() { return null; }

    @Override
    public boolean isSingleton() { return false; }
}
```

```xml
<bean id="bean4" class="com.baicai.pojo.Bean4FactoryBean"/>
```

#### 4.1 BeanFactory和FactoryBean的区别

- BeanFactory：是Spring容器的超级接口。ApplicationContext是其子接口，但功能更强大，用来管理Bean
- FactoryBean：是一个Bean生成工具，是用来获取一种类型对象的Bean，它是构造Bean实例的一种方式。

> 如果一个Bean实现了FactoryBean，对外就会被作为某组件的工厂，而非一个Bean。


---

# V.获取Bean

从IoC容器获取Bean的方式有多种，即getBean有多个重载方法。常用的有两种：

- 根据id/name查找（唯一）
- 根据Bean类型或接口类型查找（一般使用接口类型，会自动去找实现类）

```java
getBean(String name)
getBean(Class<T> requiredType)
```

> 示例

```java
UserService userService = (UserService) ac.getBean("userService");
UserService userService = (UserService) ac.getBean(UserService.class);
```

> 根据类型查找Bean时，可能存在多个，此时报NoSuchBeanDefinitionException:No unique bean of type...


---

# VI.依赖注入

依赖注入，实际就是给Bean属性赋值，赋的一般也是IoC容器管理的bean实例或其他资源。

上面就使用了依赖注入，为userService的userDao属性，注入了同样由spring管理的userDao实例。下面就详细讲述依赖注入的实现方式。

## 1.空参构造+setter

使用空参构造+setter，配合property属性，完成依赖注入。最常用。

```xml
<bean id="car" class="com.baicai.pojo.di.Car"/>

<!-- 空参 + setter -->
<bean id="user" class="com.baicai.pojo.di.User">
    <property name="id" value="1"/>
    <property name="name" value="Tom"/>
    <property name="car" ref="car"/>
</bean>
```

对于Car：要有空参构造 
对于User：
- 必须要有空参构造和对应3个属性的setter
- name中的值跟着setter走，首字母大小写都可以

> 这里name属性值取决于setter方法名，而非成员变量。当然一般成员变量名和setter后缀一致（即xxx对应setXxx）。Spring会将name值的首字母转成大写，然后在前面拼接上"set"构成一个方法名，去对应类中查找该方法。通过反射调用，实现注入。

## 2.

---

# VII.[Bean作用域](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes)

## 1.作用域类型

|Scope|Description|
|[singleton](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton)|（默认）在Spring IoC容器中仅存在一个Bean实例|
|[prototype](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype)|每次从容器获取Bean时，都会返回一个新实例。即getBean()相当于new Bean()|
|request|每次HTTP Request都会创建新实例。该作用域仅适用于WebApplicationContext环境（如XmlWebApplicationContext，否则报unknown bean scope）|
|session|每个HTTP Session拥有一个Bean实例。仅适用于WebApplicationContext环境|
|globalSession|每个global HTTP Session拥有一个Bean实例，常用于Portlet应用环境。仅适用于WebApplicationContext环境|
|application|每个ServletContext拥有一个Bean实例。仅适用于WebApplicationContext环境|
|websocket|每个WebSocket拥有一个Bean实例。适用于WebApplicationContext环境|

常用singleton（默认）和prototype。除单例外，其他作用域需要显示声明。

- singleton：每次获取的是同一个对象；在IoC容器初始化时，就初始化了
- prototype：每次获取的是不同对象；**在getBean时，才创建和初始化**

> 当一个单例Bean A依赖一个多例Bean B时，IoC只会初始化A一次，所以每次获取A时，A所依赖的B也是同一个Bean。如果想每次获取A时，注入的是不同的B，参考[beans-factory-method-injection](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-method-injection)。

关于web环境下的几个scope，参考[beans-factory-scopes-other](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-other)

## 2.示例

```xml
<bean id="singleton" class="com.baicai.pojo.SingletonBean"/>
<bean id="prototype" class="com.baicai.pojo.PrototypeBean" scope="prototype"/>
```

```java
public class SingletonBean {
    public SingletonBean() {
        System.out.println("单例初始化...");
    }
}

public class PrototypeBean {
    public PrototypeBean() {
        System.out.println("多例初始化...");
    }
}
```

```java
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println("第1次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));
    System.out.println("第2次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));

    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
}

//输出结果
单例初始化...
第1次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第2次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@1a3869f4
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@a38d7a3
```

## 3.自定义作用域

可参考[beans-factory-scopes-custom](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom)。


---

# VIII.生命周期回调

> Spring容器保证，bean在完成所有依赖注入后执行init-method。因此该方法调用在raw bean reference（"生豆子时期"），这就意味着，AOP拦截器等还没作用于该Bean。即首先目标bean被完全创建和初始化后，AOP代理和它的拦截器执行链才能执行. 如果目标bean和proxy配置单独定义，代码甚至可以绕过代理与目标bean交互。因次，将拦截器应用于init-method是不合逻辑的，这样做会把目标bean的生命周期和其代理/拦截器耦合起来，并在代码与目标bean交互时留下奇怪的语义。

从Spring 2.5开始，有3种方式控制Bean生命周期行为：
- 自定义init-method和destroy-method
- @PostConstruct和@PreDestroy注解
- 实现InitializingBean和DisposableBean回调接口

## 1.init-method和destroy-method

通过init-method和destroy-method属性，可以指定单个Bean初始化后和销毁前的操作（POJO中的方法）。

> Java配置中，对应为@Bean(initMethod = "init", destroyMethod = "cleanup")

> 也可以在父标签beans中，通过default-init-method和default-destroy-method属性指定，对该beans下的所有bean都生效。此时需要约定这些bean的初始化方法和销毁前方法名一致（比如都叫init()和destroy()）。bean标签（如init-method）的配置可以覆盖beans标签的配置（如default-init-method），局部覆盖全局。

```xml
<!-- Lifecycle callbacks -->
<bean id="lifeCycleBean" class="com.baicai.pojo.lifecycle.LifeCycleBean" init-method="init" destroy-method="cleanup"/>
```

```java
public class LifeCycleBean {
    //空参构造
    public LifeCycleBean() {
        System.out.println("LifeCycleBean空参构造...");
    }
    
    //初始化后自动调用，方法名随意，要配置到xml中
    public void init(){
        // do some initialization work
        System.out.println("LifeCycleBean init...");
    }
    
    //Bean销毁前调用，方法名随意，要配置到xml中
    public void cleanup(){
        // do some destruction work (like releasing pooled connections)
        System.out.println("LifeCycleBean cleanup...");
    }
}
```

> 测试

```java
public void testLogin() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println(context.getBean("lifeCycleBean"));

    //需要手动关闭spring容器，此时会销毁对象，执行destroy-method
    ((ClassPathXmlApplicationContext) context).close();
}
```

销毁方法的执行必须满足两个条件：
- 单例bean才可以手动销毁（多例只有getBean时才会创建和初始化，并且没法销毁）
- 必须手动关闭容器（调用close()）时，才会执行手动销毁的方法

> 输出，其中多例对象只执行了init()，没有执行destroy()。

```java
LifeCycleBean空参构造...
LifeCycleBean init...
单例------
com.baicai.pojo.lifecycle.LifeCycleBean@1a3869f4
多例------
LifeCycleBean空参构造...
LifeCycleBean init...
com.baicai.pojo.lifecycle.LifeCycleBean@a38d7a3
LifeCycleBean cleanup...

 [INFO ] 2019-03-27 15:40:52,111 [method]org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:984)
Closing org.springframework.context.support.ClassPathXmlApplicationContext@63d4e2ba: startup date [Wed Mar 27 15:40:51 CST 2019]; root of context hierarchy
```

## 2.@PostConstruct和@PreDestroy

使用这两个注解的前提，需要先注册CommonAnnotationBeanPostProcessor。

```xml
<!-- 注解驱动，更优雅 -->
<context:annotation-config/>
<!--<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
```

> 使用@Autowired，需要在Spring容器中先声明AutowiredAnnotationBeanPostProcessor
> 使用@Required，需要先声明RequiredAnnotationBeanPostProcessor
> 使用@Resource、@PostConstruct、@PreDestroy等注解，需要先声明CommonAnnotationBeanPostProcessor
> 使用@PersistenceContext，需要先声明PersistenceAnnotationBeanPostProcessor的Bean
> 逐个注册这些BeanPostProcessor太过繁琐，Spring提供了更优雅的方式：**注解驱动**，隐式地注册上述4个BeanPostProcessor。

```java
public class LifeCycleBean {
    //空参构造
    public LifeCycleBean() {
        System.out.println("LifeCycleBean空参构造...");
    }
    
    @PostConstruct
    public void init(){
        // do some initialization work
        System.out.println("LifeCycleBean init...");
    }

    @PreDestroy
    public void cleanup(){
        // do some destruction work (like releasing pooled connections)
        System.out.println("LifeCycleBean cleanup...");
    }
}
```

关于@PostConstruct和@PreDestroy对方法的要求：包括权限、返回值、能否返回异常等，可查看注解的源码说明。

## 3.实现接口

> 该方式耦合度高，官方不推荐。

InitializingBean和DisposableBean接口，都只定义了一个方法，分别是afterPropertiesSet()和destroy()，对应初始化后和销毁前的操作。

```java
public class LifeCycleBean2 implements InitializingBean, DisposableBean {
    //空参构造
    public LifeCycleBean2() { System.out.println("LifeCycleBean2空参构造..."); }

    @Override
    public void destroy() throws Exception {
        System.out.println("LifeCycleBean2 destroy...");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("LifeCycleBean2 afterPropertiesSet...");
    }
}
```

```java
<bean id="lifeCycleBean2" class="com.baicai.pojo.lifecycle.LifeCycleBean2"/>
```

## 4.多种方式同时使用

上述三种方式可以同时多个作用于Bean，此时的执行顺序为：

- initialization methods：
    - 1.@PostConstruct
    - 2.afterPropertiesSet()
    - 3.custom init-method
- destroy methods
    - 1.@PreDestroy
    - 2.destroy()
    - 3.custom destroy-method

如果多个机制同时作用，并且方法名相同时，比如都是初始化后执行的方法都叫init，那么只会执行一个。

## 5.BeanPostProcessor

TODO


---

