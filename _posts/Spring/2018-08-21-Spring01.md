---
title: Spring入门（一）
date: 2018-08-21 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Java
---

本文将介绍Spring Framework核心概念之一的IoC相关内容。

<!-- more -->

##### 目录
+ I.Spring简介
+ II.IoC+DI介绍
+ III.IoC容器
+ IV.装配Bean
+ V.获取Bean
+ VI.依赖注入
+ VII.Bean作用域
+ VIII.生命周期回调
+ IX.名称空间
+ X.SpEL
+ XI.Spring的Web集成
+ XII.Spring的JUnit集成
+ XIII.开发方式
+ XV.参考

---

# I.Spring简介

[Spring](https://spring.io/)是分层的、JavaSE/EE一站式(full-stack)、轻量级开源框架。这里基于[Spring Framework-4.3.22.RELEASE](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-introduction)讲解。

> Spring4提供了对Java8的一些特性的支持，最低要求Java6（JDK 6 update 18），推荐使用Java7和8。

经典三层结构：
- 表现层（页面数据渲染、跳转调度），JSP/Servlet/Struts/SpringMVC等
- 业务层（业务逻辑实现、事务控制），JavaBean、EJB、spring等
- 持久层（数据操作），JDBC/Hibernate/Mybatis/Spring Data JPA等

Spring取代了相对臃肿的EJB，对上述三层都提供了解决方案，并且使用spring编程是**非侵入式**的。

## 1.Spring核心

- IoC

将对象的创建和管理交给Spring工厂。由Book book = new Book()变为Book book = Spring工厂.getBook()。**工厂模式 + 反射**

> **IoC强调将对象的创建交由Spring容器；DI更强调Spring容器把对象间的依赖关系也维护了**，两者实际是相同的概念。

- AOP

基于**动态代理**进行增强

## 2.Spring优点

Spring的出现是为了解决JavaEE开发中的实际问题，降低JavaEE API的使用难度。俗称为粘合剂

- 解耦，简化开发：所有对象的创建和依赖关系的维护，都可以交给Spring管理
- AOP编程：面向切面编程，方便实现对程序的权限拦截、运行监控等功能
- 声明式事务：通过配置就可以完成事务管理，代替耦合的手动编程
- 方便测试：支持集成Junit，通过注解可以方便地测试Spring程序
- 集成第三方框架：提供了对各种优秀框架的集成支持，易扩展可插拔
- 降低JavaEE的使用难度：对JavaEE中的一些API（JDBC、JavaMail、远程调用等）提供封装，降低这些API的使用难度


## 3.模块

Spring is modular。Spring Framework包含大概20个模块。这些模块可划分为7类：Core Container、Data Access/Integration、Web、AOP、Instrumentation、Messaging和Test。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/spring-overview.png)

#### 3.1 Core Container

包括spring-core、spring-beans、spring-context、spring-context-support、spring-expression (SpEL)。

spring-core和spring-beans模块提供了Spring最基础的功能：IoC和DI特性。**BeanFactory**是工厂模式的实现，它消除了对程序实现单例（programmatic singletons）的需要，将依赖关系和配置从程序逻辑中分离出来。

spring-context模块基于core和beans，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。context模块继承了beans模块的特性，还增加了国际化（I18N）、事件传播、资源加载，以及透明地创建上下文，例如通过Servlet容器创建。另外，context模块支持一些JavaEE特性，如EJB、JMX和basic remoting。**ApplicationContext**接口是context模块的核心。context-support提供了将常见的第三方库集成到Spring上下文的支持，如caching（EhCache，Guava，JCache）、mailing（JavaMail）、scheduling（CommonJ，Quartz）和template engines（FreeMarker，JasperReports，Velocity）。

spring-expression模块，提供了一个强大的EL，在运行期间查询和操作object graph。SpEL是JSP 2.1规范中unified EL的扩展。SpEL支持访问和修改属性值，属性指定，方法调用，访问数组、容器和索引器，逻辑和数学运算，命名变量，以及支持从Spring容器中获取Bean。它还支持列表投影、选择和一般的列表聚合等。

#### 3.2 AOP and Instrumentation

spring-aop模块提供了符合AOP联盟规范的、面向切面的编程实现。方便定义如方法拦截器和切入点，减少代码耦合。利用源码级的元数据功能，还可以将各种行为信息合并到代码中（和.NET属性相似的方式）。

spring-aspects模块，提供了对AspectJ的集成。

spring-instrument模块提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用。spring-instrument-tomcat模块包含了spring对Tomcat的代理instrumentation。

#### 3.3 Messaging

Spring4引入了spring-messaging模块，其中包含来自Spring集成项目的关键抽象，如Message、MessageChannel、MessageHandler等，可以作为基于消息的应用程序的基础。该模块还包括一组用于将消息映射到方法的注释，类似SpringMVC的基于注释的编程模型。

#### 3.4 Data Access/Integration

Data Access/Integration层包括了JDBC、ORM、OXM、JMS、Transaction模块。

spring-jdbc模块，提供对JDBC的抽象，用来消除冗长的JDBC编码和解析数据库厂商特有错误代码。

spring-tx模块，对实现特定接口的类和POJO，支持程序式和声明式事务管理。

spring-orm模块，提供了对常用"对象-关系映射"APIs的集成支持。包括JPA、JDO、Hibernate。使用该模块，可以将ORM框架和Spring提供的特性相结合，如声明式事务管理。

spring-oxm模块，提供一个抽象层，用于支持集成Object和XML映射的实现，包括JAXB、Castor、XMLBeans、JiBX和XStream。

spring-jms模块（Java Messaging Service），提供了生产和消费消息的特性。从Spring4开始，它和spring-messaging模块一起提供集成。

#### 3.5 Web

Web层包括spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet模块。

spring-web模块，提供了基础的web功能。例如多文件上传、使用Servlet listeners和一个web-oriented的application context实例化IoC容器。它还包含了一个HTTP Client和对远程访问的支持。

spring-webmvc模块（aka Web-Servlet模块），提供了MVC和REST Web服务的实现。SpringMVC框架将domain model code和web forms分离，并且继承了Spring框架的特性。

spring-webmvc-portlet模块（aka Web-Portlet模块），提供了在Portlet环境下的MVC实现，mirror基于servlet的spring-webmvc模块的功能

#### 3.6 Test
spring-test模块支持使用JUnit和TestNG，对Spring组件进行单元测试和集成测试。它提供一致的ApplicationContexts和这些上下文的缓存。它还提供一些mock对象，用来独立的测试代码。


---

# II.IoC+DI介绍

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/container-magic.png)

**Inverse of Control，IoC控制反转是种思想。正转：应用程序掌握主动，需要什么资源主动出击（程序中主动创建对象）。反转：在IoC中，应用程序变得被动，等待IoC容器来创建并注入它所需要的资源。无论正转反转，控制的都是依赖资源的获取**。

**Spring采用【工厂模式 + 反射 + 配置文件/注解】的方式，对IoC思想做了实现。**

> IoC和DI的关系

IoC is also known as dependency injection (DI). 
它们是**同一概念的不同角度描述**。控制反转比较含糊，可能只能理解为IoC容器控制对象这一层面，很难让人联想到谁来维护对象间的依赖关系。所以2004年Martin Fowler又提出DI依赖注入，相比IoC，DI更明确描述了"**被注入对象依赖IoC容器配置依赖对象**"。

> 但这里还是把IoC和DI分开讲解，把IoC"理解成"容器管理对象，把DI"理解成"容器也管理对象间的依赖关系。拆开讲更清晰，但实际两者是同一概念。

## 1.IoC原理

这里对比3种开发方式，来理解IoC的实现原理

#### 1.1 传统方式

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //传统方式-自己实例化对象
        UserDao userDao = new UserDaoImpl();
        userDao.selectOne();
    }
}
```

**手动创建实例，应用程序主动获取它所依赖资源（正转）。对象间的依赖关系也是在业务代码中维护的，耦合度高，另外，（UserDao的）实现类的切换不灵活**。

#### 1.2 传统方式改进

使用工厂模式+反射+配置文件（IoC原理）

> 简单起见，这里省略了配置文件，直接使用了字符串。可参考下述Spring方式，将类全路径放入配置文件。

```java
public class UserDaoFactory {
    //方式1-耦合性仍然强: UserDaoFactory和UserDaoImpl耦合
    /*
    public UserDao getUserDao() {
        UserDao userDao = new UserDaoImpl();
        return userDao;
    }*/
    
    //方式2-反射创建实例
    public Object getBean() {
        Object bean = null;
        try {
            bean = Class.forName("com.test.IoC.principle.UserDaoImpl").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        UserDao userDao = (UserDao) factory.getBean();

        userDao.selectOne();
    }
}
```

#### 1.3 Spring方式

- a.引入依赖

不使用maven时，也可以手动加入[Spring相关jar](http://repo.spring.io/libs-release-local/org/springframework/spring/4.3.22.RELEASE/)。

> 这里最简可以只引入：spring-context、log4j

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
</dependency>
<!-- context中引用了core、beans、expression、aop -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
</dependency>

<!-- JCL + Log4j -->
<!-- spring-core中也有JCL-1.2，这里可以省略 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>
```

> 对Spring来说，日志很重要。首先，日志是Spring唯一的"强制性外部依赖"。其次，由于Spring集成的第三方库的日志实现各种各样。开发者需要在一个集中的地方，使用统一的日志配置，来管理整个应用的日志输出。这里采用JCL+Log4j。

- b.配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 一个bean标签对应spring工厂创建的一个实例(反射机制)
        id/name:对象引用, class:类全路径 -->
    <bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

</beans>
```

- c.工厂+反射

Spring为我们提供了ApplicationContext工厂，并内部实现了通过反射创建Bean。

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        //UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        //UserDao userDao = (UserDao) factory.getBean();

        //3.Spring方式
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        UserDao userDao = (UserDao) context.getBean("userDao");
        userDao.selectOne();
    }
}
```

Spring方式解决了类之间的耦合，但在每次获取对象的时候（比如Controller中依赖Service），都需要创建ApplicationContext，能不能更方便地获取对象，或更方便地解决userService依赖userDao?
答案就是DI依赖注入。既然这些对象都由Spring容器创建和管理，那么对象间的依赖关系也可以交由ApplicationContext维护。


## 2.DI原理

Dependency Injection，依赖注入

组件之间的依赖关系由Spring容器在运行期决定，即由容器动态的将依赖注入到组件中。DI是为了降低耦合度，提高组件重用性。通过依赖注入机制，无需任何代码，仅使用简单的配置就可以完成指定目标的依赖资源注入，完成自身的业务逻辑，而不需要关心依赖资源来自何处，由谁实现。
 
- 谁依赖于谁：应用程序依赖IoC容器（或一个Bean依赖另一个Bean）
- 为什么依赖：应用程序需要IoC容器来提供对象需要的外部资源
- 谁注入给谁：IoC容器注入依赖资源给应用程序
- 注入了什么：某对象所需要的外部资源（包括对象、资源、常量数据）

> 如上例子中，通过下面的依赖注入改造，就可以省去在UserServiceImpl中创建context，然后getBean。而是将UserService和UserDao的依赖关系交由Ioc容器管理，并在创建UserService实例后就注入UserDao。

```java
public class UserServiceImpl implements UserService {

    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void login() {
        System.out.println("service层被调用了");
        userDao.selectOne();
    }
}
```

```xml
<bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

<bean id="userService" class="com.baicai.service.UserServiceImpl">
    <property name="userDao" ref="userDao"/>
</bean>
```

> Junit测试时，不能new UserServiceImpl()了，要通过Spring容器获取userService（注入了UserDao的）

这里只是依赖注入的一种方式（setter），后面会详细汇总DI的实现方式

#### 2.1 依赖注入流程

IoC的依赖注入流程：

- 1.创建ApplicationContext，并使用Configuration metadata初始化（配置包括XML、Java配置、注解）
- 2.对每个Bean，其依赖可以通过成员变量、构造方法参数、静态工厂方法参数来表示。当Bean创建完成时，会注入其依赖
- 3.依赖可以是直接赋值的变量（value），或指向容器中其他Bean的引用（ref）
- 4.依赖值会转化成声明的类型。Spring默认可以把字符串值转换成如int、long、String、boolean等

在创建容器时，Spring容器会验证每个bean的配置。但Bean属性直到该Bean创建时才会被赋值。pre-instantiated（默认值，也可设置成懒加载）的单例Bean，在容器创建时就会创建，否则（多例或懒加载的Bean）在getBean时才会被创建。某个Bean的创建，会潜在的导致一连串Bean（它依赖的Bean依赖的Bean..）被创建。依赖间的不匹配可能会出现得稍晚，比如在第一次创建受影响的Bean时。

#### 2.2 循环依赖

Circular dependencies。当使用构造方式注入时，可能出现循环依赖。

比如：A通过构造注入依赖B，B也通过构造注入依赖A，运行时IoC容器检测到该循环依赖，会报BeanCurrentlyInCreationException。

循环依赖会强制在完全初始化之前，将其中一个bean注入另一个bean（典型的先有鸡还是先有蛋场景）

不推荐使用循环依赖。如果非要使用，解决方式：使用setter注入代替构造注入，或者只使用setter注入。

#### 2.3 注入前后的细节

在IoC容器加载时，Spring会检测配置的合法性，比如ref指向了不存在的bean、循环依赖等。在Bean创建完成后Spring才会设置属性和注入依赖。这意味着，即使Spring容器已经被正确的加载了，当getBean时，如果该对象的创建或其依赖的创建出现问题，仍会抛出异常。**这种延迟暴露潜在配置问题的情形，正是ApplicationContext默认使用pre-instantiate单例的原因**。即在实际需要这些bean之前就创建它们，会牺牲前期时间和内存。这样在创建ApplicationContext时就可以发现配置问题，不会延迟暴露。当然也可以修改该默认行为，让单例bean延迟初始化。

**如果不存在循环依赖，当一个或多个bean被注入到另一个bean之前，这些bean都已完全配置好**。即如果A依赖B，IoC容器会先完全配置好B，然后再调用A的setter注入。**执行顺序：bean实例化-依赖注入-生命周期回调方法**


---

# III.IoC容器

又称应用上下文、Spring容器、Spring工厂等

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/ApplicationContext-System.png)

ApplicationContext是BeanFactory的子接口。官方推荐使用ApplicationContext（更强大），两者的对比参考[ctx-vs-beanfactory](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#context-introduction-ctx-vs-beanfactory)。

> 另外，BeanFactory是延迟加载，第一次getBean()时才会初始化Bean。

## 1.创建容器

TODO

## 2.查看容器中的Bean

```java
//Return the names of all beans defined in this factory
String[] str=context.getBeanDefinitionNames();
for (String string : str) {
    System.out.println(string);
}
```

## 3.关闭non-web applications

尽量使用ConfigurableApplicationContext提供的registerShutdownHook()或close()来关闭Spring容器，会释放容器中的Bean，执行**单例Bean**的销毁回调方法。否则可能会有未释放的资源。

```java
/* 1.强转 */
//放在业务代码后面，一般在main()的最后
((ClassPathXmlApplicationContext) context).close();
//可以放在业务代码前
((ClassPathXmlApplicationContext) context).registerShutdownHook();

/* 2.反射 */
Method method = applicationContext.getClass().getMethod("close");
method.invoke(applicationContext);
```

其中registerShutdownHook()是在JVM中注册一个shutdown hook，这个钩子不是默认注册的，需要手动注册。其他JVM应用也都有类似的关闭钩子，如Hadoop、SparkContext等。

> JVM的关闭钩子是通过Runtime#addShutdownHook(Thread hook)方法来实现的。所谓的shutdown hook就是一系例的已初始化但尚未执行的线程对象。JVM正常关闭时，这些shutdown hook线程会被执行，包括：操作系统正常关闭、用户注销、用户调用System.exit(0)、kill、Ctrl+C等。断电、kill -9等非正常关闭JVM时则不会被调用

> web-based的ApplicationContext的实现类中，已经有编码实现：当相关的Web应用关闭时，会优雅地关闭IoC容器。


---

# IV.装配Bean

## 1.XML方式

即将Bean交由Spring IoC容器管理。Spring提供了4种XML方式[装配bean](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class)。

> 这里四种方式在注解开发中很少用到，偶尔使用第一种方式。其他方式在Spring底层和整合第三方框架时用的较多。

#### 1.1 [无参构造](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-ctor)

Spring在创建bean时，自动调用无参构造来实例化对象。此时需要有无参构造，也是最常用的方式。

```java
public class Bean1 {
    //默认系统给空参构造
}
```

```xml
<bean id="bean1" class="com.test.IoC.bean.xml.Bean1"/>
```

> 如果Bean1中没有无参构造（只有有参构造），则报NoSuchMethodException: com.baicai.pojo.Bean1.<init>()

#### 1.2 [静态工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-static-factory-method)

需要提供一个工厂类，其中包括一个静态方法

```java
public class Bean2 {    
}
```

```java
public class Bean2Factory {
    //静态方法，方便调用
    public static Bean2 getBean2() {
        //do other things,like Connection to Driver...
        return new Bean2();
    }
}
```

```xml
<bean id="bean2" class="com.baicai.pojo.Bean2Factory" factory-method="getBean2"/>
```

#### 1.3 [工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method)

该方式需先配置工厂实例，区别于静态工厂方式。（因为是非静态方法，所以需要先创建工厂实例，才能调用方法）

```java
public class Bean3 {    
}
```

```java
public class Bean3Factory {
    //非静态方法，需要先创建工厂实例，才能调用
    public Bean3 getBean3() {
        //do other things,like Connection to Driver
        return new Bean3();
    } 
}
```

```xml
<bean id="bean3Factory" class="com.baicai.pojo.Bean3Factory"/>
<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"/>
```

#### 1.4 实现FactoryBean接口

该方式在spring底层源码用的多。
Spring在实例化bean时，会判断是否实现了FactoryBean接口。如果实现了就调用getObject方法返回目标类型实例。

```java
public class Bean4 {    
}
```

```java
public class Bean4FactoryBean implements FactoryBean<Bean4> {
    @Override
    public Bean4 getObject() throws Exception {
        //do other things,like Connection to Driver
        return new Bean4();
    }

    @Override
    public Class<?> getObjectType() { return null; }

    @Override
    public boolean isSingleton() { return false; }
}
```

```xml
<bean id="bean4" class="com.baicai.pojo.Bean4FactoryBean"/>
```

###### BeanFactory和FactoryBean的区别

- BeanFactory：是Spring容器的超级接口。ApplicationContext是其子接口，但功能更强大，用来管理Bean
- FactoryBean：是一个Bean生成工具，是用来获取一种类型对象的Bean，它是构造Bean实例的一种方式。

> 如果一个Bean实现了FactoryBean，对外就会被作为某组件的工厂，而非一个Bean。

## 2.注解方式

使用@Component及其衍生注解@Controller、@Service、@Repository，配置Bean。

- 开启注解驱动、组件扫描

```xml
<!-- 注解驱动，有component-scan时可省略 -->
<!-- <context:annotation-config/> -->

<!-- 注解扫描，会自动开启注解驱动
     扫描@Component注解的类，将其配置为容器bean；base-package：扫描的包路径,包含子包下的类
-->
<context:component-scan base-package="com.test.ioc.bean.anno"/>
```

- 使用注解

```java
@Service
public class UserServiceImpl implements UserService {
    ...
}
```

相当于：

```xml
<bean id="userServiceImpl" class="com.baicai.service.UserServiceImpl"/>
```

> 注意，此时配置的Bean的id为userServiceImpl，而非userService。

---

# V.获取Bean

从IoC容器获取Bean的方式有多种，即getBean有多个重载方法。常用的有两种：

- 根据id/name查找（唯一）
- 根据Bean类型或接口类型查找（一般使用接口类型，会自动去找实现类）

```java
getBean(String name)
getBean(Class<T> requiredType)
```

> 示例

```java
UserService userService = (UserService) ac.getBean("userService");
UserService userService = (UserService) ac.getBean(UserService.class);
```

> 根据类型查找Bean时，可能存在多个，此时报NoSuchBeanDefinitionException:No unique bean of type...


---

# VI.依赖注入

依赖注入，实际就是给Bean属性赋值，赋的一般也是IoC容器管理的bean实例或资源。

上述示例中使用DI为userService注入了同样由spring管理的userDao实例。下面详细讲述依赖注入的实现方式。

## 1.XML方式

#### 1.1 Setter-based

使用setter，配合property属性，完成依赖注入。最常用。

```xml
<bean id="car" class="com.baicai.pojo.di.Car"/>

<!-- 空参 + setter -->
<bean id="user" class="com.baicai.pojo.di.User">
    <property name="id" value="1"/>
    <property name="name" value="Tom"/>
    <property name="car" ref="car"/>
</bean>
```

对于Car：要有空参构造 
对于User：
- 要有空参构造和对应3个属性的setter
- name中的值跟着setter走，首字母大小写都可以

> 这里name属性值取决于setter方法名，而非成员变量。当然一般成员变量名和setter后缀一致（即xxx对应setXxx）。Spring会将name值的首字母转成大写，然后在前面拼接上"set"构成一个方法名，去对应类中查找该方法。通过反射调用，实现注入。

#### 1.2 Constructor-based

有参构造 + constructor-arg标签，底层会调用有参构造初始化

```xml
<bean id="car" class="com.baicai.pojo.di.Car">
    <constructor-arg name="id" value="11"/>
    <constructor-arg name="name" value="Benz"/>
</bean>
```

此时要求Car要有有参构造：Car(int id, String name)或Car(String name, int id)（当重载方法同时存在时，执行先声明的那个）

关于constructor-arg标签的属性：
- 定位：
    - index：根据索引定位属性，以0开始
    - name：根据属性名定位属性
    - type：根据属性的数据类型定位属性
    - 可以多个定位属性同时使用
- 赋值：
    - value：简单的值，字符串
    - ref：spring容器中已存在的bean

> 即上述示例还可以表示为：

```xml
<bean id="car" class="com.baicai.pojo.di.Car">
    <constructor-arg index="0" name="id" value="11"/>
    <constructor-arg type="java.lang.String">
        <value>Benz</value>
    </constructor-arg>
</bean>
```

> 另外还有大家常说的**接口注入**方式：在UserSevice中声明UserDao成员变量，在具体方法中创建UserDao实现类实例（直接new或工厂方法等）。该方式不需要XML配置，耦合度高，跟Spring也没关系，所以这里不做介绍。

#### 1.3 Constructor-based or setter-based DI？

官方推荐以构造方式为主，setter方式为辅，具体参考[Constructor-based or setter-based DI?](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-setter-injection)

## 2.注解方式

注入的资源一般分为简单数据（对应XML方式的value）、容器中已存在的资源（对应XML方式的ref）。

- 简单数据使用@Value，配合${}和#{}注入
- 容器中的bean
    + 按id注入
    + 按class注入

#### 2.1 @Value

一般和配置文件配合使用，用于注入指定默认值。作用于：成员变量、方法上、方法/构造形参上。

可以注入简单的值，也可以**按id查找注入**容器中的bean或资源

常和${}和#{}配合使用
- #{}：常用于获取容器中的bean或bean属性
- ${}：常用于获取配置文件的k-v对（#{}也可以，稍麻烦）

> 这里Test要能访问到jdbc.username，即Spring引入了jdbc.properties文件，可以获取到键值对

```java
//注入简单的值，相当于直接赋值
@Value(value = "Rose")
private String name;

//使用${}获取配置文件键值对
@Value("${jdbc.username:root}")
private String username;

//使用#{}获取配置文件键值对，请见下述
```

```xml
<context:property-placeholder location="classpath:jdbc.properties"/>
```

> 这里Test要能访问到userDao和dataSource.url，即userDao和dataSource也在Test所在IoC容器或父容器，并且url是public的或提供了setter

```java
//使用#{}注入bean（此时可省略setUserDao()）
@Value("#{userDao}")
private UserDao userDao;

//使用#{}注入bean（作用在setter）
private UserDao userDao;
@Value("#{userDao}")
public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
}

//使用#{}注入bean属性此时可省略setJdbcUrl()）
@Value("#{dataSource.url}")
private String jdbcUrl;

//使用#{}注入bean属性（作用在setter）
private String jdbcUrl;
@Value("#{dataSource.url}")
public void setJdbcUrl(String jdbcUrl) {
    this.jdbcUrl = jdbcUrl;
}
```

> 如上，@Value也可以加在setter上，和直接加在成员变量上一样（底层也是使用setter注入，可以省略setter声明）。

###### 作用于方法和构造的形参

> 很少作用于方法。因为调用方法需要传实参，注入默认值没意义

```java
private String username;
public void test(@Value("${jdbc.username}") String username) {
    this.username = username;
}
```

```java
@Service
public class UserServiceImpl implements UserService {
    private UserDao userDao;
    //不提供空参构造，让@Service使用有参构造
    public UserServiceImpl(@Value("#{userDao}") UserDao userDao){
        this.userDao = userDao;
    }
    ...
}
```

###### #{}获取配置文件键值对

\#{}也可以获取配置文件键值对，只不过比${}稍麻烦

- 引入配置文件（两种方式，2选1）

不再使用context:property-placeholder方式了

```xml
<!--<bean id="jdbcProp" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
    <property name="locations">
        <list>
            <value>classpath:jdbc.properties</value>
        </list>
    </property>
</bean>-->
<util:properties id="jdbcProp" location="classpath:jdbc.properties"/>
```

- 获取键值对

```java
@Value("#{jdbcProp['jdbc.username']}")
private String username;
```

###### 静态成员的注入

不能直接给静态成员注入，可以加在其setter上（setter是非静态的）。

```java
//不能直接给静态成员注入
@Value("${jdbc.username}")
private static String username;
```

```java
//可以通过setter给静态成员赋值
private static String username;

@Value("${jdbc.username}")
public void setUsername(String username) {
    this.username = username;
}
```

#### 2.2 @Autowired

**按类型查找注入**：在容器中查找class为userDao的bean。该方式最常用

```java
@Autowired
private UserDao userDao;
```

不存在，报NoSuchBeanDefinitionException。

#### 2.3 @Autowired + @Qualifier

**按id查找注入**

> Autowired默认按class注入；想按id注入，必须配合@Qualifier

```java
@Autowired
@Qualifier("userDao")
private UserDao userDao;
```

#### 2.4 @Resource

JSR-250提供的@Resource，非Spring的注解。

**默认先按id查找，如果没找到，再按型class查找。如果使用了name属性，只会按id查找**。

```java
@Resource
private UserDao userDao;
```

> 以下方式只按id查找，找不到不会走class，直接抛异常

```java
@Resource(name = "userDao")
private UserDao userDao;
```

#### 2.5 @Inject

JSR-330提供的@Inject,非Spring的注解。需要先导入javax.inject-1.jar

**按class查找注入**

```xml
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
```

```java
@Inject
private UserDao userDao;
```

#### 2.6 @Inject + @Named

**按id查找注入**

```java
@Inject
@Named("userDao")
private UserDao userDao;
```

#### 2.7 总结

以上几种方式也都可以注解到setter上（直接注解到成员时，底层会创建setter，所以可以缺省）。另外，方法名不一定是setUserDao，可以任意，因为是**按形参注入**的。

```java
private UserDao userDao;

//@Autowired
/*@Autowired
@Qualifier("userDao")*/
//@Resource()
//@Resource(name = "userDao")
//@Inject
@Inject
@Named("userDao")
public void abc(UserDao userDao) {  //setter方法名可以任意，但一般setXxx
    this.userDao = userDao;
}
```

---

# VII.[Bean作用域](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes)

## 1.作用域类型

|Scope|Description|
|[singleton](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton)|（默认）在Spring IoC容器中仅存在一个Bean实例|
|[prototype](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype)|每次从容器获取Bean时，都会返回一个新实例。即getBean()相当于new Bean()|
|request|每次HTTP Request都会创建新实例。该作用域仅适用于WebApplicationContext环境（如XmlWebApplicationContext，否则报unknown bean scope）|
|session|每个HTTP Session拥有一个Bean实例。仅适用于WebApplicationContext环境|
|globalSession|每个global HTTP Session拥有一个Bean实例，常用于Portlet应用环境。仅适用于WebApplicationContext环境|
|application|每个ServletContext拥有一个Bean实例。仅适用于WebApplicationContext环境|
|websocket|每个WebSocket拥有一个Bean实例。适用于WebApplicationContext环境|

常用singleton（默认）和prototype。除单例外，其他作用域需要显示声明。

- singleton：每次获取的是同一个对象；在IoC容器初始化时，就初始化了
- prototype：每次获取的是不同对象；**在getBean时，才创建和初始化**

> 当一个单例Bean A依赖一个多例Bean B时，IoC只会初始化A一次，所以每次获取A时，A所依赖的B也是同一个Bean。如果想每次获取A时，注入的是不同的B，参考[beans-factory-method-injection](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-method-injection)。

关于web环境下的几个scope，参考[beans-factory-scopes-other](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-other)

## 2.示例

#### 2.1 XML方式

```xml
<bean id="singleton" class="com.baicai.pojo.SingletonBean"/>
<bean id="prototype" class="com.baicai.pojo.PrototypeBean" scope="prototype"/>
```

```java
public class SingletonBean {
    public SingletonBean() {
        System.out.println("单例初始化...");
    }
}

public class PrototypeBean {
    public PrototypeBean() {
        System.out.println("多例初始化...");
    }
}
```

```java
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println("第1次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));
    System.out.println("第2次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));

    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
}

//输出结果
单例初始化...
第1次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第2次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@1a3869f4
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@a38d7a3
```

#### 2.2 注解方式

```java
@Component
//@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Scope("prototype")
public class AnnoScopeBean {
    ...
}
```


## 3.自定义作用域

可参考[beans-factory-scopes-custom](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom)。


---

# VIII.生命周期回调

> Spring容器保证，bean在完成所有依赖注入后执行init-method。因此该方法调用在raw bean reference（"生豆子时期"），这就意味着，AOP拦截器等还没作用于该Bean。即首先目标bean被完全创建和初始化后，AOP代理和它的拦截器执行链才能执行. 如果目标bean和proxy配置单独定义，代码甚至可以绕过代理与目标bean交互。因次，将拦截器应用于init-method是不合逻辑的，这样做会把目标bean的生命周期和其代理/拦截器耦合起来，并在代码与目标bean交互时留下奇怪的语义。

从Spring 2.5开始，有3种方式控制Bean生命周期行为：
- 自定义init-method和destroy-method
- @PostConstruct和@PreDestroy注解
- 实现InitializingBean和DisposableBean回调接口

## 1.init-method和destroy-method

通过init-method和destroy-method属性，可以指定单个Bean初始化后和销毁前的操作（POJO中的方法）。

> Java配置中，对应为@Bean(initMethod = "init", destroyMethod = "cleanup")

> 也可以在父标签beans中，通过default-init-method和default-destroy-method属性指定，对该beans下的所有bean都生效。此时需要约定这些bean的初始化方法和销毁前方法名一致（比如都叫init()和destroy()）。bean标签（如init-method）的配置可以覆盖beans标签的配置（如default-init-method），局部覆盖全局。

```xml
<!-- Lifecycle callbacks -->
<bean id="lifeCycleBean" class="com.baicai.pojo.lifecycle.LifeCycleBean" init-method="init" destroy-method="cleanup"/>
```

```java
public class LifeCycleBean {
    //空参构造
    public LifeCycleBean() {
        System.out.println("LifeCycleBean空参构造...");
    }
    
    //初始化后自动调用，方法名随意，要配置到xml中
    public void init(){
        // do some initialization work
        System.out.println("LifeCycleBean init...");
    }
    
    //Bean销毁前调用，方法名随意，要配置到xml中
    public void cleanup(){
        // do some destruction work (like releasing pooled connections)
        System.out.println("LifeCycleBean cleanup...");
    }
}
```

> 测试

```java
public void testLogin() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println(context.getBean("lifeCycleBean"));

    //需要手动关闭spring容器，此时会销毁对象，执行destroy-method
    ((ClassPathXmlApplicationContext) context).close();
}
```

销毁方法的执行必须满足两个条件：
- 单例bean才可以手动销毁（多例只有getBean时才会创建和初始化，并且没法销毁）
- 必须手动关闭容器（调用close()）时，才会执行手动销毁的方法

> 输出，其中多例对象只执行了init()，没有执行destroy()。

```java
LifeCycleBean空参构造...
LifeCycleBean init...
单例------
com.baicai.pojo.lifecycle.LifeCycleBean@1a3869f4
多例------
LifeCycleBean空参构造...
LifeCycleBean init...
com.baicai.pojo.lifecycle.LifeCycleBean@a38d7a3
LifeCycleBean cleanup...

 [INFO ] 2019-03-27 15:40:52,111 [method]org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:984)
Closing org.springframework.context.support.ClassPathXmlApplicationContext@63d4e2ba: startup date [Wed Mar 27 15:40:51 CST 2019]; root of context hierarchy
```

## 2.@PostConstruct和@PreDestroy

使用这两个注解的前提，需要先注册CommonAnnotationBeanPostProcessor。

```xml
<!-- 注解驱动，更优雅 -->
<context:annotation-config/>
<!--<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
```

> 使用@Autowired，需要在Spring容器中先声明AutowiredAnnotationBeanPostProcessor
> 使用@Required，需要先声明RequiredAnnotationBeanPostProcessor
> 使用@Resource、@PostConstruct、@PreDestroy等注解，需要先声明CommonAnnotationBeanPostProcessor
> 使用@PersistenceContext，需要先声明PersistenceAnnotationBeanPostProcessor的Bean
> 逐个注册这些BeanPostProcessor太过繁琐，Spring提供了更优雅的方式：**[注解驱动](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-java)**，隐式地注册上述4个BeanPostProcessor。

```java
public class LifeCycleBean {
    //空参构造
    public LifeCycleBean() {
        System.out.println("LifeCycleBean空参构造...");
    }
    
    @PostConstruct
    public void init(){
        // do some initialization work
        System.out.println("LifeCycleBean init...");
    }

    @PreDestroy
    public void cleanup(){
        // do some destruction work (like releasing pooled connections)
        System.out.println("LifeCycleBean cleanup...");
    }
}
```

关于@PostConstruct和@PreDestroy对方法的要求：包括权限、返回值、能否返回异常等，可查看注解的源码说明。

## 3.实现接口

> 该方式耦合度高，官方不推荐。

InitializingBean和DisposableBean接口，都只定义了一个方法，分别是afterPropertiesSet()和destroy()，对应初始化后和销毁前的操作。

```java
public class LifeCycleBean2 implements InitializingBean, DisposableBean {
    //空参构造
    public LifeCycleBean2() { System.out.println("LifeCycleBean2空参构造..."); }

    @Override
    public void destroy() throws Exception {
        System.out.println("LifeCycleBean2 destroy...");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("LifeCycleBean2 afterPropertiesSet...");
    }
}
```

```java
<bean id="lifeCycleBean2" class="com.baicai.pojo.lifecycle.LifeCycleBean2"/>
```

## 4.多种方式同时使用

上述三种方式可以同时多个作用于Bean，此时的执行顺序为：

- initialization methods：
    - 1.@PostConstruct
    - 2.afterPropertiesSet()
    - 3.custom init-method
- destroy methods
    - 1.@PreDestroy
    - 2.destroy()
    - 3.custom destroy-method

如果多个机制同时作用，并且方法名相同时，比如都是初始化后执行的方法都叫init，那么只会执行一个。

## 5.BeanPostProcessor

Bean处理器。在Bean初始化前后，**非侵入式**的对Bean对象进行增强。可以增强指定的Bean，也可以增强所有Bean。

上面提到很多注解都依赖不同的BeanPostProcessor实现，包括@PostConstruct和@PreDestroy。如果上述Spring提供的开箱即用的生命周期行为，不能满足开发需要，或者需要自定义一些特性，就可以自定义一个BeanPostProcessor实现。

```java
public interface BeanPostProcessor {
    //初始化前调用
    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
    //初始化后调用
    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
```

> 参数bean：spring管理的bean对象、参数beanName：id或name属性

底层很多功能（如注解、AOP等）的实现都是基于它。如果注册了BeanPostProcessor，Spring会采用动态代理的方式，对目标bean增强。

> 示例

```java
public class MyBeanPostProcessor implements BeanPostProcessor {
    
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        
        //System.out.println(beanName + "初始化前增强...");    //增强所有bean
        if(beanName.equals("car")){                         //增强指定bean
            System.out.println(beanName + "在初始化前开始增强了");
        }
        return bean;//放行
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        //System.out.println(beanName + "初始化后增强...");    //增强所有bean
        if(beanName.equals("car")){                          //增强指定bean
            System.out.println(beanName + "在初始化后开始增强了");
        }
        return bean;
    }
}
```

```xml
<bean id="myBeanPostProcessor" class="com.baicai.pojo.MyBeanPostProcessor"/>
```

```java
System.out.println(context.getBean("user"))

//输出
Loading XML bean definitions from class path resource [applicationContext.xml]
car在初始化前开始增强了
car空参构造...
car在初始化后开始增强了
```

更多可参考[Container Extension Points](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension)

---

# IX.名称空间

名称空间用于Schema区分同名元素。（类似于java的包）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
```

Xmlns没有前缀，是默认的名称空间。

## 1.p名称空间

为简化XML文件的配置，Spring2.5引入了[p名称空间](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-p-namespace)，用于代替property标签，方便使用元素值，简化setter方法属性注入。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">
```

> 只在Spring中使用，并没有在XSD中定义。

使用方法：
- p:属性名="xxx" 简单数据类型、String（value）
- p:属性名-ref="xxx" 容器中其他bean 

```xml
<bean id="user" class="com.baicai.pojo.di.User" p:id="2" p:name="Jerry" p:car-ref="car"/>
```

## 2.c名称空间

参考[beans-c-namespace](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-c-namespace)


---

# X.SpEL

Spring Expression Language是Spring3引入的一种表达式语言。支持在运行时操作和查询对象，语法类似unified EL，但是SpEL提供了额外的功能，更强大。

> 关于EL、OGNL、spEL

- EL：操作servlet相关的对象和值
- OGNL：主要操作struts2值栈
- SpEL：操作bean相关

语法： #{…} , 引用另一个Bean、属性、方法、运算（取其他类的属性值时，依赖getXxx方法）

SpEL功能较多，其中常用于bean操作相关的有：
- #{beanid}：引用bean对象
- #{beanId.属性}：引用bean属性
- #{beanId.方法(参数)}：引用bean方法 

```xml
<bean id="user" class="com.baicai.pojo.di.User" p:id="1" p:name="Lucy" p:car-ref="car"/>

<bean id="user1" class="com.baicai.pojo.di.User">
    <property name="id" value="#{user.id + 1}"/>
    <property name="name" value="#{user.name}"/>
    <property name="car" ref="car"/>
</bean>

<bean id="user2" class="com.baicai.pojo.di.User" p:id="#{user.id + 2}" p:name="#{user.name + 'Kin'}"/>

<bean id="user3" class="com.baicai.pojo.di.User" p:id="#{1 + 3}" p:name="#{'bmw'.toUpperCase()}"/>
```

> 抛异常：

```java
org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'id' cannot be found on object of type 'com.baicai.pojo.di.User' - maybe not public or not valid?
```

> 原因

spEL需要访问对象的属性时，要求对象的属性能访问到，所以：
- 1.要么属性为public（不能是default或private等）
- 2.要么私有属性提供getter（常用）

> 在User中添加getter或公开属性后：

```java
User{id=1, name='Lucy', car=Car{id=11, name='Benz'}}
User{id=2, name='Lucy', car=Car{id=11, name='Benz'}}
User{id=3, name='LucyKin', car=null}
User{id=4, name='BMW', car=null}
```

更多关于SpEL表达式，参考[expressions](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#expressions)


---

# XI.Spring的Web集成

将Spring容器绑定成Servlet容器属性，保证Web应用中只有一个spring容器。

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>servlet-api</artifactId>
</dependency>
```

## 1.传统方式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">   
    <context:component-scan base-package="com.baicai.web"/>
</beans>
```

> Servlet也可以在Web.xml中配置，这里使用注解方式。

```java
@WebServlet(name = "HelloServlet", urlPatterns="/", loadOnStartup = 1)
public class HelloServlet extends HttpServlet {
    
    private static final long serialVersionUID = 1L;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //传统方式：
        //HelloService helloService = new HelloService();
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext-web.xml");
        HelloService helloService=(HelloService)ac.getBean("helloService");
        helloService.sayHello();
        
        response.setContentType("text/html;charset=utf-8");//中文乱码
        response.getWriter().print("来自HelloServlet响应");
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request, response);
    }
}
```

上述方式虽然是从IoC容器获取bean，但每次request都会创建ac实例，而IoC容器创建时也会创建单例无懒加载的bean和其他资源，即每个request使用是不同的HelloService。非应用级别的单例，还会消耗资源。

> 解决方案：将ApplicationContext绑定到ServletContext容器上，实现应用级别的单例

ServletContext是Web应用的唯一容器。在其初始化时，会自动执行ServletContextListener监听器。所以可以实现ServletContextListener接口，在监听到ServletContext创建时，创建Spring容器，并绑定到ServletContext属性上。实际上，无需自定义监听器，Spring提供了ContextLoaderListener监听器，位于spring-web。

> ContextLoaderListener中的具体操作，可查看源码initWebApplicationContext()。

## 2.spring方式

- 引入依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
</dependency>
```

- web.xml中配置Spring提供的监听器

```xml
<!-- spring web监听器，监听到ServletContext创建时，跟着创建ApplicationContext，并作为属性绑定到ServletContext上 -->
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

<!-- 指定spring配置文件路径 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext-web.xml</param-value>
</context-param>
```

> 如果不指定spring配置文件，默认使用/WEB-INF/applicationContext.xml。

- 修改HelloServlet中获取IoC容器的方式

两种方式

```java
//方式1
//ApplicationContext ac = (ApplicationContext) request.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
//ApplicationContext ac = (ApplicationContext) this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);

//方式2
//WebApplicationContext是ApplicationContext的子接口
WebApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());
```

至此，多次请求，不再多次创建ApplicationContext。

> 使用Web框架SpringMVC，会更方便。

# XII.Spring的JUnit集成

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
</dependency>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>
```

```java
//JUnit整合spring，开启该类下的spring注解功能（不是全局）
@RunWith(SpringJUnit4ClassRunner.class)
//加载核心配置文件，（在该类中）自动构建spring容器
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class SpringTest {

    //不使用ac.getBean了
    @Autowired
    private UserService userService;

    @Test
    public void testLogin() {
        /* 不再需要手动创建ApplicationContext */
        userService.login();
    }
}
```


---

# XIII.开发方式

## 1.纯XML

需要在XML中配置bean、各种组件、依赖注入。虽然可以分割XML文件，但太过繁琐，配置文件臃肿，不推荐。

## 2.XML+注解

- 分割XML文件管理
- 使用注解完成bean配置和依赖管理
- 使用XML配置其他组件和功能、整合其他框架

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">   
    <context:component-scan base-package="com.baicai.service"/>
</beans>
```

## 3.Java+注解

这里简单展示一个示例，更多可参考[Java-based container configuration](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-java)

```java
@Configuration
@Import(SpringConfig1.class)
@ComponentScan(basePackages = {"com.baicai.service","com.baicai.dao"})
@PropertySource(value = {"classpath:jdbc.properties"}, ignoreResourceNotFound = true)
public class SpringConfig {

    @Bean(initMethod = "init", destroyMethod = "destory")
    public MyBean myBean() {
        return new MyBean();
    }

    @Bean
    @Scope("prototype")
    public MyBean2 myBean2() {
        MyBean2 myBean2 = new MyBean2();
        myBean2.setMyBean(myBean());//setter
        return myBean2;
    }

    @Bean
    public MyBean3 myBean3() {
        return new MyBean3(myBean());//有参构造
    }
}
```

> 其他文件

```java
@Configuration
public class SpringConfig1 {
}
```

```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserDao userDao;
    ...
}
```

```java
@Repository
public class UserDaoImpl implements UserDao {
    ...
}
```

```java
public class MyBean {
    public void init() {}
    public void destory() {}
}

public class MyBean2 {
    private MyBean myBean;
    public MyBean getMyBean() { return myBean; }
    public void setMyBean(MyBean myBean) { this.myBean = myBean; }
}

public class MyBean3 {
    private MyBean myBean;
    public MyBean3(MyBean myBean) { this.myBean = myBean; }
}
```

> 单元测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {SpringConfig.class})
public class SpringTest {

    @Autowired
    private UserService userService;

    @Test
    public void testLogin() { userService.login(); }
}
```


---

# XV.参考

- [Spring Framework Reference Documentation-4.3.22](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/)
- [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html)