---
title: Spring入门
date: 2018-08-21 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Basic
    - Java
---

Spring无需过多介绍。本文将介绍Spring Framework的基本使用。

<!-- more -->

##### 目录
+ I.简介
+ II.Ioc
+ III.DI

---

# I.简介

[Spring](https://spring.io/)是分层的、JavaSE/EE一站式(full-stack)、轻量级开源框架。这里基于[Spring Framework-4.3.22.RELEASE](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-introduction)讲解。

> Spring4提供了对Java8的一些特性的支持，最低要求Java6（JDK 6 update 18），推荐使用Java7和8。

经典三层结构：
- 表现层（页面数据渲染、跳转调度），JSP/Servlet/Struts/SpringMVC等
- 业务层（业务逻辑实现、事务控制），JavaBean、EJB、spring等
- 持久层（数据操作），JDBC/Hibernate/Mybatis/Spring Data JPA等

Spring取代了相对臃肿的EJB，对上述三层都提供了解决方案，并且使用spring编程是**非侵入式**的。

## 1.核心

- IOC

将对象的创建和管理交给Spring工厂。由Book book = new Book()变为Book book = Spring工厂.getBook()。**工厂模式 + 反射**

> **IOC是将对象的创建交由Spring容器；DI是让Spring容器把对象间的依赖关系也维护了**。

- AOP

基于**动态代理**进行增强

## 2.优点

Spring的出现是为了解决JavaEE开发中的实际问题，降低JavaEE API的使用难度。俗称为粘合剂

- 解耦，简化开发：所有对象的创建和依赖关系的维护，都可以交给Spring管理
- AOP编程：面向切面编程，方便实现对程序的权限拦截、运行监控等功能
- 声明式事务：通过配置就可以完成事务管理，代替耦合的手动编程
- 方便测试：支持集成Junit，通过注解可以方便地测试Spring程序
- 集成第三方框架：提供了对各种优秀框架的集成支持，易扩展可插拔
- 降低JavaEE的使用难度：对JavaEE中的一些API（JDBC、JavaMail、远程调用等）提供封装，降低这些API的使用难度


## 3.模块

Spring is modular。Spring Framework包含大概20个模块。这些模块可划分为7类：Core Container、Data Access/Integration、Web、AOP、Instrumentation、Messaging和Test。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/spring-overview.png)

#### 3.1 Core Container

包括spring-core、spring-beans、spring-context、spring-context-support、spring-expression (SpEL)。

spring-core和spring-beans模块提供了Spring最基础的功能：IoC和DI特性。**BeanFactory**是工厂模式的实现，它消除了对程序实现单例（programmatic singletons）的需要，将依赖关系和配置从程序逻辑中分离出来。

spring-context模块基于core和beans，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。context模块继承了beans模块的特性，还增加了国际化（I18N）、事件传播、资源加载，以及透明地创建上下文，例如通过Servlet容器创建。另外，context模块支持一些JavaEE特性，如EJB、JMX和basic remoting。**ApplicationContext**接口是context模块的核心。context-support提供了将常见的第三方库集成到Spring上下文的支持，如caching（EhCache，Guava，JCache）、mailing（JavaMail）、scheduling（CommonJ，Quartz）和template engines（FreeMarker，JasperReports，Velocity）。

spring-expression模块，提供了一个强大的EL，在运行期间查询和操作object graph。SpEL是JSP 2.1规范中unified EL的扩展。SpEL支持访问和修改属性值，属性指定，方法调用，访问数组、容器和索引器，逻辑和数学运算，命名变量，以及支持从Spring容器中获取Bean。它还支持列表投影、选择和一般的列表聚合等。

#### 3.2 AOP and Instrumentation

spring-aop模块提供了符合AOP联盟规范的、面向切面的编程实现。方便定义如方法拦截器和切入点，减少代码耦合。利用源码级的元数据功能，还可以将各种行为信息合并到代码中（和.NET属性相似的方式）。

spring-aspects模块，提供了对AspectJ的集成。

spring-instrument模块提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用。spring-instrument-tomcat模块包含了spring对Tomcat的代理instrumentation。

#### 3.3 Messaging

Spring4引入了spring-messaging模块，其中包含来自Spring集成项目的关键抽象，如Message、MessageChannel、MessageHandler等，可以作为基于消息的应用程序的基础。该模块还包括一组用于将消息映射到方法的注释，类似SpringMVC的基于注释的编程模型。

#### 3.4 Data Access/Integration

Data Access/Integration层包括了JDBC、ORM、OXM、JMS、Transaction模块。

spring-jdbc模块，提供对JDBC的抽象，用来消除冗长的JDBC编码和解析数据库厂商特有错误代码。

spring-tx模块，对实现特定接口的类和POJO，支持程序式和声明式事务管理。

spring-orm模块，提供了对常用"对象-关系映射"APIs的集成支持。包括JPA、JDO、Hibernate。使用该模块，可以将ORM框架和Spring提供的特性相结合，如声明式事务管理。

spring-oxm模块，提供一个抽象层，用于支持集成Object和XML映射的实现，包括JAXB、Castor、XMLBeans、JiBX和XStream。

spring-jms模块（Java Messaging Service），提供了生产和消费消息的特性。从Spring4开始，它和spring-messaging模块一起提供集成。

#### 3.5 Web

Web层包括spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet模块。

spring-web模块，提供了基础的web功能。例如多文件上传、使用Servlet listeners和一个web-oriented的application context实例化IoC容器。它还包含了一个HTTP Client和对远程访问的支持。

spring-webmvc模块（aka Web-Servlet模块），提供了MVC和REST Web服务的实现。SpringMVC框架将domain model code和web forms分离，并且继承了Spring框架的特性。

spring-webmvc-portlet模块（aka Web-Portlet模块），提供了在Portlet环境下的MVC实现，mirror基于servlet的spring-webmvc模块的功能

#### 3.6 Test
spring-test模块支持使用JUnit和TestNG，对Spring组件进行单元测试和集成测试。它提供一致的ApplicationContexts和这些上下文的缓存。它还提供一些mock对象，用来独立的测试代码。


---

# II.Ioc

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/container-magic.png)

Inverse of Control，控制反转，**工厂模式 + 反射 + 配置文件（xml）**。

> **Ioc是种思想。正转：应用程序掌握主动，需要什么资源主动出击（程序中主动创建对象）。反转：在Ioc中，应用程序变得被动，等待Ioc容器来创建并注入它所需要的资源。无论正转反转，控制的都是依赖资源的获取**。

## 1.Ioc原理

这里对比3种开发方式，来理解IOC的实现原理

#### 1.1 传统方式

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //传统方式-自己实例化对象
        UserDao userDao = new UserDaoImpl();
        userDao.selectOne();
    }
}
```

**手动创建实例，对象依赖关系的维护也在业务代码中，代码耦合度高，（UserDao的）实现类的切换不灵活**。

#### 1.2 传统方式改进

使用工厂模式+反射+配置文件（IOC原理）

> 这里省略了配置文件，可参考下述Spring方式，将类全路径放入配置文件。

```java
public class UserDaoFactory {
    //方式1-耦合性仍然强: UserDaoFactory和UserDaoImpl耦合
    /*
    public UserDao getUserDao() {
        UserDao userDao = new UserDaoImpl();
        return userDao;
    }*/
    
    //方式2-反射创建实例
    public Object getBean() {
        Object bean = null;
        try {
            bean = Class.forName("com.test.ioc.principle.UserDaoImpl").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        UserDao userDao = (UserDao) factory.getBean();

        userDao.selectOne();
    }
}
```

#### 1.3 Spring方式

- a.引入依赖

不使用maven时，也可以手动加入[Spring相关jar](http://repo.spring.io/libs-release-local/org/springframework/spring/4.3.22.RELEASE/)。

> 这里最简可以只引入：spring-context、log4j

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
</dependency>
<!-- context中引用了core、beans、expression、aop -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
</dependency>

<!-- JCL + Log4j -->
<!-- spring-core中也有JCL-1.2，这里可以省略 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>
```

> 对Spring来说，日志很重要。首先，日志是Spring唯一的"强制性外部依赖"。其次，由于Spring集成的第三方库的日志实现各种各样。开发者需要在一个集中的地方，使用统一的日志配置，来管理整个应用的日志输出。这里采用JCL+Log4j。

- b.配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 一个bean标签对应spring工厂创建的一个实例(反射机制)
        id/name:对象引用, class:类全路径 -->
    <bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

</beans>
```

- c.工厂+反射

Spring为我们提供了工厂ApplicationContext，并内部实现通过反射创建Bean。

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        //UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        //UserDao userDao = (UserDao) factory.getBean();

        //3.Spring方式
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        UserDao userDao = (UserDao) context.getBean("userDao");
        userDao.selectOne();
    }
}
```

Spring方式解决了类之间的耦合，但在每次获取对象的时候（比如Controller中依赖Service），都需要创建ApplicationContext，能不能更方便地获取对象，或解决userService依赖userDao?
答案就是DI依赖注入。既然这些对象都由Spring容器创建和管理，那么对象间的依赖关系也可以交由ApplicationContext维护。

## 2.[Bean配置方式](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class)

Spring工厂底层有4种方式创建Bean，对应配置文件中也有4种方式配置bean。

> 这里四种方式在注解开发中很少用到，偶尔使用第一种方式。其他方式在Spring底层和整合第三方框架时用的较多。

#### 2.1 [无参构造](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-ctor)

Spring在创建bean时，自动调用无参构造来实例化对象。此时需要有无参构造，也是最常用的方式。

```java
public class Bean1 {
    //默认系统给空参构造
}
```

```xml
<bean id="bean1" class="com.test.ioc.bean.xml.Bean1"/>
```

> 如果Bean1中没有无参构造（只有有参构造），则报NoSuchMethodException: com.baicai.pojo.Bean1.<init>()

#### 2.2 [静态工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-static-factory-method)

需要提供一个工厂类，其中包括一个静态方法

```java
public class Bean2 {    
}
```

```java
public class Bean2Factory {
    //静态方法，方便调用
    public static Bean2 getBean2() {
        //do other things,like Connection to Driver...
        return new Bean2();
    }
}
```

```xml
<bean id="bean2" class="com.baicai.pojo.Bean2Factory" factory-method="getBean2"/>
```

#### 2.3 [工厂方法](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class-instance-factory-method)

该方式需先配置工厂实例，区别于静态工厂方式。（因为是非静态方法，所以需要先创建工厂实例，才能调用方法）

```java
public class Bean3 {    
}
```

```java
public class Bean3Factory {
    //非静态方法，需要先创建工厂实例，才能调用
    public Bean3 getBean3() {
        //do other things,like Connection to Driver
        return new Bean3();
    } 
}
```

```xml
<bean id="bean3Factory" class="com.baicai.pojo.Bean3Factory"/>
<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"/>
```

#### 2.4 实现FactoryBean接口

该方式在spring底层源码用的多。
Spring在实例化bean时，会判断是否实现了FactoryBean接口。如果实现了就调用getObject方法返回目标类型实例。

```java
public class Bean4 {    
}
```

```java
public class Bean4FactoryBean implements FactoryBean<Bean4> {
    @Override
    public Bean4 getObject() throws Exception {
        //do other things,like Connection to Driver
        return new Bean4();
    }

    @Override
    public Class<?> getObjectType() { return null; }

    @Override
    public boolean isSingleton() { return false; }
}
```

```xml
<bean id="bean4" class="com.baicai.pojo.Bean4FactoryBean"/>
```

## 3.BeanFactory和FactoryBean的区别

- BeanFactory：是Spring容器的超级接口。ApplicationContext是其子接口，但功能更强大，用来管理Bean
- FactoryBean：是一个Bean生成工具，是用来获取一种类型对象的Bean，它是构造Bean实例的一种方式。

> 如果一个Bean实现了FactoryBean，对外就会被作为某组件的工厂，而非一个Bean。


## 4.[Bean作用域](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes)

#### 4.1 作用域类型

|Scope|Description|
|[singleton](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton)|（默认）在Spring Ioc容器中仅存在一个Bean实例|
|[prototype](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype)|每次从容器获取Bean时，都会返回一个新实例。即getBean()相当于new Bean()|
|request|每次HTTP Request都会创建新实例。该作用域仅适用于WebApplicationContext环境（如XmlWebApplicationContext，否则报unknown bean scope）|
|session|每个HTTP Session拥有一个Bean实例。仅适用于WebApplicationContext环境|
|globalSession|每个global HTTP Session拥有一个Bean实例，常用于Portlet应用环境。仅适用于WebApplicationContext环境|
|application|每个ServletContext拥有一个Bean实例。仅适用于WebApplicationContext环境|
|websocket|每个WebSocket拥有一个Bean实例。适用于WebApplicationContext环境|

常用singleton（默认）和prototype。除单例外，其他作用域需要显示声明。

- singleton：每次获取的是同一个对象；在Ioc容器初始化时，就初始化了
- prototype：每次获取的是不同对象；**在getBean时，才创建和初始化**

> 当一个单例Bean A依赖一个多例Bean B时，Ioc只会初始化A一次，所以每次获取A时，A所依赖的B也是同一个Bean。如果想每次获取A时，注入的是不同的B，参考[beans-factory-method-injection](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-method-injection)。

关于web环境下的几个scope，参考[beans-factory-scopes-other](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-other)

#### 4.2 示例

```xml
<bean id="singleton" class="com.baicai.pojo.SingletonBean"/>
<bean id="prototype" class="com.baicai.pojo.PrototypeBean" scope="prototype"/>
```

```java
public class SingletonBean {
    public SingletonBean() {
        System.out.println("单例初始化...");
    }
}

public class PrototypeBean {
    public PrototypeBean() {
        System.out.println("多例初始化...");
    }
}
```

```java
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println("第1次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));
    System.out.println("第2次获取单例Bean...");
    System.out.println(context.getBean("singletonBean"));

    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
    System.out.println("第1次获取多例Bean...");
    System.out.println(context.getBean("prototypeBean"));
}

//输出结果
单例初始化...
第1次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第2次获取单例Bean...
com.baicai.pojo.beanScope.SingletonBean@77ec78b9
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@1a3869f4
第1次获取多例Bean...
多例初始化...
com.baicai.pojo.beanScope.PrototypeBean@a38d7a3
```

#### 4.3 自定义作用域

可参考[beans-factory-scopes-custom](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom)。


## 5.生命周期回调


#### 5.1 方式一、通过xml属性

通过init-method和destroy-method属性，可以指定初始化后和销毁对象前的操作（POJO中的方法）。

> Java配置中，对应为@Bean(initMethod = "init", destroyMethod = "cleanup")

```xml
<!-- Lifecycle callbacks -->
<bean id="lifeCycleBean" class="com.baicai.pojo.lifecycle.LifeCycleBean" init-method="init" destroy-method="cleanup"/>
```

```java
public class LifeCycleBean {
    //空参构造
    public LifeCycleBean() {
        System.out.println("LifeCycleBean空参构造...");
    }
    
    //初始化后自动调用，方法名随意，要配置到xml中
    public void init(){
        // do some initialization work
        System.out.println("LifeCycleBean init...");
    }
    
    //Bean销毁前调用，方法名随意，要配置到xml中
    public void cleanup(){
        // do some destruction work (like releasing pooled connections)
        System.out.println("LifeCycleBean cleanup...");
    }
}
```

> 测试

```java
public void testLogin() {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    System.out.println(context.getBean("lifeCycleBean"));

    //需要手动关闭spring容器，此时会销毁对象，执行destroy-method
    ((ClassPathXmlApplicationContext) context).close();
}
```

销毁方法的执行必须满足两个条件：
- 单例bean才可以手动销毁（多例只有getBean时才会创建和初始化，并且没法销毁）
- 必须手动关闭容器（调用close()）时，才会执行手动销毁的方法

> 输出，其中多例对象只执行了init()，没有执行destroy()。

```java
LifeCycleBean空参构造...
LifeCycleBean init...
单例------
com.baicai.pojo.lifecycle.LifeCycleBean@1a3869f4
多例------
LifeCycleBean空参构造...
LifeCycleBean init...
com.baicai.pojo.lifecycle.LifeCycleBean@a38d7a3
LifeCycleBean cleanup...

 [INFO ] 2019-03-27 15:40:52,111 [method]org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:984)
Closing org.springframework.context.support.ClassPathXmlApplicationContext@63d4e2ba: startup date [Wed Mar 27 15:40:51 CST 2019]; root of context hierarchy
```

#### 5.3 方式二、

#### 5.3 方式三、实现接口

> 该方式耦合度高，官方不推荐。

InitializingBean和DisposableBean接口，都只定义了一个方法，分别是afterPropertiesSet()和destroy()，对应初始化后和销毁前的操作。

```java
public class LifeCycleBean2 implements InitializingBean, DisposableBean {
    //空参构造
    public LifeCycleBean2() { System.out.println("LifeCycleBean2空参构造..."); }

    @Override
    public void destroy() throws Exception {
        System.out.println("LifeCycleBean2 destroy...");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("LifeCycleBean2 afterPropertiesSet...");
    }
}
```

```java
<bean id="lifeCycleBean2" class="com.baicai.pojo.lifecycle.LifeCycleBean2"/>
```


---

# III.DI

Dependency Injection，依赖注入

组件之间的依赖关系由Spring容器在运行期决定，即由容器动态的将依赖注入到组件中。DI是为了降低耦合度，提高组件重用性。通过依赖注入机制，无需任何代码，仅使用简单的配置就可以完成指定目标的依赖资源注入，完成自身的业务逻辑，而不需要关心依赖资源来自何处，由谁实现。
 
- 谁依赖于谁：应用程序依赖IoC容器（或一个Bean依赖另一个Bean）
- 为什么依赖：应用程序需要IoC容器来提供对象需要的外部资源
- 谁注入给谁：IoC容器注入依赖资源给应用程序
- 注入了什么：某对象所需要的外部资源（包括对象、资源、常量数据）

> IoC和DI的关系

它们是同一个概念的不同角度描述。控制反转比较含糊，可能只是理解为容器控制对象这一层面，很难让人联想到谁来维护对象间的依赖关系。所以2004年Martin Fowler又提出DI依赖注入，相比IoC，DI明确描述了"被注入对象依赖IoC容器配置依赖对象"。

> 步骤

- 1.在被注入类中定义成员变量，并提供setter
- 2.配置文件中配置依赖关系

```java
public class UserServiceImpl implements UserService {

    //IOC+DI
    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void login() {
        System.out.println("service层被调用了");
        userDao.selectOne();
    }
}
```

```xml
<bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

<bean id="userService" class="com.baicai.service.UserServiceImpl">
    <!-- property依靠setter注入 -->
    <!-- name：setter方法的后缀小写 -->
    <!-- ref：要引入bean的id/name -->
    <property name="userDao" ref="userDao"/>
</bean>
```

> 如果使用Junit测试，不能new UserServiceImpl()，要通过Spring容器获取该Bean（注入了UserDao的）


---

# IV.Spring容器

又称应用上下文、Ioc容器、Spring工厂等

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/ApplicationContext-System.png)

ApplicationContext是BeanFactory的子接口。官方推荐使用ApplicationContext（更强大），两者的对比参考[ctx-vs-beanfactory](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#context-introduction-ctx-vs-beanfactory)。

> 另外，BeanFactory是延迟加载，第一次getBean()时才会初始化Bean。


## 获取Bean

从Ioc容器获取Bean的方式有多种，即getBean有多个重载方法。常用的有两种：

- 根据id/name查找（唯一）
- 根据Bean类型或接口类型查找（一般使用接口类型，会自动去找实现类）

```java
getBean(String name)
getBean(Class<T> requiredType)
```

> 示例

```java
UserService userService = (UserService) ac.getBean("userService");
UserService userService = (UserService) ac.getBean(UserService.class);
```

根据类型查找Bean时，可能存在多个，此时报NoSuchBeanDefinitionException:No unique bean of type...

