---
title: Spring入门
date: 2018-08-21 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Basic
    - Java
---

Spring无需过多介绍。本文将介绍Spring Framework的基本使用。

<!-- more -->

##### 目录
+ I.介绍
+ II.Ioc
+ III.DI

---

# I.介绍

[Spring](https://spring.io/)是分层的、JavaSE/EE一站式(full-stack)、轻量级开源框架。这里基于[Spring Framework-4.3.22.RELEASE](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#beans-introduction)讲解。

> Spring4提供了对Java8的一些特性的支持，最低要求Java6（JDK 6 update 18），推荐使用Java7和8。

经典三层结构：
- 表现层（页面数据渲染、跳转调度），JSP/Servlet/Struts/SpringMVC等
- 业务层（业务逻辑实现、事务控制），JavaBean、EJB、spring等
- 持久层（数据操作），JDBC/Hibernate/Mybatis/Spring Data JPA等

Spring取代了相对臃肿的EJB，对上述三层都提供了解决方案，并且使用spring编程是**非侵入式**的。

## 核心

- IOC

将对象的创建和管理交给Spring工厂。由Book book = new Book()变为Book book = Spring工厂.getBook()。**工厂模式 + 反射**

> **IOC是将对象的创建交由Spring容器；DI是让Spring容器把对象间的依赖关系也维护了**。

- AOP

基于**动态代理**进行增强

## 优点

Spring 的出现是为了解决JavaEE开发中的实际问题，降低JavaEE API的使用难度。俗称为粘合剂

- 解耦，简化开发：所有对象的创建和依赖关系的维护，都可以交给Spring管理
- AOP编程：面向切面编程，方便实现对程序的权限拦截、运行监控等功能
- 声明式事务：通过配置就可以完成事务管理，代替耦合的手动编程
- 方便测试：支持集成Junit，通过注解可以方便地测试Spring程序
- 集成第三方框架：提供了对各种优秀框架的集成支持，易扩展可插拔
- 降低JavaEE的使用难度：对JavaEE中的一些API（JDBC、JavaMail、远程调用等）提供封装，降低这些API的使用难度


## 模块

Spring is modular。Spring Framework包含大概20个模块。这些模块可划分为7类：Core Container、Data Access/Integration、Web、AOP、Instrumentation、Messaging和Test。

![avatar](http://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/spring-overview.png)

#### Core Container

包括spring-core、spring-beans、spring-context、spring-context-support、spring-expression (SpEL)。

spring-core和spring-beans模块提供了Spring最基础的功能：IoC和DI特性。**BeanFactory**是工厂模式的实现，它消除了对程序实现单例（programmatic singletons）的需要，将依赖关系和配置从程序逻辑中分离出来。

spring-context模块基于core和beans，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。context模块继承了beans模块的特性，还增加了国际化（I18N）、事件传播、资源加载，以及透明地创建上下文，例如通过Servlet容器创建。另外，context模块支持一些JavaEE特性，如EJB、JMX和basic remoting。**ApplicationContext**接口是context模块的核心。context-support提供了将常见的第三方库集成到Spring上下文的支持，如caching（EhCache，Guava，JCache）、mailing（JavaMail）、scheduling（CommonJ，Quartz）和template engines（FreeMarker，JasperReports，Velocity）。

spring-expression模块，提供了一个强大的EL，在运行期间查询和操作object graph。SpEL是JSP 2.1规范中unified EL的扩展。SpEL支持访问和修改属性值，属性指定，方法调用，访问数组、容器和索引器，逻辑和数学运算，命名变量，以及支持从Spring容器中获取Bean。它还支持列表投影、选择和一般的列表聚合等。

#### AOP and Instrumentation

spring-aop模块提供了符合AOP联盟规范的、面向切面的编程实现。方便定义如方法拦截器和切入点，减少代码耦合。利用源码级的元数据功能，还可以将各种行为信息合并到代码中（和.NET属性相似的方式）。

spring-aspects模块，提供了对AspectJ的集成。

spring-instrument模块提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用。spring-instrument-tomcat模块包含了spring对Tomcat的代理instrumentation。

#### Messaging

Spring4引入了spring-messaging模块，其中包含来自Spring集成项目的关键抽象，如Message、MessageChannel、MessageHandler等，可以作为基于消息的应用程序的基础。该模块还包括一组用于将消息映射到方法的注释，类似SpringMVC的基于注释的编程模型。

#### Data Access/Integration

Data Access/Integration层包括了JDBC、ORM、OXM、JMS、Transaction模块。

spring-jdbc模块，提供对JDBC的抽象，用来消除冗长的JDBC编码和解析数据库厂商特有错误代码。

spring-tx模块，对实现特定接口的类和POJO，支持程序式和声明式事务管理。

spring-orm模块，提供了对常用"对象-关系映射"APIs的集成支持。包括JPA、JDO、Hibernate。使用该模块，可以将ORM框架和Spring提供的特性相结合，如声明式事务管理。

spring-oxm模块，提供一个抽象层，用于支持集成Object和XML映射的实现，包括JAXB、Castor、XMLBeans、JiBX和XStream。

spring-jms模块（Java Messaging Service），提供了生产和消费消息的特性。从Spring4开始，它和spring-messaging模块一起提供集成。

#### Web

Web层包括spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet模块。

spring-web模块，提供了基础的web功能。例如多文件上传、使用Servlet listeners和一个web-oriented的application context实例化IoC容器。它还包含了一个HTTP Client和对远程访问的支持。

spring-webmvc模块（aka Web-Servlet模块），提供了MVC和REST Web服务的实现。SpringMVC框架将domain model code和web forms分离，并且继承了Spring框架的特性。

spring-webmvc-portlet模块（aka Web-Portlet模块），提供了在Portlet环境下的MVC实现，mirror基于servlet的spring-webmvc模块的功能

#### Test
spring-test模块支持使用JUnit和TestNG，对Spring组件进行单元测试和集成测试。它提供一致的ApplicationContexts和这些上下文的缓存。它还提供一些mock对象，用来独立的测试代码。


---

# II.Ioc

Inverse of Control，控制反转，**工厂模式 + 反射 + 配置文件（xml）**。

> **Ioc是种思想。正转：应用程序掌握主动，需要什么资源主动出击（程序中主动创建对象）。反转：在Ioc中，应用程序变得被动，等待Ioc容器来创建并注入它所需要的资源。无论正转反转，控制的都是依赖资源的获取**。

这里对比3种开发方式，来理解IOC原理

## 传统方式

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //传统方式-自己实例化对象
        UserDao userDao = new UserDaoImpl();
        userDao.selectOne();
    }
}
```

**手动创建实例，对象依赖关系的维护也在业务代码中，代码耦合度高，（UserDao的）实现类的切换不灵活**。

## 传统方式改进

使用工厂模式+反射+配置文件（IOC原理）

> 这里省略了配置文件，可参考下述Spring方式，将类全路径放入配置文件。

```java
public class UserDaoFactory {
    //方式1-耦合性仍然强: UserDaoFactory和UserDaoImpl耦合
    /*
    public UserDao getUserDao() {
        UserDao userDao = new UserDaoImpl();
        return userDao;
    }*/
    
    //方式2-反射创建实例
    public Object getBean() {
        Object bean = null;
        try {
            bean = Class.forName("com.test.ioc.principle.UserDaoImpl").newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }
}
```

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        UserDao userDao = (UserDao) factory.getBean();

        userDao.selectOne();
    }
}
```

## Spring方式

#### 依赖

不使用maven时，也可以手动加入[Spring相关jar](http://repo.spring.io/libs-release-local/org/springframework/spring/4.3.22.RELEASE/)。

> 这里最简可以只引入：spring-context、log4j

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
</dependency>
<!-- context中引用了core、beans、expression、aop -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-expression</artifactId>
</dependency>

<!-- JCL + Log4j -->
<!-- spring-core中也有JCL-1.2，这里可以省略 -->
<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>
```

> 对Spring来说，日志很重要。首先，日志是Spring唯一的"强制性外部依赖"。其次，由于Spring集成的第三方库的日志实现各种各样。开发者需要在一个集中的地方，使用统一的日志配置，来管理整个应用的日志输出。这里采用JCL+Log4j。

#### 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 一个bean标签对应spring工厂创建的一个实例(反射机制)
        id/name:对象引用, class:类全路径 -->
    <bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

</beans>
```

#### 工厂+反射

Spring为我们提供了工厂ApplicationContext，并内部实现通过反射创建Bean

```java
public class UserServiceImpl implements UserService {
    @Override
    public void login() {
        System.out.println("service层被调用了");
        //1.传统方式-自己实例化对象
        //UserDao userDao = new UserDaoImpl();

        //2.传统方式-改进-工厂+反射+配置文件
        //UserDaoFactory factory = new UserDaoFactory();
        //UserDao userDao = factory.getUserDao();
        //UserDao userDao = (UserDao) factory.getBean();

        //3.Spring方式
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        UserDao userDao = (UserDao) context.getBean("userDao");
        userDao.selectOne();
    }
}
```

Spring方式解决了类之间的耦合，但在每次获取对象的时候（比如Controller中依赖Service），都需要创建ApplicationContext，能不能更方便地获取对象，或解决userService依赖userDao?
答案就是DI依赖注入。既然这些对象都由Spring容器创建和管理，那么对象间的依赖关系也可以交由ApplicationContext维护。


---

# III.DI

Dependency Injection，依赖注入

组件之间的依赖关系由Spring容器在运行期决定，即由容器动态的将依赖注入到组件中。DI是为了降低耦合度，提高组件重用性。通过依赖注入机制，无需任何代码，仅使用简单的配置就可以完成指定目标的依赖资源注入，完成自身的业务逻辑，而不需要关心依赖资源来自何处，由谁实现。
 
- 谁依赖于谁：应用程序依赖IoC容器（或一个Bean依赖另一个Bean）
- 为什么依赖：应用程序需要IoC容器来提供对象需要的外部资源
- 谁注入给谁：IoC容器注入依赖资源给应用程序
- 注入了什么：某对象所需要的外部资源（包括对象、资源、常量数据）

> IoC和DI的关系

它们是同一个概念的不同角度描述。控制反转比较含糊，可能只是理解为容器控制对象这一层面，很难让人联想到谁来维护对象间的依赖关系。所以2004年Martin Fowler又提出DI依赖注入，相比IoC，DI明确描述了"被注入对象依赖IoC容器配置依赖对象"。

> 步骤

- 1.在被注入类中定义成员变量，并提供setter
- 2.配置文件中配置依赖关系

```java
public class UserServiceImpl implements UserService {

    //IOC+DI
    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void login() {
        System.out.println("service层被调用了");
        userDao.selectOne();
    }
}
```

```xml
<bean id="userDao" class="com.baicai.dao.UserDaoImpl" />

<bean id="userService" class="com.baicai.service.UserServiceImpl">
    <!-- property依靠setter注入 -->
    <!-- name：setter方法的后缀小写 -->
    <!-- ref：要引入bean的id/name -->
    <property name="userDao" ref="userDao"/>
</bean>
```

> 如果使用Junit测试，不能new UserServiceImpl()，要通过Spring容器获取该Bean（注入了UserDao的）


---

# IV.Spring容器

又称应用上下文、Ioc容器、Spring工厂等

![avatar](https://blog-wocaishiliuke.oss-cn-shanghai.aliyuncs.com/images/Spring/ApplicationContext-System.png)

ApplicationContext是BeanFactory的子接口。官方推荐使用ApplicationContext（更强大），两者的对比参考[ctx-vs-beanfactory](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#context-introduction-ctx-vs-beanfactory)。

> 另外，BeanFactory是延迟加载，第一次getBean()时才会初始化Bean。


## 获取Bean

从Ioc容器获取Bean的方式有多种，即getBean有多个重载方法。常用的有两种：

- 根据id/name查找（唯一）
- 根据Bean类型或接口类型查找（一般使用接口类型，会自动去找实现类）

```java
getBean(String name)
getBean(Class<T> requiredType)
```

> 示例

```java
UserService userService = (UserService) ac.getBean("userService");
UserService userService = (UserService) ac.getBean(UserService.class);
```

> 根据接口查找时，NoSuchBeanDefinitionException:No unique bean of type...