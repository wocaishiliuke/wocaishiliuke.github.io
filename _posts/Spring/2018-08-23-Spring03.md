---
title: Spring入门（三）
date: 2018-08-23 19:01:09
categories:
    - Spring
tags:
    - Spring
    - Java
---

本文将介绍Spring Framework中的其他内容

<!-- more -->

##### 目录
+ I.Spring事务管理
+ II.Spring JdbcTemplate

---

# II.Spring JdbcTemplate

之前提到，Spring为一些复杂难用的Java API提供了很好的封装，其中就包括JDBC的底层细节。[Spring JdbcTemplate](https://docs.spring.io/spring/docs/4.3.22.RELEASE/spring-framework-reference/htmlsingle/#jdbc)就是这样一个模板工具类，用以简化JDBC编程（类似Apache DbUtils ）。

> Spring JDBC - who does what?

|Action|Spring|You|
|Define connection parameters.||X|
|Open the connection.|X||
|Specify the SQL statement.||X|
|Declare parameters and provide parameter values||X|
|Prepare and execute the statement.|X||
|Set up the loop to iterate through the results (if any).|X||
|Do the work for each iteration.||X|
|Process any exception.|X||
|Handle transactions.|X||
|Close the connection, statement and resultset.|X||

> 为了方便Data Access（Dao编程），Spring为很多持久化技术都提供了对应的模板类：

|持久化技术|模板类|作用|
|：-------|：----|：--|
|JDBC|org.springframework.jdbc.core.JdbcTemplate|简化JDBC编程|
|Hibernate3.0|org.springframework.orm.hibernate3.HibernateTemplate|简化Hibernater编程|
|MyBatis|org.springframework.orm.ibatis.SqlMapClientTemplate|简化mybatis编程|
|JPA|org.springframework.orm.jpa.JpaTemplate|简化JPA编程|

> 使用方法

- 1.继承支持类
- 2.注入数据源，获取模板类即可

为了方便Dao中使用这些模板类，Spring又提供了对应的支持类，方便继承使用：

|持久化技术|支持类|
|：-------|：----|
|JDBC|org.springframework.jdbc.core.support.JdbcDaoSupport|
|Hibernate3.0|org.springframework.orm.hibernate3.support.HibernateDaoSupport|
|MyBatis|org.springframework.orm.ibatis.support.SqlMapClientDaoSupport|

以JdbcDaoSupport为例，查看源码发现，有两种方式设置该支持类的JdbcTemplate：
- directly（setJdbcTemplate()）
- through a DataSource（setDataSource()）

```java
public abstract class JdbcDaoSupport extends DaoSupport {

    private JdbcTemplate jdbcTemplate;

    //设置该DAO使用的JDBC数据源（会创建jdbcTemplate）
    public final void setDataSource(DataSource dataSource) {
        if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) {
            this.jdbcTemplate = createJdbcTemplate(dataSource);
            initTemplateConfig();
        }
    }

    //通过指定的数据源，创建JdbcTemplate
    protected JdbcTemplate createJdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

    //获取该DAO使用的数据源
    public final DataSource getDataSource() {
        return (this.jdbcTemplate != null ? this.jdbcTemplate.getDataSource() : null);
    }

    //直接设置JdbcTemplate（设置数据源外的另一种jdbcTemplate创建方式）
    public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        initTemplateConfig();
    }

    //返回该DAO使用的JdbcTemplate
    public final JdbcTemplate getJdbcTemplate() {
      return this.jdbcTemplate;
    }

    //在设置了JdbcTemplate后被调用，用以初始化该DAO的模板配置。为空，交给子类具体实现
    protected void initTemplateConfig() {}

    @Override
    protected void checkDaoConfig() {
        if (this.jdbcTemplate == null) {
            throw new IllegalArgumentException("'dataSource' or 'jdbcTemplate' is required");
        }
    }

    //返回该DAO的JdbcTemplate的SQLExceptionTranslator（用于转化SQLExceptions到自定义的JDBC访问码）
    protected final SQLExceptionTranslator getExceptionTranslator() {
        return getJdbcTemplate().getExceptionTranslator();
    }

    //获取一个JDBC Connection（来自当前事务或新连接）
    protected final Connection getConnection() throws CannotGetJdbcConnectionException {
        return DataSourceUtils.getConnection(getDataSource());
    }

    //关闭通过该DAO数据源创建的JDBC Connection
    protected final void releaseConnection(Connection con) {
        DataSourceUtils.releaseConnection(con, getDataSource());
    }
}
```

##  JdbcTemplate初尝试

- 构建连接池DataSource
- 构建JDBCTemplate
- 调用JDBCTemplate的execute方法

#### 依赖

spring-jdbc依赖了：spring-beans、spring-core、spring-tx

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
</dependency>

<dependency>
    <groupId>commons-logging</groupId>
    <artifactId>commons-logging</artifactId>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
</dependency>
```

#### 配置文件

```java
### direct messages to stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} [method]%l%n%m%n

### set log levels
log4j.rootLogger=info,stdout
```

仅测试JdbcTemplate，所以先不用配置到IoC容器

#### 测试

> 数据库准备

```sql
CREATE DATABASE `test_spring` DEFAULT CHARACTER SET utf8mb4;
```

```java
public class JdbcTemplateTest {
    @Test
    public void test() {
        //1.创建数据源
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/test_spring");
        dataSource.setUsername("root");
        dataSource.setPassword("root");
        //2.创建jdbcTemplate模板类
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);   //jdbcTemplate.setDataSource(dataSource)
        //3.执行语句
        jdbcTemplate.execute("create table test1(id int,name varchar(20),price decimal(10,2))");
    }
}
```

## 通过Spring使用JdbcTemplate

#### 依赖

在上面的基础上，增加spring-context（spring-jdbc没有依赖context）、spring-test

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
</dependency>
```

#### 数据源

DriverManagerDataSource是spring提供的数据源，但不推荐生产使用。DriverManagerDataSource的工作机制：需要连接时就new一个connection，并没有连接池作用。适合本地测试，因为不需要额外的依赖。查看该类源码，进行属性参数注入配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- spring内置的连接池 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/test_spring"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
    
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"></property>
        <!-- <constructor-arg name="dataSource" ref="dataSource"/> -->
    </bean>
</beans>
```

#### 测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="classpath:applicationContext.xml")
public class JdbcTemplateTest {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void test() {
        this.jdbcTemplate.execute("create table test2(id int,name varchar(20),price decimal(10,2))");
    }
}
```

## 其他数据源

以下连接池是真正的连接池机制，销毁并非真正的销毁，而是关闭归还给连接池。其他连接参数不详述，这里只配置四大金刚。

#### Apache DBCP

```xml
<dependency>
    <groupId>commons-dbcp</groupId>
    <artifactId>commons-dbcp</artifactId>
    <version>1.4</version>
</dependency>
<dependency>
    <groupId>commons-pool</groupId>
    <artifactId>commons-pool</artifactId>
    <version>1.6</version>
</dependency>
```

```xml
<!-- Apache DBCP连接池 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/test_spring"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```

#### C3P0

C3P0的jar，根据版本不同需要导入的包可能不同：

- c3p0-0.9.1.2.jar只需要导这1个包即可
- c3p0-0.9.5.2.jar需要此包外，还需要mchange-commons-java-0.2.11.jar包

```xml
<!-- C3P0连接池 -->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test_spring"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

#### Druid

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.9</version>
</dependency>
```

```xml
<!-- Druid连接池 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/test_spring"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```

#### HikariCP

该连接池使用slf4j日志实现，前面几种都是log4j实现，所以还需要引入转换包和slf4j包：
HikariCP-2.5.1.jar、slf4j-api-1.7.25.jar、slf4j-log4j12-1.7.25.jar

> 日志配置不变，还是使用Log4j的配置即可

```xml
<!-- HikariCP连接池 -->
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test_spring"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```

## 数据源配置文件

上面将配置参数写死在XML中，可以提取到properties：

```java
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test_spring
jdbc.username=root
jdbc.password=root
```

> 也可以使用SPEL取值，只不过不能使用property-placeholder，详见[Spring入门（一）](http://blog.wocaishiliuke.cn/spring/2018/08/21/Spring01/)

```xml
<context:property-placeholder location="classpath:jdbc.properties"/>
    
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

## JdbcTemplate的CURD

#### 准备sql和POJO

```sql
CREATE TABLE book (
    id int(11) PRIMARY KEY NOT NULL AUTO_INCREMENT COMMENT 'PRIMARY KEY', 
    name varchar(20), 
    price decimal(10,2)
) DEFAULT CHARSET=utf8mb4
```

```java
public class Book {
    private Integer id;
    private String name;
    private BigDecimal price;
    
    //getter, setter, toString
}
```

#### DAO

> CRUD方法参考[spring-docs中的JdbcTemplate](https://docs.spring.io/spring/docs/4.3.22.RELEASE/javadoc-api/)

```java
public class BookDao extends JdbcDaoSupport {
    
    public void save(Book book) {
        String sql = "insert into book values(null,?,?)";
        //jdbcTemplate变量是父类private的，子类只能通过getter访问
        this.getJdbcTemplate().update(sql,book.getName(),book.getPrice());
    }
    
    public void update(Book book) {
        String sql = "update book set name=?,price=? where id=?";
        this.getJdbcTemplate().update(sql,book.getName(),book.getPrice(),book.getId());
    }
    
    public Book getById(Integer id) {
        String sql = "select * from book where id=?";
        return this.getJdbcTemplate().queryForObject(sql, new BeanPropertyRowMapper<>(Book.class), id);
    }
    
    public Integer getCount(Map<String, Object> map) {
        String sql = "select count(*) from book where name like ?";
        return this.getJdbcTemplate().queryForObject(sql, Integer.class, "%" + map.get("keyWord") + "%");
    }
    
    public void deleteById(Integer id) {
        String sql = "delete from book where id=?";
        this.getJdbcTemplate().update(sql, id);
    }
    
    public List<Book> getAll() {
        String sql = "select * from book";
        return this.getJdbcTemplate().query(sql, new BeanPropertyRowMapper(Book.class));
    }
    
    public List<Book> getByParam(Map<String, Object> map) {
        String sql = "select * from book where name like ?";
        return this.getJdbcTemplate().query(sql, new BeanPropertyRowMapper(Book.class), "%" + map.get("name") + "%");
    }
}
```

#### 配置

```xml
<context:property-placeholder location="classpath:jdbc.properties"/>
    
<!-- spring内置的连接池 -->
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"></property>
    <!-- <constructor-arg name="dataSource" ref="dataSource"/> -->
</bean>

<bean id="bookDao" class="com.test.jdbctemplate.crud.BookDao">
    <!-- 方式1：直接走setJdbcTemplate -->
    <!-- <property name="jdbcTemplate" ref="jdbcTemplate"/> -->
    <!-- 方式2：走setDataSource()，此时就不需要配置jdbcTemplate了 -->
    <property name="dataSource" ref="dataSource"/>
</bean>
```

这里省略了单元测试。