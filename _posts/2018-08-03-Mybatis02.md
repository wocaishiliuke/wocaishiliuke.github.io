---
title: Mybatis动态代理
date: 2018-08-03 20:01:09
categories:
    - Mybatis
tags:
    - Mybatis
    - Basic
    - Java
---

本文将在《Mybatis入门》的基础上，进一步探讨。

<!-- more -->

##### 目录
+ I.完整CRUD
+ II.动态代理
+ III.各元素生命周期

---

# I.完整CRUD

> 基于《Mybatis入门》中的tb_user，编写完整的UserDao

#### 代码部分

- UserDao接口

```
package com.mybatis.dao;

public interface UserDao {
    /**
     * 根据id查询用户
     */
    public User queryUserById(Long id);
    /**
     * 查询所有用户
     */
    public List<User> queryAll();
    /**
     * 新增用户
     */
    public void insert(User user);
    /**
     * 更新用户
     */
    public void update(User user);
    /**
     * 根据id删除用户
     */
    public void deleteById(Long id);
}
```

- UserDaoImpl实现类

> **sqlSession是线程不安全的，每个线程都应该有它自己的 SqlSession 实例。所以要在方法中获取，不能声明为成员变量(多线程共享)。其作用域是请求/方法作用域，并且响应后要关闭**

```
package com.mybatis.dao.impl;

public class UserDaoImpl implements UserDao {
    
    //sqlSession是线程不安全的，要在方法中获取，不能声明为成员变量(多线程共享);这里只是示意，方便测试，开发不能这么用
    private SqlSession sqlSession;
    
    public UserDaoImpl(SqlSession sqlSession) {
        this.sqlSession = sqlSession;
    }
    
    @Override
    public User queryUserById(Long id) {
        return this.sqlSession.selectOne("UserMapper.selectOne", id);
    }

    @Override
    public List<User> queryAll() {
        return this.sqlSession.selectList("UserMapper.selectList");
    }

    @Override
    public void insert(User user) {
        this.sqlSession.insert("UserMapper.insert", user);
    }

    @Override
    public void update(User user) {
        this.sqlSession.update("UserMapper.update", user);
    }

    @Override
    public void deleteById(Long id) {
        this.sqlSession.delete("UserMapper.delete", id);
    }
}
```

- UserMapper.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="UserMapper">

    <!-- select类型的statement; id：同一namespace下唯一，resultType：返回结果集的包装类型 -->
    <select id="selectOne" resultType="com.mybatis.pojo.User">
        SELECT * FROM tb_user WHERE id = #{id}
    </select>
    
    <select id="selectList" resultType="com.mybatis.pojo.User">
        SELECT * FROM tb_user
    </select>
    
    <insert id="insert" parameterType="com.mybatis.pojo.User">
        INSERT INTO tb_user(id, user_name, password, name, age, sex, birthday, created, updated) 
        VALUES(null, #{userName}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, now(), now())
    </insert>
    
    <update id="update" parameterType="com.mybatis.pojo.User">
        UPDATE tb_user SET user_name = #{userName}, password = #{password}, name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday}, updated = now()
        WHERE id = #{id}
    </update>
    
    <delete id="delete" parameterType="java.lang.Long">
        DELETE FROM tb_user WHERE id = #{id}
    </delete>
</mapper>
```

- 测试用例

> - 1.右键UserDao接口，new Junit Test Case(4)，勾选setUp()，选择需要测试的方法
> - 2.setUp()中的sqlSession和userDao要用成员变量接收，因为后面@Test方法中要使用，保证是UserDao有参构造的sqlSession，才能提交事务
> - 3.增删改需要提交事务，才会改变数据库（不管是自动提交还是手动提交）

```
package com.mybatis.dao;

public class UserDaoTest {
    
    //sqlSession和userDao定义成成员变量，方便使用;sqlSession线程不安全，**开发不能定义成成员变量**
    private SqlSession sqlSession;
    private UserDao userDao;

    //实际setUp中代码应该在每个Test中重复书写的（避免线程安全问题），这里方便起见做了抽取
    @Before
    public void setUp() throws Exception {
        InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //这里要用成员变量的sqlSession，不能用局部变量，因为在下面的@Test中要使用
        //SqlSession sqlSession = sqlSessionFactory.openSession();//不能用局部变量
        sqlSession = sqlSessionFactory.openSession();
        userDao = new UserDaoImpl(sqlSession);
    }

    @Test
    public void testQueryUserById() {
        System.out.println(this.userDao.queryUserById(1L));
    }

    @Test
    public void testQueryAll() {
        List<User> list = this.userDao.queryAll();
        if (null != list && list.size() > 0) {
            for (User user : list) {
                System.out.println(user);
            }
        }
    }

    @Test
    public void testInsert() {
        User user = new User();
        user.setAge(16);
        user.setBirthday(new Date());
        user.setName("白菜饼");
        user.setPassword("123456");
        user.setSex(2);
        user.setUserName("baicaibing");
        this.userDao.insert(user);
        //提交事务，才会插入数据库
        this.sqlSession.commit();//这里的sqlSession就是传入userDao构造的sqlSession，所以是同一个会话
    }

    @Test
    public void testUpdate() {
        User user = new User();
        user.setId(7L);
        user.setAge(16);
        user.setBirthday(new Date());
        user.setName("白菜饼1");
        user.setPassword("123456");
        user.setSex(2);
        user.setUserName("baicaibing");
        this.userDao.update(user);
        //提交事务，才会更新数据库
        this.sqlSession.commit();//这里的sqlSession就是传入userDao构造的sqlSession，所以是同一个会话
    }

    @Test
    public void testDeleteById() {
        this.userDao.deleteById(7L);
        //提交事务，才会更新数据库
        this.sqlSession.commit();//这里的sqlSession就是传入userDao构造的sqlSession，所以是同一个会话
    }
}
```

#### 目录结构

```
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com
│   │   │       ├── jdbc
│   │   │       │   └── hello
│   │   │       │       └── JdbcTest.java
│   │   │       └── mybatis
│   │   │           ├── dao
│   │   │           │   ├── impl
│   │   │           │   │   └── UserDaoImpl.java
│   │   │           │   └── UserDao.java
│   │   │           ├── hello
│   │   │           │   └── MybatisTest.java
│   │   │           └── pojo
│   │   │               └── User.java
│   │   └── resources
│   │       ├── log4j.properties
│   │       ├── mybatis-config.xml
│   │       └── UserMapper.xml
│   └── test
│       └── java
│           └── com
│               └── mybatis
│                   └── dao
│                       └── UserDaoTest.java
└── target
    ├── classes
    │   ├── com
    │   │   ├── jdbc
    │   │   │   └── hello
    │   │   │       └── JdbcTest.class
    │   │   └── mybatis
    │   │       ├── dao
    │   │       │   ├── impl
    │   │       │   │   └── UserDaoImpl.class
    │   │       │   └── UserDao.class
    │   │       ├── hello
    │   │       │   └── MybatisTest.class
    │   │       └── pojo
    │   │           └── User.class
    │   ├── log4j.properties
    │   ├── META-INF
    │   │   ├── MANIFEST.MF
    │   │   └── maven
    │   │       └── com.test.mybatis
    │   │           └── study_mybatis01
    │   │               ├── pom.properties
    │   │               └── pom.xml
    │   ├── mybatis-config.xml
    │   └── UserMapper.xml
    └── test-classes
        └── com
            └── mybatis
                └── dao
                    └── UserDaoTest.class
```

#### 分析执行过程

- 1.在UserDaoTest的setUp()方法中，创建sqlSession（加载主配置文件mybatis-config.xml），实例化UserDaoImpl(传入sqlSession)；
- 2.@Test方法中，调用dao的方法，读取mapper文件，获得statement，以及传来的参数(id/user)，执行方法，提交事物，数据库更新

```
this.sqlSession.selectOne("UserMapper.selectOne", id);
```

> **数据库字段名user_name和类属性名userName不一致的问题**

- 方案1：sql语句中使用别名AS
- 方案2：使用resultMap
- 方案3：mybatis-config.xml中开启驼峰匹配(只支持经典数据库字段名，匹配经典属性的驼峰命名)

---

II.动态代理

#### 动态代理的目的

在上述Dao的实现类中

- 对sqlsession的使用方式很类似（sqlSession.CRUD(statement, 参数)）
- sql的statement路径硬编码在java代码中
- 接口对应实现类，再对应XxxMapper.xml

综上，mybatis进一步提供了接口的动态代理。即不需要编写Dao实现类，就可以完成接口和映射文件的直接映射。这也是官方推荐的使用方式

> 在Mybatis中持久层接口一般习惯命名为XxxMapper.java

#### 动态代理的约定

> 想要方便，必须遵守一些约定。

- 1. 映射文件的命名空间（namespace）必须是接口的全路径
- 2. 映射文件的statement的id必须和mapper接口的方法名保持一致（所以方法不能重载）
- 3. statement的resultType必须和mapper接口方法的返回类型一致
- 4. statement的parameterType必须和mapper接口方法的参数类型一致（有时也可以省略）

> - 1.namespace本身没有限制，不重复即可。但如果要使用动态代理，namespace必须是接口的全路径
> - 2.通过1和2条，替代原来实现类中接口方法和namespace.id的对应（this.sqlSession.selectOne("UserMapper.selectOne", id)）

#### 动态代理的实现

- 1.修改获取userDao的方式

> 使用SqlSession提供的getMapper()方法

```
@Before
    public void setUp() throws Exception {
        InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //这里要用成员变量的sqlSession，不能用局部变量，因为在下面的@Test中要使用
        //SqlSession sqlSession = sqlSessionFactory.openSession();//不能用局部变量
        sqlSession = sqlSessionFactory.openSession();
        //实现类方式
        //userDao = new UserDaoImpl(sqlSession);
        //动态代理方式
        userDao = sqlSession.getMapper(UserDao.class);
    }

```

- 2.修改映射文件以满足4个约定

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mybatis.dao.UserDao">

    <!-- select类型的statement。id：同一namespace下唯一，resultType：返回结果集的包装类型 -->
    <select id="queryUserById" resultType="com.mybatis.pojo.User">
        SELECT * FROM tb_user WHERE id = #{id}
    </select>
    
    <select id="queryAll" resultType="com.mybatis.pojo.User">
        SELECT * FROM tb_user
    </select>
    
    <insert id="insert" parameterType="com.mybatis.pojo.User">
        INSERT INTO tb_user(id, user_name, password, name, age, sex, birthday, created, updated) 
        VALUES(null, #{userName}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, now(), now())
    </insert>
    
    <update id="update" parameterType="com.mybatis.pojo.User">
        UPDATE tb_user SET user_name = #{userName}, password = #{password}, name = #{name}, age = #{age}, sex = #{sex}, birthday = #{birthday}, updated = now()
        WHERE id = #{id}
    </update>
    
    <delete id="deleteById" parameterType="java.lang.Long">
        DELETE FROM tb_user WHERE id = #{id}
    </delete>
</mapper>
```

III.各元素生命周期